// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `fido.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Url {
    // message fields
    pub url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Url {
    fn default() -> &'a Url {
        <Url as ::protobuf::Message>::default_instance()
    }
}

impl Url {
    pub fn new() -> Url {
        ::std::default::Default::default()
    }

    // string url = 1;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Url {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Url {
        Url::new()
    }

    fn default_instance() -> &'static Url {
        static instance: ::protobuf::rt::LazyV2<Url> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Url::new)
    }
}

impl ::protobuf::Clear for Url {
    fn clear(&mut self) {
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Url {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommonCredentialInfo {
    // message fields
    pub id: ::std::string::String,
    pub raw_id: ::std::vec::Vec<u8>,
    pub client_data_json: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommonCredentialInfo {
    fn default() -> &'a CommonCredentialInfo {
        <CommonCredentialInfo as ::protobuf::Message>::default_instance()
    }
}

impl CommonCredentialInfo {
    pub fn new() -> CommonCredentialInfo {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // bytes raw_id = 2;


    pub fn get_raw_id(&self) -> &[u8] {
        &self.raw_id
    }
    pub fn clear_raw_id(&mut self) {
        self.raw_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_raw_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.raw_id
    }

    // Take field
    pub fn take_raw_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.raw_id, ::std::vec::Vec::new())
    }

    // bytes client_data_json = 3;


    pub fn get_client_data_json(&self) -> &[u8] {
        &self.client_data_json
    }
    pub fn clear_client_data_json(&mut self) {
        self.client_data_json.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_data_json(&mut self, v: ::std::vec::Vec<u8>) {
        self.client_data_json = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_data_json(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.client_data_json
    }

    // Take field
    pub fn take_client_data_json(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.client_data_json, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CommonCredentialInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.raw_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.client_data_json)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.raw_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.raw_id);
        }
        if !self.client_data_json.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.client_data_json);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.raw_id.is_empty() {
            os.write_bytes(2, &self.raw_id)?;
        }
        if !self.client_data_json.is_empty() {
            os.write_bytes(3, &self.client_data_json)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommonCredentialInfo {
        CommonCredentialInfo::new()
    }

    fn default_instance() -> &'static CommonCredentialInfo {
        static instance: ::protobuf::rt::LazyV2<CommonCredentialInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommonCredentialInfo::new)
    }
}

impl ::protobuf::Clear for CommonCredentialInfo {
    fn clear(&mut self) {
        self.id.clear();
        self.raw_id.clear();
        self.client_data_json.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CommonCredentialInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MakeCredentialAuthenticatorResponse {
    // message fields
    pub info: ::protobuf::SingularPtrField<CommonCredentialInfo>,
    pub attestation_object: ::std::vec::Vec<u8>,
    pub transports: ::std::vec::Vec<AuthenticatorTransport>,
    pub echo_hmac_create_secret: bool,
    pub hmac_create_secret: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MakeCredentialAuthenticatorResponse {
    fn default() -> &'a MakeCredentialAuthenticatorResponse {
        <MakeCredentialAuthenticatorResponse as ::protobuf::Message>::default_instance()
    }
}

impl MakeCredentialAuthenticatorResponse {
    pub fn new() -> MakeCredentialAuthenticatorResponse {
        ::std::default::Default::default()
    }

    // .cryptohome.fido.CommonCredentialInfo info = 1;


    pub fn get_info(&self) -> &CommonCredentialInfo {
        self.info.as_ref().unwrap_or_else(|| <CommonCredentialInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CommonCredentialInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CommonCredentialInfo {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CommonCredentialInfo {
        self.info.take().unwrap_or_else(|| CommonCredentialInfo::new())
    }

    // bytes attestation_object = 2;


    pub fn get_attestation_object(&self) -> &[u8] {
        &self.attestation_object
    }
    pub fn clear_attestation_object(&mut self) {
        self.attestation_object.clear();
    }

    // Param is passed by value, moved
    pub fn set_attestation_object(&mut self, v: ::std::vec::Vec<u8>) {
        self.attestation_object = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attestation_object(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.attestation_object
    }

    // Take field
    pub fn take_attestation_object(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.attestation_object, ::std::vec::Vec::new())
    }

    // repeated .cryptohome.fido.AuthenticatorTransport transports = 3;


    pub fn get_transports(&self) -> &[AuthenticatorTransport] {
        &self.transports
    }
    pub fn clear_transports(&mut self) {
        self.transports.clear();
    }

    // Param is passed by value, moved
    pub fn set_transports(&mut self, v: ::std::vec::Vec<AuthenticatorTransport>) {
        self.transports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transports(&mut self) -> &mut ::std::vec::Vec<AuthenticatorTransport> {
        &mut self.transports
    }

    // Take field
    pub fn take_transports(&mut self) -> ::std::vec::Vec<AuthenticatorTransport> {
        ::std::mem::replace(&mut self.transports, ::std::vec::Vec::new())
    }

    // bool echo_hmac_create_secret = 4;


    pub fn get_echo_hmac_create_secret(&self) -> bool {
        self.echo_hmac_create_secret
    }
    pub fn clear_echo_hmac_create_secret(&mut self) {
        self.echo_hmac_create_secret = false;
    }

    // Param is passed by value, moved
    pub fn set_echo_hmac_create_secret(&mut self, v: bool) {
        self.echo_hmac_create_secret = v;
    }

    // bool hmac_create_secret = 5;


    pub fn get_hmac_create_secret(&self) -> bool {
        self.hmac_create_secret
    }
    pub fn clear_hmac_create_secret(&mut self) {
        self.hmac_create_secret = false;
    }

    // Param is passed by value, moved
    pub fn set_hmac_create_secret(&mut self, v: bool) {
        self.hmac_create_secret = v;
    }
}

impl ::protobuf::Message for MakeCredentialAuthenticatorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.attestation_object)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.transports, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.echo_hmac_create_secret = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hmac_create_secret = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.attestation_object.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.attestation_object);
        }
        for value in &self.transports {
            my_size += ::protobuf::rt::enum_size(3, *value);
        };
        if self.echo_hmac_create_secret != false {
            my_size += 2;
        }
        if self.hmac_create_secret != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.attestation_object.is_empty() {
            os.write_bytes(2, &self.attestation_object)?;
        }
        for v in &self.transports {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(v))?;
        };
        if self.echo_hmac_create_secret != false {
            os.write_bool(4, self.echo_hmac_create_secret)?;
        }
        if self.hmac_create_secret != false {
            os.write_bool(5, self.hmac_create_secret)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MakeCredentialAuthenticatorResponse {
        MakeCredentialAuthenticatorResponse::new()
    }

    fn default_instance() -> &'static MakeCredentialAuthenticatorResponse {
        static instance: ::protobuf::rt::LazyV2<MakeCredentialAuthenticatorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MakeCredentialAuthenticatorResponse::new)
    }
}

impl ::protobuf::Clear for MakeCredentialAuthenticatorResponse {
    fn clear(&mut self) {
        self.info.clear();
        self.attestation_object.clear();
        self.transports.clear();
        self.echo_hmac_create_secret = false;
        self.hmac_create_secret = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MakeCredentialAuthenticatorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAssertionAuthenticatorResponse {
    // message fields
    pub info: ::protobuf::SingularPtrField<CommonCredentialInfo>,
    pub authenticator_data: ::std::vec::Vec<u8>,
    pub signature: ::std::vec::Vec<u8>,
    pub user_handle: ::std::vec::Vec<u8>,
    pub echo_appid_extension: bool,
    pub appid_extension: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAssertionAuthenticatorResponse {
    fn default() -> &'a GetAssertionAuthenticatorResponse {
        <GetAssertionAuthenticatorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAssertionAuthenticatorResponse {
    pub fn new() -> GetAssertionAuthenticatorResponse {
        ::std::default::Default::default()
    }

    // .cryptohome.fido.CommonCredentialInfo info = 1;


    pub fn get_info(&self) -> &CommonCredentialInfo {
        self.info.as_ref().unwrap_or_else(|| <CommonCredentialInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CommonCredentialInfo) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CommonCredentialInfo {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> CommonCredentialInfo {
        self.info.take().unwrap_or_else(|| CommonCredentialInfo::new())
    }

    // bytes authenticator_data = 2;


    pub fn get_authenticator_data(&self) -> &[u8] {
        &self.authenticator_data
    }
    pub fn clear_authenticator_data(&mut self) {
        self.authenticator_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_authenticator_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.authenticator_data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authenticator_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.authenticator_data
    }

    // Take field
    pub fn take_authenticator_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.authenticator_data, ::std::vec::Vec::new())
    }

    // bytes signature = 3;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // bytes user_handle = 4;


    pub fn get_user_handle(&self) -> &[u8] {
        &self.user_handle
    }
    pub fn clear_user_handle(&mut self) {
        self.user_handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_handle(&mut self, v: ::std::vec::Vec<u8>) {
        self.user_handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_handle(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.user_handle
    }

    // Take field
    pub fn take_user_handle(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.user_handle, ::std::vec::Vec::new())
    }

    // bool echo_appid_extension = 5;


    pub fn get_echo_appid_extension(&self) -> bool {
        self.echo_appid_extension
    }
    pub fn clear_echo_appid_extension(&mut self) {
        self.echo_appid_extension = false;
    }

    // Param is passed by value, moved
    pub fn set_echo_appid_extension(&mut self, v: bool) {
        self.echo_appid_extension = v;
    }

    // bool appid_extension = 6;


    pub fn get_appid_extension(&self) -> bool {
        self.appid_extension
    }
    pub fn clear_appid_extension(&mut self) {
        self.appid_extension = false;
    }

    // Param is passed by value, moved
    pub fn set_appid_extension(&mut self, v: bool) {
        self.appid_extension = v;
    }
}

impl ::protobuf::Message for GetAssertionAuthenticatorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.authenticator_data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.user_handle)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.echo_appid_extension = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.appid_extension = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.authenticator_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.authenticator_data);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.signature);
        }
        if !self.user_handle.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.user_handle);
        }
        if self.echo_appid_extension != false {
            my_size += 2;
        }
        if self.appid_extension != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.authenticator_data.is_empty() {
            os.write_bytes(2, &self.authenticator_data)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(3, &self.signature)?;
        }
        if !self.user_handle.is_empty() {
            os.write_bytes(4, &self.user_handle)?;
        }
        if self.echo_appid_extension != false {
            os.write_bool(5, self.echo_appid_extension)?;
        }
        if self.appid_extension != false {
            os.write_bool(6, self.appid_extension)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAssertionAuthenticatorResponse {
        GetAssertionAuthenticatorResponse::new()
    }

    fn default_instance() -> &'static GetAssertionAuthenticatorResponse {
        static instance: ::protobuf::rt::LazyV2<GetAssertionAuthenticatorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAssertionAuthenticatorResponse::new)
    }
}

impl ::protobuf::Clear for GetAssertionAuthenticatorResponse {
    fn clear(&mut self) {
        self.info.clear();
        self.authenticator_data.clear();
        self.signature.clear();
        self.user_handle.clear();
        self.echo_appid_extension = false;
        self.appid_extension = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAssertionAuthenticatorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PublicKeyCredentialRpEntity {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub icon: ::protobuf::SingularPtrField<Url>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublicKeyCredentialRpEntity {
    fn default() -> &'a PublicKeyCredentialRpEntity {
        <PublicKeyCredentialRpEntity as ::protobuf::Message>::default_instance()
    }
}

impl PublicKeyCredentialRpEntity {
    pub fn new() -> PublicKeyCredentialRpEntity {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .cryptohome.fido.Url icon = 3;


    pub fn get_icon(&self) -> &Url {
        self.icon.as_ref().unwrap_or_else(|| <Url as ::protobuf::Message>::default_instance())
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: Url) {
        self.icon = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut Url {
        if self.icon.is_none() {
            self.icon.set_default();
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> Url {
        self.icon.take().unwrap_or_else(|| Url::new())
    }
}

impl ::protobuf::Message for PublicKeyCredentialRpEntity {
    fn is_initialized(&self) -> bool {
        for v in &self.icon {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.icon)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(ref v) = self.icon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(ref v) = self.icon.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublicKeyCredentialRpEntity {
        PublicKeyCredentialRpEntity::new()
    }

    fn default_instance() -> &'static PublicKeyCredentialRpEntity {
        static instance: ::protobuf::rt::LazyV2<PublicKeyCredentialRpEntity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PublicKeyCredentialRpEntity::new)
    }
}

impl ::protobuf::Clear for PublicKeyCredentialRpEntity {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.icon.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicKeyCredentialRpEntity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PublicKeyCredentialUserEntity {
    // message fields
    pub id: ::std::vec::Vec<u8>,
    pub name: ::std::string::String,
    pub icon: ::protobuf::SingularPtrField<Url>,
    pub display_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublicKeyCredentialUserEntity {
    fn default() -> &'a PublicKeyCredentialUserEntity {
        <PublicKeyCredentialUserEntity as ::protobuf::Message>::default_instance()
    }
}

impl PublicKeyCredentialUserEntity {
    pub fn new() -> PublicKeyCredentialUserEntity {
        ::std::default::Default::default()
    }

    // bytes id = 1;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .cryptohome.fido.Url icon = 3;


    pub fn get_icon(&self) -> &Url {
        self.icon.as_ref().unwrap_or_else(|| <Url as ::protobuf::Message>::default_instance())
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: Url) {
        self.icon = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut Url {
        if self.icon.is_none() {
            self.icon.set_default();
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> Url {
        self.icon.take().unwrap_or_else(|| Url::new())
    }

    // string display_name = 4;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PublicKeyCredentialUserEntity {
    fn is_initialized(&self) -> bool {
        for v in &self.icon {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.icon)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(ref v) = self.icon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.display_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(ref v) = self.icon.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(4, &self.display_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublicKeyCredentialUserEntity {
        PublicKeyCredentialUserEntity::new()
    }

    fn default_instance() -> &'static PublicKeyCredentialUserEntity {
        static instance: ::protobuf::rt::LazyV2<PublicKeyCredentialUserEntity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PublicKeyCredentialUserEntity::new)
    }
}

impl ::protobuf::Clear for PublicKeyCredentialUserEntity {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.icon.clear();
        self.display_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicKeyCredentialUserEntity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PublicKeyCredentialParameters {
    // message fields
    pub field_type: PublicKeyCredentialType,
    pub algorithm_identifier: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublicKeyCredentialParameters {
    fn default() -> &'a PublicKeyCredentialParameters {
        <PublicKeyCredentialParameters as ::protobuf::Message>::default_instance()
    }
}

impl PublicKeyCredentialParameters {
    pub fn new() -> PublicKeyCredentialParameters {
        ::std::default::Default::default()
    }

    // .cryptohome.fido.PublicKeyCredentialType type = 1;


    pub fn get_field_type(&self) -> PublicKeyCredentialType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PublicKeyCredentialType::PUBLIC_KEY;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PublicKeyCredentialType) {
        self.field_type = v;
    }

    // int32 algorithm_identifier = 2;


    pub fn get_algorithm_identifier(&self) -> i32 {
        self.algorithm_identifier
    }
    pub fn clear_algorithm_identifier(&mut self) {
        self.algorithm_identifier = 0;
    }

    // Param is passed by value, moved
    pub fn set_algorithm_identifier(&mut self, v: i32) {
        self.algorithm_identifier = v;
    }
}

impl ::protobuf::Message for PublicKeyCredentialParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.algorithm_identifier = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != PublicKeyCredentialType::PUBLIC_KEY {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.algorithm_identifier != 0 {
            my_size += ::protobuf::rt::value_size(2, self.algorithm_identifier, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != PublicKeyCredentialType::PUBLIC_KEY {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.algorithm_identifier != 0 {
            os.write_int32(2, self.algorithm_identifier)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublicKeyCredentialParameters {
        PublicKeyCredentialParameters::new()
    }

    fn default_instance() -> &'static PublicKeyCredentialParameters {
        static instance: ::protobuf::rt::LazyV2<PublicKeyCredentialParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PublicKeyCredentialParameters::new)
    }
}

impl ::protobuf::Clear for PublicKeyCredentialParameters {
    fn clear(&mut self) {
        self.field_type = PublicKeyCredentialType::PUBLIC_KEY;
        self.algorithm_identifier = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicKeyCredentialParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CableAuthentication {
    // message fields
    pub version: u32,
    pub client_eid: ::std::vec::Vec<u8>,
    pub authenticator_eid: ::std::vec::Vec<u8>,
    pub session_pre_key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CableAuthentication {
    fn default() -> &'a CableAuthentication {
        <CableAuthentication as ::protobuf::Message>::default_instance()
    }
}

impl CableAuthentication {
    pub fn new() -> CableAuthentication {
        ::std::default::Default::default()
    }

    // uint32 version = 1;


    pub fn get_version(&self) -> u32 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = v;
    }

    // bytes client_eid = 2;


    pub fn get_client_eid(&self) -> &[u8] {
        &self.client_eid
    }
    pub fn clear_client_eid(&mut self) {
        self.client_eid.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_eid(&mut self, v: ::std::vec::Vec<u8>) {
        self.client_eid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_eid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.client_eid
    }

    // Take field
    pub fn take_client_eid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.client_eid, ::std::vec::Vec::new())
    }

    // bytes authenticator_eid = 3;


    pub fn get_authenticator_eid(&self) -> &[u8] {
        &self.authenticator_eid
    }
    pub fn clear_authenticator_eid(&mut self) {
        self.authenticator_eid.clear();
    }

    // Param is passed by value, moved
    pub fn set_authenticator_eid(&mut self, v: ::std::vec::Vec<u8>) {
        self.authenticator_eid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authenticator_eid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.authenticator_eid
    }

    // Take field
    pub fn take_authenticator_eid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.authenticator_eid, ::std::vec::Vec::new())
    }

    // bytes session_pre_key = 4;


    pub fn get_session_pre_key(&self) -> &[u8] {
        &self.session_pre_key
    }
    pub fn clear_session_pre_key(&mut self) {
        self.session_pre_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_pre_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.session_pre_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_pre_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.session_pre_key
    }

    // Take field
    pub fn take_session_pre_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.session_pre_key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CableAuthentication {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.version = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.client_eid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.authenticator_eid)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.session_pre_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(1, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.client_eid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.client_eid);
        }
        if !self.authenticator_eid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.authenticator_eid);
        }
        if !self.session_pre_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.session_pre_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.version != 0 {
            os.write_uint32(1, self.version)?;
        }
        if !self.client_eid.is_empty() {
            os.write_bytes(2, &self.client_eid)?;
        }
        if !self.authenticator_eid.is_empty() {
            os.write_bytes(3, &self.authenticator_eid)?;
        }
        if !self.session_pre_key.is_empty() {
            os.write_bytes(4, &self.session_pre_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CableAuthentication {
        CableAuthentication::new()
    }

    fn default_instance() -> &'static CableAuthentication {
        static instance: ::protobuf::rt::LazyV2<CableAuthentication> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CableAuthentication::new)
    }
}

impl ::protobuf::Clear for CableAuthentication {
    fn clear(&mut self) {
        self.version = 0;
        self.client_eid.clear();
        self.authenticator_eid.clear();
        self.session_pre_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CableAuthentication {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CableRegistration {
    // message fields
    pub versions: ::std::vec::Vec<u8>,
    pub relying_party_public_key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CableRegistration {
    fn default() -> &'a CableRegistration {
        <CableRegistration as ::protobuf::Message>::default_instance()
    }
}

impl CableRegistration {
    pub fn new() -> CableRegistration {
        ::std::default::Default::default()
    }

    // bytes versions = 1;


    pub fn get_versions(&self) -> &[u8] {
        &self.versions
    }
    pub fn clear_versions(&mut self) {
        self.versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_versions(&mut self, v: ::std::vec::Vec<u8>) {
        self.versions = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_versions(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.versions
    }

    // Take field
    pub fn take_versions(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.versions, ::std::vec::Vec::new())
    }

    // bytes relying_party_public_key = 2;


    pub fn get_relying_party_public_key(&self) -> &[u8] {
        &self.relying_party_public_key
    }
    pub fn clear_relying_party_public_key(&mut self) {
        self.relying_party_public_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_relying_party_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.relying_party_public_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relying_party_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.relying_party_public_key
    }

    // Take field
    pub fn take_relying_party_public_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.relying_party_public_key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CableRegistration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.versions)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.relying_party_public_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.versions.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.versions);
        }
        if !self.relying_party_public_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.relying_party_public_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.versions.is_empty() {
            os.write_bytes(1, &self.versions)?;
        }
        if !self.relying_party_public_key.is_empty() {
            os.write_bytes(2, &self.relying_party_public_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CableRegistration {
        CableRegistration::new()
    }

    fn default_instance() -> &'static CableRegistration {
        static instance: ::protobuf::rt::LazyV2<CableRegistration> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CableRegistration::new)
    }
}

impl ::protobuf::Clear for CableRegistration {
    fn clear(&mut self) {
        self.versions.clear();
        self.relying_party_public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CableRegistration {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PublicKeyCredentialRequestOptions {
    // message fields
    pub challenge: ::std::vec::Vec<u8>,
    pub adjusted_timeout: i64,
    pub relying_party_id: ::std::string::String,
    pub allow_credentials: ::protobuf::RepeatedField<PublicKeyCredentialDescriptor>,
    pub user_verification: UserVerificationRequirement,
    pub appid: ::std::string::String,
    pub cable_authentication_data: ::protobuf::RepeatedField<CableAuthentication>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublicKeyCredentialRequestOptions {
    fn default() -> &'a PublicKeyCredentialRequestOptions {
        <PublicKeyCredentialRequestOptions as ::protobuf::Message>::default_instance()
    }
}

impl PublicKeyCredentialRequestOptions {
    pub fn new() -> PublicKeyCredentialRequestOptions {
        ::std::default::Default::default()
    }

    // bytes challenge = 1;


    pub fn get_challenge(&self) -> &[u8] {
        &self.challenge
    }
    pub fn clear_challenge(&mut self) {
        self.challenge.clear();
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: ::std::vec::Vec<u8>) {
        self.challenge = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.challenge
    }

    // Take field
    pub fn take_challenge(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.challenge, ::std::vec::Vec::new())
    }

    // int64 adjusted_timeout = 2;


    pub fn get_adjusted_timeout(&self) -> i64 {
        self.adjusted_timeout
    }
    pub fn clear_adjusted_timeout(&mut self) {
        self.adjusted_timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_adjusted_timeout(&mut self, v: i64) {
        self.adjusted_timeout = v;
    }

    // string relying_party_id = 3;


    pub fn get_relying_party_id(&self) -> &str {
        &self.relying_party_id
    }
    pub fn clear_relying_party_id(&mut self) {
        self.relying_party_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_relying_party_id(&mut self, v: ::std::string::String) {
        self.relying_party_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relying_party_id(&mut self) -> &mut ::std::string::String {
        &mut self.relying_party_id
    }

    // Take field
    pub fn take_relying_party_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.relying_party_id, ::std::string::String::new())
    }

    // repeated .cryptohome.fido.PublicKeyCredentialDescriptor allow_credentials = 4;


    pub fn get_allow_credentials(&self) -> &[PublicKeyCredentialDescriptor] {
        &self.allow_credentials
    }
    pub fn clear_allow_credentials(&mut self) {
        self.allow_credentials.clear();
    }

    // Param is passed by value, moved
    pub fn set_allow_credentials(&mut self, v: ::protobuf::RepeatedField<PublicKeyCredentialDescriptor>) {
        self.allow_credentials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allow_credentials(&mut self) -> &mut ::protobuf::RepeatedField<PublicKeyCredentialDescriptor> {
        &mut self.allow_credentials
    }

    // Take field
    pub fn take_allow_credentials(&mut self) -> ::protobuf::RepeatedField<PublicKeyCredentialDescriptor> {
        ::std::mem::replace(&mut self.allow_credentials, ::protobuf::RepeatedField::new())
    }

    // .cryptohome.fido.UserVerificationRequirement user_verification = 5;


    pub fn get_user_verification(&self) -> UserVerificationRequirement {
        self.user_verification
    }
    pub fn clear_user_verification(&mut self) {
        self.user_verification = UserVerificationRequirement::REQUIRED;
    }

    // Param is passed by value, moved
    pub fn set_user_verification(&mut self, v: UserVerificationRequirement) {
        self.user_verification = v;
    }

    // string appid = 6;


    pub fn get_appid(&self) -> &str {
        &self.appid
    }
    pub fn clear_appid(&mut self) {
        self.appid.clear();
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: ::std::string::String) {
        self.appid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appid(&mut self) -> &mut ::std::string::String {
        &mut self.appid
    }

    // Take field
    pub fn take_appid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.appid, ::std::string::String::new())
    }

    // repeated .cryptohome.fido.CableAuthentication cable_authentication_data = 7;


    pub fn get_cable_authentication_data(&self) -> &[CableAuthentication] {
        &self.cable_authentication_data
    }
    pub fn clear_cable_authentication_data(&mut self) {
        self.cable_authentication_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_cable_authentication_data(&mut self, v: ::protobuf::RepeatedField<CableAuthentication>) {
        self.cable_authentication_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cable_authentication_data(&mut self) -> &mut ::protobuf::RepeatedField<CableAuthentication> {
        &mut self.cable_authentication_data
    }

    // Take field
    pub fn take_cable_authentication_data(&mut self) -> ::protobuf::RepeatedField<CableAuthentication> {
        ::std::mem::replace(&mut self.cable_authentication_data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PublicKeyCredentialRequestOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.allow_credentials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cable_authentication_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.challenge)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.adjusted_timeout = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.relying_party_id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.allow_credentials)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.user_verification, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.appid)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cable_authentication_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.challenge.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.challenge);
        }
        if self.adjusted_timeout != 0 {
            my_size += ::protobuf::rt::value_size(2, self.adjusted_timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.relying_party_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.relying_party_id);
        }
        for value in &self.allow_credentials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.user_verification != UserVerificationRequirement::REQUIRED {
            my_size += ::protobuf::rt::enum_size(5, self.user_verification);
        }
        if !self.appid.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.appid);
        }
        for value in &self.cable_authentication_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.challenge.is_empty() {
            os.write_bytes(1, &self.challenge)?;
        }
        if self.adjusted_timeout != 0 {
            os.write_int64(2, self.adjusted_timeout)?;
        }
        if !self.relying_party_id.is_empty() {
            os.write_string(3, &self.relying_party_id)?;
        }
        for v in &self.allow_credentials {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.user_verification != UserVerificationRequirement::REQUIRED {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.user_verification))?;
        }
        if !self.appid.is_empty() {
            os.write_string(6, &self.appid)?;
        }
        for v in &self.cable_authentication_data {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublicKeyCredentialRequestOptions {
        PublicKeyCredentialRequestOptions::new()
    }

    fn default_instance() -> &'static PublicKeyCredentialRequestOptions {
        static instance: ::protobuf::rt::LazyV2<PublicKeyCredentialRequestOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PublicKeyCredentialRequestOptions::new)
    }
}

impl ::protobuf::Clear for PublicKeyCredentialRequestOptions {
    fn clear(&mut self) {
        self.challenge.clear();
        self.adjusted_timeout = 0;
        self.relying_party_id.clear();
        self.allow_credentials.clear();
        self.user_verification = UserVerificationRequirement::REQUIRED;
        self.appid.clear();
        self.cable_authentication_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicKeyCredentialRequestOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AuthenticatorSelectionCriteria {
    // message fields
    pub authenticator_attachment: AuthenticatorAttachment,
    pub require_resident_key: bool,
    pub user_verification: UserVerificationRequirement,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthenticatorSelectionCriteria {
    fn default() -> &'a AuthenticatorSelectionCriteria {
        <AuthenticatorSelectionCriteria as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticatorSelectionCriteria {
    pub fn new() -> AuthenticatorSelectionCriteria {
        ::std::default::Default::default()
    }

    // .cryptohome.fido.AuthenticatorAttachment authenticator_attachment = 1;


    pub fn get_authenticator_attachment(&self) -> AuthenticatorAttachment {
        self.authenticator_attachment
    }
    pub fn clear_authenticator_attachment(&mut self) {
        self.authenticator_attachment = AuthenticatorAttachment::NO_PREFERENCE;
    }

    // Param is passed by value, moved
    pub fn set_authenticator_attachment(&mut self, v: AuthenticatorAttachment) {
        self.authenticator_attachment = v;
    }

    // bool require_resident_key = 2;


    pub fn get_require_resident_key(&self) -> bool {
        self.require_resident_key
    }
    pub fn clear_require_resident_key(&mut self) {
        self.require_resident_key = false;
    }

    // Param is passed by value, moved
    pub fn set_require_resident_key(&mut self, v: bool) {
        self.require_resident_key = v;
    }

    // .cryptohome.fido.UserVerificationRequirement user_verification = 3;


    pub fn get_user_verification(&self) -> UserVerificationRequirement {
        self.user_verification
    }
    pub fn clear_user_verification(&mut self) {
        self.user_verification = UserVerificationRequirement::REQUIRED;
    }

    // Param is passed by value, moved
    pub fn set_user_verification(&mut self, v: UserVerificationRequirement) {
        self.user_verification = v;
    }
}

impl ::protobuf::Message for AuthenticatorSelectionCriteria {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.authenticator_attachment, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.require_resident_key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.user_verification, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.authenticator_attachment != AuthenticatorAttachment::NO_PREFERENCE {
            my_size += ::protobuf::rt::enum_size(1, self.authenticator_attachment);
        }
        if self.require_resident_key != false {
            my_size += 2;
        }
        if self.user_verification != UserVerificationRequirement::REQUIRED {
            my_size += ::protobuf::rt::enum_size(3, self.user_verification);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.authenticator_attachment != AuthenticatorAttachment::NO_PREFERENCE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.authenticator_attachment))?;
        }
        if self.require_resident_key != false {
            os.write_bool(2, self.require_resident_key)?;
        }
        if self.user_verification != UserVerificationRequirement::REQUIRED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.user_verification))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticatorSelectionCriteria {
        AuthenticatorSelectionCriteria::new()
    }

    fn default_instance() -> &'static AuthenticatorSelectionCriteria {
        static instance: ::protobuf::rt::LazyV2<AuthenticatorSelectionCriteria> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthenticatorSelectionCriteria::new)
    }
}

impl ::protobuf::Clear for AuthenticatorSelectionCriteria {
    fn clear(&mut self) {
        self.authenticator_attachment = AuthenticatorAttachment::NO_PREFERENCE;
        self.require_resident_key = false;
        self.user_verification = UserVerificationRequirement::REQUIRED;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticatorSelectionCriteria {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PublicKeyCredentialCreationOptions {
    // message fields
    pub relying_party: ::protobuf::SingularPtrField<PublicKeyCredentialRpEntity>,
    pub user: ::protobuf::SingularPtrField<PublicKeyCredentialUserEntity>,
    pub challenge: ::std::vec::Vec<u8>,
    pub public_key_parameters: ::protobuf::RepeatedField<PublicKeyCredentialParameters>,
    pub adjusted_timeout: i64,
    pub exclude_credentials: ::protobuf::RepeatedField<PublicKeyCredentialDescriptor>,
    pub authenticator_selection: ::protobuf::SingularPtrField<AuthenticatorSelectionCriteria>,
    pub attestation: AttestationConveyancePreference,
    pub cable_registration_data: ::protobuf::SingularPtrField<CableRegistration>,
    pub hmac_create_secret: bool,
    pub protection_policy: ProtectionPolicy,
    pub enforce_protection_policy: bool,
    pub appid_exclude: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublicKeyCredentialCreationOptions {
    fn default() -> &'a PublicKeyCredentialCreationOptions {
        <PublicKeyCredentialCreationOptions as ::protobuf::Message>::default_instance()
    }
}

impl PublicKeyCredentialCreationOptions {
    pub fn new() -> PublicKeyCredentialCreationOptions {
        ::std::default::Default::default()
    }

    // .cryptohome.fido.PublicKeyCredentialRpEntity relying_party = 1;


    pub fn get_relying_party(&self) -> &PublicKeyCredentialRpEntity {
        self.relying_party.as_ref().unwrap_or_else(|| <PublicKeyCredentialRpEntity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_relying_party(&mut self) {
        self.relying_party.clear();
    }

    pub fn has_relying_party(&self) -> bool {
        self.relying_party.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relying_party(&mut self, v: PublicKeyCredentialRpEntity) {
        self.relying_party = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relying_party(&mut self) -> &mut PublicKeyCredentialRpEntity {
        if self.relying_party.is_none() {
            self.relying_party.set_default();
        }
        self.relying_party.as_mut().unwrap()
    }

    // Take field
    pub fn take_relying_party(&mut self) -> PublicKeyCredentialRpEntity {
        self.relying_party.take().unwrap_or_else(|| PublicKeyCredentialRpEntity::new())
    }

    // .cryptohome.fido.PublicKeyCredentialUserEntity user = 2;


    pub fn get_user(&self) -> &PublicKeyCredentialUserEntity {
        self.user.as_ref().unwrap_or_else(|| <PublicKeyCredentialUserEntity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: PublicKeyCredentialUserEntity) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut PublicKeyCredentialUserEntity {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> PublicKeyCredentialUserEntity {
        self.user.take().unwrap_or_else(|| PublicKeyCredentialUserEntity::new())
    }

    // bytes challenge = 3;


    pub fn get_challenge(&self) -> &[u8] {
        &self.challenge
    }
    pub fn clear_challenge(&mut self) {
        self.challenge.clear();
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: ::std::vec::Vec<u8>) {
        self.challenge = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.challenge
    }

    // Take field
    pub fn take_challenge(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.challenge, ::std::vec::Vec::new())
    }

    // repeated .cryptohome.fido.PublicKeyCredentialParameters public_key_parameters = 4;


    pub fn get_public_key_parameters(&self) -> &[PublicKeyCredentialParameters] {
        &self.public_key_parameters
    }
    pub fn clear_public_key_parameters(&mut self) {
        self.public_key_parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_key_parameters(&mut self, v: ::protobuf::RepeatedField<PublicKeyCredentialParameters>) {
        self.public_key_parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_public_key_parameters(&mut self) -> &mut ::protobuf::RepeatedField<PublicKeyCredentialParameters> {
        &mut self.public_key_parameters
    }

    // Take field
    pub fn take_public_key_parameters(&mut self) -> ::protobuf::RepeatedField<PublicKeyCredentialParameters> {
        ::std::mem::replace(&mut self.public_key_parameters, ::protobuf::RepeatedField::new())
    }

    // int64 adjusted_timeout = 5;


    pub fn get_adjusted_timeout(&self) -> i64 {
        self.adjusted_timeout
    }
    pub fn clear_adjusted_timeout(&mut self) {
        self.adjusted_timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_adjusted_timeout(&mut self, v: i64) {
        self.adjusted_timeout = v;
    }

    // repeated .cryptohome.fido.PublicKeyCredentialDescriptor exclude_credentials = 6;


    pub fn get_exclude_credentials(&self) -> &[PublicKeyCredentialDescriptor] {
        &self.exclude_credentials
    }
    pub fn clear_exclude_credentials(&mut self) {
        self.exclude_credentials.clear();
    }

    // Param is passed by value, moved
    pub fn set_exclude_credentials(&mut self, v: ::protobuf::RepeatedField<PublicKeyCredentialDescriptor>) {
        self.exclude_credentials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exclude_credentials(&mut self) -> &mut ::protobuf::RepeatedField<PublicKeyCredentialDescriptor> {
        &mut self.exclude_credentials
    }

    // Take field
    pub fn take_exclude_credentials(&mut self) -> ::protobuf::RepeatedField<PublicKeyCredentialDescriptor> {
        ::std::mem::replace(&mut self.exclude_credentials, ::protobuf::RepeatedField::new())
    }

    // .cryptohome.fido.AuthenticatorSelectionCriteria authenticator_selection = 7;


    pub fn get_authenticator_selection(&self) -> &AuthenticatorSelectionCriteria {
        self.authenticator_selection.as_ref().unwrap_or_else(|| <AuthenticatorSelectionCriteria as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authenticator_selection(&mut self) {
        self.authenticator_selection.clear();
    }

    pub fn has_authenticator_selection(&self) -> bool {
        self.authenticator_selection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authenticator_selection(&mut self, v: AuthenticatorSelectionCriteria) {
        self.authenticator_selection = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authenticator_selection(&mut self) -> &mut AuthenticatorSelectionCriteria {
        if self.authenticator_selection.is_none() {
            self.authenticator_selection.set_default();
        }
        self.authenticator_selection.as_mut().unwrap()
    }

    // Take field
    pub fn take_authenticator_selection(&mut self) -> AuthenticatorSelectionCriteria {
        self.authenticator_selection.take().unwrap_or_else(|| AuthenticatorSelectionCriteria::new())
    }

    // .cryptohome.fido.AttestationConveyancePreference attestation = 8;


    pub fn get_attestation(&self) -> AttestationConveyancePreference {
        self.attestation
    }
    pub fn clear_attestation(&mut self) {
        self.attestation = AttestationConveyancePreference::NONE_ATTESTATION_PREFERENCE;
    }

    // Param is passed by value, moved
    pub fn set_attestation(&mut self, v: AttestationConveyancePreference) {
        self.attestation = v;
    }

    // .cryptohome.fido.CableRegistration cable_registration_data = 9;


    pub fn get_cable_registration_data(&self) -> &CableRegistration {
        self.cable_registration_data.as_ref().unwrap_or_else(|| <CableRegistration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cable_registration_data(&mut self) {
        self.cable_registration_data.clear();
    }

    pub fn has_cable_registration_data(&self) -> bool {
        self.cable_registration_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cable_registration_data(&mut self, v: CableRegistration) {
        self.cable_registration_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cable_registration_data(&mut self) -> &mut CableRegistration {
        if self.cable_registration_data.is_none() {
            self.cable_registration_data.set_default();
        }
        self.cable_registration_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_cable_registration_data(&mut self) -> CableRegistration {
        self.cable_registration_data.take().unwrap_or_else(|| CableRegistration::new())
    }

    // bool hmac_create_secret = 10;


    pub fn get_hmac_create_secret(&self) -> bool {
        self.hmac_create_secret
    }
    pub fn clear_hmac_create_secret(&mut self) {
        self.hmac_create_secret = false;
    }

    // Param is passed by value, moved
    pub fn set_hmac_create_secret(&mut self, v: bool) {
        self.hmac_create_secret = v;
    }

    // .cryptohome.fido.ProtectionPolicy protection_policy = 11;


    pub fn get_protection_policy(&self) -> ProtectionPolicy {
        self.protection_policy
    }
    pub fn clear_protection_policy(&mut self) {
        self.protection_policy = ProtectionPolicy::UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_protection_policy(&mut self, v: ProtectionPolicy) {
        self.protection_policy = v;
    }

    // bool enforce_protection_policy = 12;


    pub fn get_enforce_protection_policy(&self) -> bool {
        self.enforce_protection_policy
    }
    pub fn clear_enforce_protection_policy(&mut self) {
        self.enforce_protection_policy = false;
    }

    // Param is passed by value, moved
    pub fn set_enforce_protection_policy(&mut self, v: bool) {
        self.enforce_protection_policy = v;
    }

    // string appid_exclude = 13;


    pub fn get_appid_exclude(&self) -> &str {
        &self.appid_exclude
    }
    pub fn clear_appid_exclude(&mut self) {
        self.appid_exclude.clear();
    }

    // Param is passed by value, moved
    pub fn set_appid_exclude(&mut self, v: ::std::string::String) {
        self.appid_exclude = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appid_exclude(&mut self) -> &mut ::std::string::String {
        &mut self.appid_exclude
    }

    // Take field
    pub fn take_appid_exclude(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.appid_exclude, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PublicKeyCredentialCreationOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.relying_party {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.public_key_parameters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exclude_credentials {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authenticator_selection {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cable_registration_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.relying_party)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.challenge)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.public_key_parameters)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.adjusted_timeout = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.exclude_credentials)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authenticator_selection)?;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.attestation, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cable_registration_data)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hmac_create_secret = tmp;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.protection_policy, 11, &mut self.unknown_fields)?
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enforce_protection_policy = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.appid_exclude)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.relying_party.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.challenge.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.challenge);
        }
        for value in &self.public_key_parameters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.adjusted_timeout != 0 {
            my_size += ::protobuf::rt::value_size(5, self.adjusted_timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.exclude_credentials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.authenticator_selection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.attestation != AttestationConveyancePreference::NONE_ATTESTATION_PREFERENCE {
            my_size += ::protobuf::rt::enum_size(8, self.attestation);
        }
        if let Some(ref v) = self.cable_registration_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.hmac_create_secret != false {
            my_size += 2;
        }
        if self.protection_policy != ProtectionPolicy::UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(11, self.protection_policy);
        }
        if self.enforce_protection_policy != false {
            my_size += 2;
        }
        if !self.appid_exclude.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.appid_exclude);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.relying_party.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.challenge.is_empty() {
            os.write_bytes(3, &self.challenge)?;
        }
        for v in &self.public_key_parameters {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.adjusted_timeout != 0 {
            os.write_int64(5, self.adjusted_timeout)?;
        }
        for v in &self.exclude_credentials {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.authenticator_selection.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.attestation != AttestationConveyancePreference::NONE_ATTESTATION_PREFERENCE {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.attestation))?;
        }
        if let Some(ref v) = self.cable_registration_data.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.hmac_create_secret != false {
            os.write_bool(10, self.hmac_create_secret)?;
        }
        if self.protection_policy != ProtectionPolicy::UNSPECIFIED {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.protection_policy))?;
        }
        if self.enforce_protection_policy != false {
            os.write_bool(12, self.enforce_protection_policy)?;
        }
        if !self.appid_exclude.is_empty() {
            os.write_string(13, &self.appid_exclude)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublicKeyCredentialCreationOptions {
        PublicKeyCredentialCreationOptions::new()
    }

    fn default_instance() -> &'static PublicKeyCredentialCreationOptions {
        static instance: ::protobuf::rt::LazyV2<PublicKeyCredentialCreationOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PublicKeyCredentialCreationOptions::new)
    }
}

impl ::protobuf::Clear for PublicKeyCredentialCreationOptions {
    fn clear(&mut self) {
        self.relying_party.clear();
        self.user.clear();
        self.challenge.clear();
        self.public_key_parameters.clear();
        self.adjusted_timeout = 0;
        self.exclude_credentials.clear();
        self.authenticator_selection.clear();
        self.attestation = AttestationConveyancePreference::NONE_ATTESTATION_PREFERENCE;
        self.cable_registration_data.clear();
        self.hmac_create_secret = false;
        self.protection_policy = ProtectionPolicy::UNSPECIFIED;
        self.enforce_protection_policy = false;
        self.appid_exclude.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicKeyCredentialCreationOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PublicKeyCredentialDescriptor {
    // message fields
    pub field_type: PublicKeyCredentialType,
    pub id: ::std::vec::Vec<u8>,
    pub transports: ::std::vec::Vec<AuthenticatorTransport>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PublicKeyCredentialDescriptor {
    fn default() -> &'a PublicKeyCredentialDescriptor {
        <PublicKeyCredentialDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl PublicKeyCredentialDescriptor {
    pub fn new() -> PublicKeyCredentialDescriptor {
        ::std::default::Default::default()
    }

    // .cryptohome.fido.PublicKeyCredentialType type = 1;


    pub fn get_field_type(&self) -> PublicKeyCredentialType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = PublicKeyCredentialType::PUBLIC_KEY;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PublicKeyCredentialType) {
        self.field_type = v;
    }

    // bytes id = 2;


    pub fn get_id(&self) -> &[u8] {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    // repeated .cryptohome.fido.AuthenticatorTransport transports = 3;


    pub fn get_transports(&self) -> &[AuthenticatorTransport] {
        &self.transports
    }
    pub fn clear_transports(&mut self) {
        self.transports.clear();
    }

    // Param is passed by value, moved
    pub fn set_transports(&mut self, v: ::std::vec::Vec<AuthenticatorTransport>) {
        self.transports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transports(&mut self) -> &mut ::std::vec::Vec<AuthenticatorTransport> {
        &mut self.transports
    }

    // Take field
    pub fn take_transports(&mut self) -> ::std::vec::Vec<AuthenticatorTransport> {
        ::std::mem::replace(&mut self.transports, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PublicKeyCredentialDescriptor {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.transports, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != PublicKeyCredentialType::PUBLIC_KEY {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.id);
        }
        for value in &self.transports {
            my_size += ::protobuf::rt::enum_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != PublicKeyCredentialType::PUBLIC_KEY {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.id.is_empty() {
            os.write_bytes(2, &self.id)?;
        }
        for v in &self.transports {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublicKeyCredentialDescriptor {
        PublicKeyCredentialDescriptor::new()
    }

    fn default_instance() -> &'static PublicKeyCredentialDescriptor {
        static instance: ::protobuf::rt::LazyV2<PublicKeyCredentialDescriptor> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PublicKeyCredentialDescriptor::new)
    }
}

impl ::protobuf::Clear for PublicKeyCredentialDescriptor {
    fn clear(&mut self) {
        self.field_type = PublicKeyCredentialType::PUBLIC_KEY;
        self.id.clear();
        self.transports.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicKeyCredentialDescriptor {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AuthenticatorStatus {
    SUCCESS = 0,
    PENDING_REQUEST = 1,
    NOT_ALLOWED_ERROR = 2,
    INVALID_DOMAIN = 3,
    INVALID_ICON_URL = 4,
    CREDENTIAL_EXCLUDED = 5,
    CREDENTIAL_NOT_RECOGNIZED = 6,
    NOT_IMPLEMENTED = 7,
    NOT_FOCUSED = 8,
    RESIDENT_CREDENTIALS_UNSUPPORTED = 9,
    USER_VERIFICATION_UNSUPPORTED = 10,
    ALGORITHM_UNSUPPORTED = 11,
    EMPTY_ALLOW_CREDENTIALS = 12,
    ANDROID_NOT_SUPPORTED_ERROR = 13,
    PROTECTION_POLICY_INCONSISTENT = 14,
    ABORT_ERROR = 15,
    OPAQUE_DOMAIN = 16,
    INVALID_PROTOCOL = 17,
    BAD_RELYING_PARTY_ID = 18,
    UNKNOWN_ERROR = 19,
}

impl ::protobuf::ProtobufEnum for AuthenticatorStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthenticatorStatus> {
        match value {
            0 => ::std::option::Option::Some(AuthenticatorStatus::SUCCESS),
            1 => ::std::option::Option::Some(AuthenticatorStatus::PENDING_REQUEST),
            2 => ::std::option::Option::Some(AuthenticatorStatus::NOT_ALLOWED_ERROR),
            3 => ::std::option::Option::Some(AuthenticatorStatus::INVALID_DOMAIN),
            4 => ::std::option::Option::Some(AuthenticatorStatus::INVALID_ICON_URL),
            5 => ::std::option::Option::Some(AuthenticatorStatus::CREDENTIAL_EXCLUDED),
            6 => ::std::option::Option::Some(AuthenticatorStatus::CREDENTIAL_NOT_RECOGNIZED),
            7 => ::std::option::Option::Some(AuthenticatorStatus::NOT_IMPLEMENTED),
            8 => ::std::option::Option::Some(AuthenticatorStatus::NOT_FOCUSED),
            9 => ::std::option::Option::Some(AuthenticatorStatus::RESIDENT_CREDENTIALS_UNSUPPORTED),
            10 => ::std::option::Option::Some(AuthenticatorStatus::USER_VERIFICATION_UNSUPPORTED),
            11 => ::std::option::Option::Some(AuthenticatorStatus::ALGORITHM_UNSUPPORTED),
            12 => ::std::option::Option::Some(AuthenticatorStatus::EMPTY_ALLOW_CREDENTIALS),
            13 => ::std::option::Option::Some(AuthenticatorStatus::ANDROID_NOT_SUPPORTED_ERROR),
            14 => ::std::option::Option::Some(AuthenticatorStatus::PROTECTION_POLICY_INCONSISTENT),
            15 => ::std::option::Option::Some(AuthenticatorStatus::ABORT_ERROR),
            16 => ::std::option::Option::Some(AuthenticatorStatus::OPAQUE_DOMAIN),
            17 => ::std::option::Option::Some(AuthenticatorStatus::INVALID_PROTOCOL),
            18 => ::std::option::Option::Some(AuthenticatorStatus::BAD_RELYING_PARTY_ID),
            19 => ::std::option::Option::Some(AuthenticatorStatus::UNKNOWN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AuthenticatorStatus] = &[
            AuthenticatorStatus::SUCCESS,
            AuthenticatorStatus::PENDING_REQUEST,
            AuthenticatorStatus::NOT_ALLOWED_ERROR,
            AuthenticatorStatus::INVALID_DOMAIN,
            AuthenticatorStatus::INVALID_ICON_URL,
            AuthenticatorStatus::CREDENTIAL_EXCLUDED,
            AuthenticatorStatus::CREDENTIAL_NOT_RECOGNIZED,
            AuthenticatorStatus::NOT_IMPLEMENTED,
            AuthenticatorStatus::NOT_FOCUSED,
            AuthenticatorStatus::RESIDENT_CREDENTIALS_UNSUPPORTED,
            AuthenticatorStatus::USER_VERIFICATION_UNSUPPORTED,
            AuthenticatorStatus::ALGORITHM_UNSUPPORTED,
            AuthenticatorStatus::EMPTY_ALLOW_CREDENTIALS,
            AuthenticatorStatus::ANDROID_NOT_SUPPORTED_ERROR,
            AuthenticatorStatus::PROTECTION_POLICY_INCONSISTENT,
            AuthenticatorStatus::ABORT_ERROR,
            AuthenticatorStatus::OPAQUE_DOMAIN,
            AuthenticatorStatus::INVALID_PROTOCOL,
            AuthenticatorStatus::BAD_RELYING_PARTY_ID,
            AuthenticatorStatus::UNKNOWN_ERROR,
        ];
        values
    }
}

impl ::std::marker::Copy for AuthenticatorStatus {
}

impl ::std::default::Default for AuthenticatorStatus {
    fn default() -> Self {
        AuthenticatorStatus::SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticatorStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AuthenticatorTransport {
    USB = 0,
    NFC = 1,
    BLE = 2,
    CABLE = 3,
    INTERNAL = 4,
}

impl ::protobuf::ProtobufEnum for AuthenticatorTransport {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthenticatorTransport> {
        match value {
            0 => ::std::option::Option::Some(AuthenticatorTransport::USB),
            1 => ::std::option::Option::Some(AuthenticatorTransport::NFC),
            2 => ::std::option::Option::Some(AuthenticatorTransport::BLE),
            3 => ::std::option::Option::Some(AuthenticatorTransport::CABLE),
            4 => ::std::option::Option::Some(AuthenticatorTransport::INTERNAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AuthenticatorTransport] = &[
            AuthenticatorTransport::USB,
            AuthenticatorTransport::NFC,
            AuthenticatorTransport::BLE,
            AuthenticatorTransport::CABLE,
            AuthenticatorTransport::INTERNAL,
        ];
        values
    }
}

impl ::std::marker::Copy for AuthenticatorTransport {
}

impl ::std::default::Default for AuthenticatorTransport {
    fn default() -> Self {
        AuthenticatorTransport::USB
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticatorTransport {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UserVerificationRequirement {
    REQUIRED = 0,
    PREFERRED = 1,
    DISCOURAGED = 2,
}

impl ::protobuf::ProtobufEnum for UserVerificationRequirement {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UserVerificationRequirement> {
        match value {
            0 => ::std::option::Option::Some(UserVerificationRequirement::REQUIRED),
            1 => ::std::option::Option::Some(UserVerificationRequirement::PREFERRED),
            2 => ::std::option::Option::Some(UserVerificationRequirement::DISCOURAGED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UserVerificationRequirement] = &[
            UserVerificationRequirement::REQUIRED,
            UserVerificationRequirement::PREFERRED,
            UserVerificationRequirement::DISCOURAGED,
        ];
        values
    }
}

impl ::std::marker::Copy for UserVerificationRequirement {
}

impl ::std::default::Default for UserVerificationRequirement {
    fn default() -> Self {
        UserVerificationRequirement::REQUIRED
    }
}

impl ::protobuf::reflect::ProtobufValue for UserVerificationRequirement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AttestationConveyancePreference {
    NONE_ATTESTATION_PREFERENCE = 0,
    INDIRECT = 1,
    DIRECT = 2,
    ENTERPRISE = 3,
}

impl ::protobuf::ProtobufEnum for AttestationConveyancePreference {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AttestationConveyancePreference> {
        match value {
            0 => ::std::option::Option::Some(AttestationConveyancePreference::NONE_ATTESTATION_PREFERENCE),
            1 => ::std::option::Option::Some(AttestationConveyancePreference::INDIRECT),
            2 => ::std::option::Option::Some(AttestationConveyancePreference::DIRECT),
            3 => ::std::option::Option::Some(AttestationConveyancePreference::ENTERPRISE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AttestationConveyancePreference] = &[
            AttestationConveyancePreference::NONE_ATTESTATION_PREFERENCE,
            AttestationConveyancePreference::INDIRECT,
            AttestationConveyancePreference::DIRECT,
            AttestationConveyancePreference::ENTERPRISE,
        ];
        values
    }
}

impl ::std::marker::Copy for AttestationConveyancePreference {
}

impl ::std::default::Default for AttestationConveyancePreference {
    fn default() -> Self {
        AttestationConveyancePreference::NONE_ATTESTATION_PREFERENCE
    }
}

impl ::protobuf::reflect::ProtobufValue for AttestationConveyancePreference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AuthenticatorAttachment {
    NO_PREFERENCE = 0,
    PLATFORM = 1,
    CROSS_PLATFORM = 2,
}

impl ::protobuf::ProtobufEnum for AuthenticatorAttachment {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthenticatorAttachment> {
        match value {
            0 => ::std::option::Option::Some(AuthenticatorAttachment::NO_PREFERENCE),
            1 => ::std::option::Option::Some(AuthenticatorAttachment::PLATFORM),
            2 => ::std::option::Option::Some(AuthenticatorAttachment::CROSS_PLATFORM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AuthenticatorAttachment] = &[
            AuthenticatorAttachment::NO_PREFERENCE,
            AuthenticatorAttachment::PLATFORM,
            AuthenticatorAttachment::CROSS_PLATFORM,
        ];
        values
    }
}

impl ::std::marker::Copy for AuthenticatorAttachment {
}

impl ::std::default::Default for AuthenticatorAttachment {
    fn default() -> Self {
        AuthenticatorAttachment::NO_PREFERENCE
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticatorAttachment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ProtectionPolicy {
    UNSPECIFIED = 0,
    NONE_PROTECTION_POLICY = 1,
    UV_OR_CRED_ID_REQUIRED = 2,
    UV_REQUIRED = 3,
}

impl ::protobuf::ProtobufEnum for ProtectionPolicy {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtectionPolicy> {
        match value {
            0 => ::std::option::Option::Some(ProtectionPolicy::UNSPECIFIED),
            1 => ::std::option::Option::Some(ProtectionPolicy::NONE_PROTECTION_POLICY),
            2 => ::std::option::Option::Some(ProtectionPolicy::UV_OR_CRED_ID_REQUIRED),
            3 => ::std::option::Option::Some(ProtectionPolicy::UV_REQUIRED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ProtectionPolicy] = &[
            ProtectionPolicy::UNSPECIFIED,
            ProtectionPolicy::NONE_PROTECTION_POLICY,
            ProtectionPolicy::UV_OR_CRED_ID_REQUIRED,
            ProtectionPolicy::UV_REQUIRED,
        ];
        values
    }
}

impl ::std::marker::Copy for ProtectionPolicy {
}

impl ::std::default::Default for ProtectionPolicy {
    fn default() -> Self {
        ProtectionPolicy::UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtectionPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PublicKeyCredentialType {
    PUBLIC_KEY = 0,
}

impl ::protobuf::ProtobufEnum for PublicKeyCredentialType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PublicKeyCredentialType> {
        match value {
            0 => ::std::option::Option::Some(PublicKeyCredentialType::PUBLIC_KEY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PublicKeyCredentialType] = &[
            PublicKeyCredentialType::PUBLIC_KEY,
        ];
        values
    }
}

impl ::std::marker::Copy for PublicKeyCredentialType {
}

impl ::std::default::Default for PublicKeyCredentialType {
    fn default() -> Self {
        PublicKeyCredentialType::PUBLIC_KEY
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicKeyCredentialType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}
