// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `UserDataAuth.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreateRequest {
    // message fields
    pub keys: ::protobuf::RepeatedField<super::key::Key>,
    pub copy_authorization_key: bool,
    pub force_ecryptfs: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateRequest {
    fn default() -> &'a CreateRequest {
        <CreateRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateRequest {
    pub fn new() -> CreateRequest {
        ::std::default::Default::default()
    }

    // repeated .cryptohome.Key keys = 1;


    pub fn get_keys(&self) -> &[super::key::Key] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<super::key::Key>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<super::key::Key> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<super::key::Key> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    // bool copy_authorization_key = 2;


    pub fn get_copy_authorization_key(&self) -> bool {
        self.copy_authorization_key
    }
    pub fn clear_copy_authorization_key(&mut self) {
        self.copy_authorization_key = false;
    }

    // Param is passed by value, moved
    pub fn set_copy_authorization_key(&mut self, v: bool) {
        self.copy_authorization_key = v;
    }

    // bool force_ecryptfs = 3;


    pub fn get_force_ecryptfs(&self) -> bool {
        self.force_ecryptfs
    }
    pub fn clear_force_ecryptfs(&mut self) {
        self.force_ecryptfs = false;
    }

    // Param is passed by value, moved
    pub fn set_force_ecryptfs(&mut self, v: bool) {
        self.force_ecryptfs = v;
    }
}

impl ::protobuf::Message for CreateRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.copy_authorization_key = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_ecryptfs = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.copy_authorization_key != false {
            my_size += 2;
        }
        if self.force_ecryptfs != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.keys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.copy_authorization_key != false {
            os.write_bool(2, self.copy_authorization_key)?;
        }
        if self.force_ecryptfs != false {
            os.write_bool(3, self.force_ecryptfs)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateRequest {
        CreateRequest::new()
    }

    fn default_instance() -> &'static CreateRequest {
        static instance: ::protobuf::rt::LazyV2<CreateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateRequest::new)
    }
}

impl ::protobuf::Clear for CreateRequest {
    fn clear(&mut self) {
        self.keys.clear();
        self.copy_authorization_key = false;
        self.force_ecryptfs = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CryptohomeErrorInfo {
    // message fields
    pub error_id: ::std::string::String,
    pub readable_error_id: ::std::string::String,
    pub primary_action: PrimaryAction,
    pub possible_actions: ::std::vec::Vec<PossibleAction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CryptohomeErrorInfo {
    fn default() -> &'a CryptohomeErrorInfo {
        <CryptohomeErrorInfo as ::protobuf::Message>::default_instance()
    }
}

impl CryptohomeErrorInfo {
    pub fn new() -> CryptohomeErrorInfo {
        ::std::default::Default::default()
    }

    // string error_id = 1;


    pub fn get_error_id(&self) -> &str {
        &self.error_id
    }
    pub fn clear_error_id(&mut self) {
        self.error_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_id(&mut self, v: ::std::string::String) {
        self.error_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_id(&mut self) -> &mut ::std::string::String {
        &mut self.error_id
    }

    // Take field
    pub fn take_error_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_id, ::std::string::String::new())
    }

    // string readable_error_id = 2;


    pub fn get_readable_error_id(&self) -> &str {
        &self.readable_error_id
    }
    pub fn clear_readable_error_id(&mut self) {
        self.readable_error_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_readable_error_id(&mut self, v: ::std::string::String) {
        self.readable_error_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readable_error_id(&mut self) -> &mut ::std::string::String {
        &mut self.readable_error_id
    }

    // Take field
    pub fn take_readable_error_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.readable_error_id, ::std::string::String::new())
    }

    // .user_data_auth.PrimaryAction primary_action = 3;


    pub fn get_primary_action(&self) -> PrimaryAction {
        self.primary_action
    }
    pub fn clear_primary_action(&mut self) {
        self.primary_action = PrimaryAction::PRIMARY_NO_ERROR;
    }

    // Param is passed by value, moved
    pub fn set_primary_action(&mut self, v: PrimaryAction) {
        self.primary_action = v;
    }

    // repeated .user_data_auth.PossibleAction possible_actions = 4;


    pub fn get_possible_actions(&self) -> &[PossibleAction] {
        &self.possible_actions
    }
    pub fn clear_possible_actions(&mut self) {
        self.possible_actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_possible_actions(&mut self, v: ::std::vec::Vec<PossibleAction>) {
        self.possible_actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_possible_actions(&mut self) -> &mut ::std::vec::Vec<PossibleAction> {
        &mut self.possible_actions
    }

    // Take field
    pub fn take_possible_actions(&mut self) -> ::std::vec::Vec<PossibleAction> {
        ::std::mem::replace(&mut self.possible_actions, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CryptohomeErrorInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.readable_error_id)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.primary_action, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.possible_actions, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.error_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error_id);
        }
        if !self.readable_error_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.readable_error_id);
        }
        if self.primary_action != PrimaryAction::PRIMARY_NO_ERROR {
            my_size += ::protobuf::rt::enum_size(3, self.primary_action);
        }
        for value in &self.possible_actions {
            my_size += ::protobuf::rt::enum_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.error_id.is_empty() {
            os.write_string(1, &self.error_id)?;
        }
        if !self.readable_error_id.is_empty() {
            os.write_string(2, &self.readable_error_id)?;
        }
        if self.primary_action != PrimaryAction::PRIMARY_NO_ERROR {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.primary_action))?;
        }
        for v in &self.possible_actions {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CryptohomeErrorInfo {
        CryptohomeErrorInfo::new()
    }

    fn default_instance() -> &'static CryptohomeErrorInfo {
        static instance: ::protobuf::rt::LazyV2<CryptohomeErrorInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CryptohomeErrorInfo::new)
    }
}

impl ::protobuf::Clear for CryptohomeErrorInfo {
    fn clear(&mut self) {
        self.error_id.clear();
        self.readable_error_id.clear();
        self.primary_action = PrimaryAction::PRIMARY_NO_ERROR;
        self.possible_actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CryptohomeErrorInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IsMountedRequest {
    // message fields
    pub username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsMountedRequest {
    fn default() -> &'a IsMountedRequest {
        <IsMountedRequest as ::protobuf::Message>::default_instance()
    }
}

impl IsMountedRequest {
    pub fn new() -> IsMountedRequest {
        ::std::default::Default::default()
    }

    // string username = 1;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }
}

impl ::protobuf::Message for IsMountedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsMountedRequest {
        IsMountedRequest::new()
    }

    fn default_instance() -> &'static IsMountedRequest {
        static instance: ::protobuf::rt::LazyV2<IsMountedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IsMountedRequest::new)
    }
}

impl ::protobuf::Clear for IsMountedRequest {
    fn clear(&mut self) {
        self.username.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IsMountedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct IsMountedReply {
    // message fields
    pub is_mounted: bool,
    pub is_ephemeral_mount: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsMountedReply {
    fn default() -> &'a IsMountedReply {
        <IsMountedReply as ::protobuf::Message>::default_instance()
    }
}

impl IsMountedReply {
    pub fn new() -> IsMountedReply {
        ::std::default::Default::default()
    }

    // bool is_mounted = 1;


    pub fn get_is_mounted(&self) -> bool {
        self.is_mounted
    }
    pub fn clear_is_mounted(&mut self) {
        self.is_mounted = false;
    }

    // Param is passed by value, moved
    pub fn set_is_mounted(&mut self, v: bool) {
        self.is_mounted = v;
    }

    // bool is_ephemeral_mount = 2;


    pub fn get_is_ephemeral_mount(&self) -> bool {
        self.is_ephemeral_mount
    }
    pub fn clear_is_ephemeral_mount(&mut self) {
        self.is_ephemeral_mount = false;
    }

    // Param is passed by value, moved
    pub fn set_is_ephemeral_mount(&mut self, v: bool) {
        self.is_ephemeral_mount = v;
    }
}

impl ::protobuf::Message for IsMountedReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_mounted = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_ephemeral_mount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_mounted != false {
            my_size += 2;
        }
        if self.is_ephemeral_mount != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_mounted != false {
            os.write_bool(1, self.is_mounted)?;
        }
        if self.is_ephemeral_mount != false {
            os.write_bool(2, self.is_ephemeral_mount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsMountedReply {
        IsMountedReply::new()
    }

    fn default_instance() -> &'static IsMountedReply {
        static instance: ::protobuf::rt::LazyV2<IsMountedReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IsMountedReply::new)
    }
}

impl ::protobuf::Clear for IsMountedReply {
    fn clear(&mut self) {
        self.is_mounted = false;
        self.is_ephemeral_mount = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for IsMountedReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct UnmountRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnmountRequest {
    fn default() -> &'a UnmountRequest {
        <UnmountRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnmountRequest {
    pub fn new() -> UnmountRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UnmountRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnmountRequest {
        UnmountRequest::new()
    }

    fn default_instance() -> &'static UnmountRequest {
        static instance: ::protobuf::rt::LazyV2<UnmountRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnmountRequest::new)
    }
}

impl ::protobuf::Clear for UnmountRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for UnmountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct UnmountReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnmountReply {
    fn default() -> &'a UnmountReply {
        <UnmountReply as ::protobuf::Message>::default_instance()
    }
}

impl UnmountReply {
    pub fn new() -> UnmountReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 2;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for UnmountReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnmountReply {
        UnmountReply::new()
    }

    fn default_instance() -> &'static UnmountReply {
        static instance: ::protobuf::rt::LazyV2<UnmountReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnmountReply::new)
    }
}

impl ::protobuf::Clear for UnmountReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for UnmountReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MountRequest {
    // message fields
    pub account: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    pub authorization: ::protobuf::SingularPtrField<super::rpc::AuthorizationRequest>,
    pub require_ephemeral: bool,
    pub create: ::protobuf::SingularPtrField<CreateRequest>,
    pub force_dircrypto_if_available: bool,
    pub to_migrate_from_ecryptfs: bool,
    pub public_mount: bool,
    pub guest_mount: bool,
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MountRequest {
    fn default() -> &'a MountRequest {
        <MountRequest as ::protobuf::Message>::default_instance()
    }
}

impl MountRequest {
    pub fn new() -> MountRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account = 1;


    pub fn get_account(&self) -> &super::rpc::AccountIdentifier {
        self.account.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    pub fn has_account(&self) -> bool {
        self.account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: super::rpc::AccountIdentifier) {
        self.account = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account.is_none() {
            self.account.set_default();
        }
        self.account.as_mut().unwrap()
    }

    // Take field
    pub fn take_account(&mut self) -> super::rpc::AccountIdentifier {
        self.account.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }

    // .cryptohome.AuthorizationRequest authorization = 2;


    pub fn get_authorization(&self) -> &super::rpc::AuthorizationRequest {
        self.authorization.as_ref().unwrap_or_else(|| <super::rpc::AuthorizationRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authorization(&mut self) {
        self.authorization.clear();
    }

    pub fn has_authorization(&self) -> bool {
        self.authorization.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorization(&mut self, v: super::rpc::AuthorizationRequest) {
        self.authorization = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorization(&mut self) -> &mut super::rpc::AuthorizationRequest {
        if self.authorization.is_none() {
            self.authorization.set_default();
        }
        self.authorization.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorization(&mut self) -> super::rpc::AuthorizationRequest {
        self.authorization.take().unwrap_or_else(|| super::rpc::AuthorizationRequest::new())
    }

    // bool require_ephemeral = 3;


    pub fn get_require_ephemeral(&self) -> bool {
        self.require_ephemeral
    }
    pub fn clear_require_ephemeral(&mut self) {
        self.require_ephemeral = false;
    }

    // Param is passed by value, moved
    pub fn set_require_ephemeral(&mut self, v: bool) {
        self.require_ephemeral = v;
    }

    // .user_data_auth.CreateRequest create = 4;


    pub fn get_create(&self) -> &CreateRequest {
        self.create.as_ref().unwrap_or_else(|| <CreateRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_create(&mut self) {
        self.create.clear();
    }

    pub fn has_create(&self) -> bool {
        self.create.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: CreateRequest) {
        self.create = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create(&mut self) -> &mut CreateRequest {
        if self.create.is_none() {
            self.create.set_default();
        }
        self.create.as_mut().unwrap()
    }

    // Take field
    pub fn take_create(&mut self) -> CreateRequest {
        self.create.take().unwrap_or_else(|| CreateRequest::new())
    }

    // bool force_dircrypto_if_available = 5;


    pub fn get_force_dircrypto_if_available(&self) -> bool {
        self.force_dircrypto_if_available
    }
    pub fn clear_force_dircrypto_if_available(&mut self) {
        self.force_dircrypto_if_available = false;
    }

    // Param is passed by value, moved
    pub fn set_force_dircrypto_if_available(&mut self, v: bool) {
        self.force_dircrypto_if_available = v;
    }

    // bool to_migrate_from_ecryptfs = 6;


    pub fn get_to_migrate_from_ecryptfs(&self) -> bool {
        self.to_migrate_from_ecryptfs
    }
    pub fn clear_to_migrate_from_ecryptfs(&mut self) {
        self.to_migrate_from_ecryptfs = false;
    }

    // Param is passed by value, moved
    pub fn set_to_migrate_from_ecryptfs(&mut self, v: bool) {
        self.to_migrate_from_ecryptfs = v;
    }

    // bool public_mount = 7;


    pub fn get_public_mount(&self) -> bool {
        self.public_mount
    }
    pub fn clear_public_mount(&mut self) {
        self.public_mount = false;
    }

    // Param is passed by value, moved
    pub fn set_public_mount(&mut self, v: bool) {
        self.public_mount = v;
    }

    // bool guest_mount = 8;


    pub fn get_guest_mount(&self) -> bool {
        self.guest_mount
    }
    pub fn clear_guest_mount(&mut self) {
        self.guest_mount = false;
    }

    // Param is passed by value, moved
    pub fn set_guest_mount(&mut self, v: bool) {
        self.guest_mount = v;
    }

    // bytes auth_session_id = 9;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MountRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authorization {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authorization)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.require_ephemeral = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_dircrypto_if_available = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.to_migrate_from_ecryptfs = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.public_mount = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.guest_mount = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authorization.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.require_ephemeral != false {
            my_size += 2;
        }
        if let Some(ref v) = self.create.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.force_dircrypto_if_available != false {
            my_size += 2;
        }
        if self.to_migrate_from_ecryptfs != false {
            my_size += 2;
        }
        if self.public_mount != false {
            my_size += 2;
        }
        if self.guest_mount != false {
            my_size += 2;
        }
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authorization.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.require_ephemeral != false {
            os.write_bool(3, self.require_ephemeral)?;
        }
        if let Some(ref v) = self.create.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.force_dircrypto_if_available != false {
            os.write_bool(5, self.force_dircrypto_if_available)?;
        }
        if self.to_migrate_from_ecryptfs != false {
            os.write_bool(6, self.to_migrate_from_ecryptfs)?;
        }
        if self.public_mount != false {
            os.write_bool(7, self.public_mount)?;
        }
        if self.guest_mount != false {
            os.write_bool(8, self.guest_mount)?;
        }
        if !self.auth_session_id.is_empty() {
            os.write_bytes(9, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MountRequest {
        MountRequest::new()
    }

    fn default_instance() -> &'static MountRequest {
        static instance: ::protobuf::rt::LazyV2<MountRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MountRequest::new)
    }
}

impl ::protobuf::Clear for MountRequest {
    fn clear(&mut self) {
        self.account.clear();
        self.authorization.clear();
        self.require_ephemeral = false;
        self.create.clear();
        self.force_dircrypto_if_available = false;
        self.to_migrate_from_ecryptfs = false;
        self.public_mount = false;
        self.guest_mount = false;
        self.auth_session_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MountReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub recreated: bool,
    pub sanitized_username: ::std::string::String,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MountReply {
    fn default() -> &'a MountReply {
        <MountReply as ::protobuf::Message>::default_instance()
    }
}

impl MountReply {
    pub fn new() -> MountReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // bool recreated = 2;


    pub fn get_recreated(&self) -> bool {
        self.recreated
    }
    pub fn clear_recreated(&mut self) {
        self.recreated = false;
    }

    // Param is passed by value, moved
    pub fn set_recreated(&mut self, v: bool) {
        self.recreated = v;
    }

    // string sanitized_username = 3;


    pub fn get_sanitized_username(&self) -> &str {
        &self.sanitized_username
    }
    pub fn clear_sanitized_username(&mut self) {
        self.sanitized_username.clear();
    }

    // Param is passed by value, moved
    pub fn set_sanitized_username(&mut self, v: ::std::string::String) {
        self.sanitized_username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sanitized_username(&mut self) -> &mut ::std::string::String {
        &mut self.sanitized_username
    }

    // Take field
    pub fn take_sanitized_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sanitized_username, ::std::string::String::new())
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 4;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for MountReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.recreated = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sanitized_username)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if self.recreated != false {
            my_size += 2;
        }
        if !self.sanitized_username.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.sanitized_username);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if self.recreated != false {
            os.write_bool(2, self.recreated)?;
        }
        if !self.sanitized_username.is_empty() {
            os.write_string(3, &self.sanitized_username)?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MountReply {
        MountReply::new()
    }

    fn default_instance() -> &'static MountReply {
        static instance: ::protobuf::rt::LazyV2<MountReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MountReply::new)
    }
}

impl ::protobuf::Clear for MountReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.recreated = false;
        self.sanitized_username.clear();
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MountReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RemoveRequest {
    // message fields
    pub identifier: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveRequest {
    fn default() -> &'a RemoveRequest {
        <RemoveRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveRequest {
    pub fn new() -> RemoveRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier identifier = 1;


    pub fn get_identifier(&self) -> &super::rpc::AccountIdentifier {
        self.identifier.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identifier(&mut self) {
        self.identifier.clear();
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: super::rpc::AccountIdentifier) {
        self.identifier = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.identifier.is_none() {
            self.identifier.set_default();
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> super::rpc::AccountIdentifier {
        self.identifier.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }

    // bytes auth_session_id = 2;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RemoveRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.identifier {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identifier)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identifier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identifier.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.auth_session_id.is_empty() {
            os.write_bytes(2, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveRequest {
        RemoveRequest::new()
    }

    fn default_instance() -> &'static RemoveRequest {
        static instance: ::protobuf::rt::LazyV2<RemoveRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveRequest::new)
    }
}

impl ::protobuf::Clear for RemoveRequest {
    fn clear(&mut self) {
        self.identifier.clear();
        self.auth_session_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RemoveReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveReply {
    fn default() -> &'a RemoveReply {
        <RemoveReply as ::protobuf::Message>::default_instance()
    }
}

impl RemoveReply {
    pub fn new() -> RemoveReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 2;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for RemoveReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveReply {
        RemoveReply::new()
    }

    fn default_instance() -> &'static RemoveReply {
        static instance: ::protobuf::rt::LazyV2<RemoveReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveReply::new)
    }
}

impl ::protobuf::Clear for RemoveReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListKeysRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    pub authorization_request: ::protobuf::SingularPtrField<super::rpc::AuthorizationRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListKeysRequest {
    fn default() -> &'a ListKeysRequest {
        <ListKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListKeysRequest {
    pub fn new() -> ListKeysRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }

    // .cryptohome.AuthorizationRequest authorization_request = 2;


    pub fn get_authorization_request(&self) -> &super::rpc::AuthorizationRequest {
        self.authorization_request.as_ref().unwrap_or_else(|| <super::rpc::AuthorizationRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authorization_request(&mut self) {
        self.authorization_request.clear();
    }

    pub fn has_authorization_request(&self) -> bool {
        self.authorization_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorization_request(&mut self, v: super::rpc::AuthorizationRequest) {
        self.authorization_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorization_request(&mut self) -> &mut super::rpc::AuthorizationRequest {
        if self.authorization_request.is_none() {
            self.authorization_request.set_default();
        }
        self.authorization_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorization_request(&mut self) -> super::rpc::AuthorizationRequest {
        self.authorization_request.take().unwrap_or_else(|| super::rpc::AuthorizationRequest::new())
    }
}

impl ::protobuf::Message for ListKeysRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authorization_request {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authorization_request)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListKeysRequest {
        ListKeysRequest::new()
    }

    fn default_instance() -> &'static ListKeysRequest {
        static instance: ::protobuf::rt::LazyV2<ListKeysRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListKeysRequest::new)
    }
}

impl ::protobuf::Clear for ListKeysRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.authorization_request.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ListKeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListKeysReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub labels: ::protobuf::RepeatedField<::std::string::String>,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListKeysReply {
    fn default() -> &'a ListKeysReply {
        <ListKeysReply as ::protobuf::Message>::default_instance()
    }
}

impl ListKeysReply {
    pub fn new() -> ListKeysReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // repeated string labels = 2;


    pub fn get_labels(&self) -> &[::std::string::String] {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::protobuf::RepeatedField::new())
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 3;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for ListKeysReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.labels)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        for value in &self.labels {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        for v in &self.labels {
            os.write_string(2, &v)?;
        };
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListKeysReply {
        ListKeysReply::new()
    }

    fn default_instance() -> &'static ListKeysReply {
        static instance: ::protobuf::rt::LazyV2<ListKeysReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListKeysReply::new)
    }
}

impl ::protobuf::Clear for ListKeysReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.labels.clear();
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ListKeysReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetKeyDataRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    pub authorization_request: ::protobuf::SingularPtrField<super::rpc::AuthorizationRequest>,
    pub key: ::protobuf::SingularPtrField<super::key::Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetKeyDataRequest {
    fn default() -> &'a GetKeyDataRequest {
        <GetKeyDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetKeyDataRequest {
    pub fn new() -> GetKeyDataRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }

    // .cryptohome.AuthorizationRequest authorization_request = 2;


    pub fn get_authorization_request(&self) -> &super::rpc::AuthorizationRequest {
        self.authorization_request.as_ref().unwrap_or_else(|| <super::rpc::AuthorizationRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authorization_request(&mut self) {
        self.authorization_request.clear();
    }

    pub fn has_authorization_request(&self) -> bool {
        self.authorization_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorization_request(&mut self, v: super::rpc::AuthorizationRequest) {
        self.authorization_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorization_request(&mut self) -> &mut super::rpc::AuthorizationRequest {
        if self.authorization_request.is_none() {
            self.authorization_request.set_default();
        }
        self.authorization_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorization_request(&mut self) -> super::rpc::AuthorizationRequest {
        self.authorization_request.take().unwrap_or_else(|| super::rpc::AuthorizationRequest::new())
    }

    // .cryptohome.Key key = 3;


    pub fn get_key(&self) -> &super::key::Key {
        self.key.as_ref().unwrap_or_else(|| <super::key::Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: super::key::Key) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut super::key::Key {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> super::key::Key {
        self.key.take().unwrap_or_else(|| super::key::Key::new())
    }
}

impl ::protobuf::Message for GetKeyDataRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authorization_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authorization_request)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetKeyDataRequest {
        GetKeyDataRequest::new()
    }

    fn default_instance() -> &'static GetKeyDataRequest {
        static instance: ::protobuf::rt::LazyV2<GetKeyDataRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetKeyDataRequest::new)
    }
}

impl ::protobuf::Clear for GetKeyDataRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.authorization_request.clear();
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetKeyDataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetKeyDataReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub key_data: ::protobuf::RepeatedField<super::key::KeyData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetKeyDataReply {
    fn default() -> &'a GetKeyDataReply {
        <GetKeyDataReply as ::protobuf::Message>::default_instance()
    }
}

impl GetKeyDataReply {
    pub fn new() -> GetKeyDataReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // repeated .cryptohome.KeyData key_data = 2;


    pub fn get_key_data(&self) -> &[super::key::KeyData] {
        &self.key_data
    }
    pub fn clear_key_data(&mut self) {
        self.key_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_data(&mut self, v: ::protobuf::RepeatedField<super::key::KeyData>) {
        self.key_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_key_data(&mut self) -> &mut ::protobuf::RepeatedField<super::key::KeyData> {
        &mut self.key_data
    }

    // Take field
    pub fn take_key_data(&mut self) -> ::protobuf::RepeatedField<super::key::KeyData> {
        ::std::mem::replace(&mut self.key_data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetKeyDataReply {
    fn is_initialized(&self) -> bool {
        for v in &self.key_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.key_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        for value in &self.key_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        for v in &self.key_data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetKeyDataReply {
        GetKeyDataReply::new()
    }

    fn default_instance() -> &'static GetKeyDataReply {
        static instance: ::protobuf::rt::LazyV2<GetKeyDataReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetKeyDataReply::new)
    }
}

impl ::protobuf::Clear for GetKeyDataReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.key_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetKeyDataReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CheckKeyRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    pub authorization_request: ::protobuf::SingularPtrField<super::rpc::AuthorizationRequest>,
    pub unlock_webauthn_secret: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckKeyRequest {
    fn default() -> &'a CheckKeyRequest {
        <CheckKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl CheckKeyRequest {
    pub fn new() -> CheckKeyRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }

    // .cryptohome.AuthorizationRequest authorization_request = 2;


    pub fn get_authorization_request(&self) -> &super::rpc::AuthorizationRequest {
        self.authorization_request.as_ref().unwrap_or_else(|| <super::rpc::AuthorizationRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authorization_request(&mut self) {
        self.authorization_request.clear();
    }

    pub fn has_authorization_request(&self) -> bool {
        self.authorization_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorization_request(&mut self, v: super::rpc::AuthorizationRequest) {
        self.authorization_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorization_request(&mut self) -> &mut super::rpc::AuthorizationRequest {
        if self.authorization_request.is_none() {
            self.authorization_request.set_default();
        }
        self.authorization_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorization_request(&mut self) -> super::rpc::AuthorizationRequest {
        self.authorization_request.take().unwrap_or_else(|| super::rpc::AuthorizationRequest::new())
    }

    // bool unlock_webauthn_secret = 3;


    pub fn get_unlock_webauthn_secret(&self) -> bool {
        self.unlock_webauthn_secret
    }
    pub fn clear_unlock_webauthn_secret(&mut self) {
        self.unlock_webauthn_secret = false;
    }

    // Param is passed by value, moved
    pub fn set_unlock_webauthn_secret(&mut self, v: bool) {
        self.unlock_webauthn_secret = v;
    }
}

impl ::protobuf::Message for CheckKeyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authorization_request {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authorization_request)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unlock_webauthn_secret = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.unlock_webauthn_secret != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.unlock_webauthn_secret != false {
            os.write_bool(3, self.unlock_webauthn_secret)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckKeyRequest {
        CheckKeyRequest::new()
    }

    fn default_instance() -> &'static CheckKeyRequest {
        static instance: ::protobuf::rt::LazyV2<CheckKeyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckKeyRequest::new)
    }
}

impl ::protobuf::Clear for CheckKeyRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.authorization_request.clear();
        self.unlock_webauthn_secret = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckKeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CheckKeyReply {
    // message fields
    pub error: CryptohomeErrorCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckKeyReply {
    fn default() -> &'a CheckKeyReply {
        <CheckKeyReply as ::protobuf::Message>::default_instance()
    }
}

impl CheckKeyReply {
    pub fn new() -> CheckKeyReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }
}

impl ::protobuf::Message for CheckKeyReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckKeyReply {
        CheckKeyReply::new()
    }

    fn default_instance() -> &'static CheckKeyReply {
        static instance: ::protobuf::rt::LazyV2<CheckKeyReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckKeyReply::new)
    }
}

impl ::protobuf::Clear for CheckKeyReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckKeyReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddKeyRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    pub authorization_request: ::protobuf::SingularPtrField<super::rpc::AuthorizationRequest>,
    pub key: ::protobuf::SingularPtrField<super::key::Key>,
    pub clobber_if_exists: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddKeyRequest {
    fn default() -> &'a AddKeyRequest {
        <AddKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddKeyRequest {
    pub fn new() -> AddKeyRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }

    // .cryptohome.AuthorizationRequest authorization_request = 2;


    pub fn get_authorization_request(&self) -> &super::rpc::AuthorizationRequest {
        self.authorization_request.as_ref().unwrap_or_else(|| <super::rpc::AuthorizationRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authorization_request(&mut self) {
        self.authorization_request.clear();
    }

    pub fn has_authorization_request(&self) -> bool {
        self.authorization_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorization_request(&mut self, v: super::rpc::AuthorizationRequest) {
        self.authorization_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorization_request(&mut self) -> &mut super::rpc::AuthorizationRequest {
        if self.authorization_request.is_none() {
            self.authorization_request.set_default();
        }
        self.authorization_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorization_request(&mut self) -> super::rpc::AuthorizationRequest {
        self.authorization_request.take().unwrap_or_else(|| super::rpc::AuthorizationRequest::new())
    }

    // .cryptohome.Key key = 3;


    pub fn get_key(&self) -> &super::key::Key {
        self.key.as_ref().unwrap_or_else(|| <super::key::Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: super::key::Key) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut super::key::Key {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> super::key::Key {
        self.key.take().unwrap_or_else(|| super::key::Key::new())
    }

    // bool clobber_if_exists = 4;


    pub fn get_clobber_if_exists(&self) -> bool {
        self.clobber_if_exists
    }
    pub fn clear_clobber_if_exists(&mut self) {
        self.clobber_if_exists = false;
    }

    // Param is passed by value, moved
    pub fn set_clobber_if_exists(&mut self, v: bool) {
        self.clobber_if_exists = v;
    }
}

impl ::protobuf::Message for AddKeyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authorization_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authorization_request)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.clobber_if_exists = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.clobber_if_exists != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.clobber_if_exists != false {
            os.write_bool(4, self.clobber_if_exists)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddKeyRequest {
        AddKeyRequest::new()
    }

    fn default_instance() -> &'static AddKeyRequest {
        static instance: ::protobuf::rt::LazyV2<AddKeyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddKeyRequest::new)
    }
}

impl ::protobuf::Clear for AddKeyRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.authorization_request.clear();
        self.key.clear();
        self.clobber_if_exists = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AddKeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddKeyReply {
    // message fields
    pub error: CryptohomeErrorCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddKeyReply {
    fn default() -> &'a AddKeyReply {
        <AddKeyReply as ::protobuf::Message>::default_instance()
    }
}

impl AddKeyReply {
    pub fn new() -> AddKeyReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }
}

impl ::protobuf::Message for AddKeyReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddKeyReply {
        AddKeyReply::new()
    }

    fn default_instance() -> &'static AddKeyReply {
        static instance: ::protobuf::rt::LazyV2<AddKeyReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddKeyReply::new)
    }
}

impl ::protobuf::Clear for AddKeyReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AddKeyReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RemoveKeyRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    pub authorization_request: ::protobuf::SingularPtrField<super::rpc::AuthorizationRequest>,
    pub key: ::protobuf::SingularPtrField<super::key::Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveKeyRequest {
    fn default() -> &'a RemoveKeyRequest {
        <RemoveKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveKeyRequest {
    pub fn new() -> RemoveKeyRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }

    // .cryptohome.AuthorizationRequest authorization_request = 2;


    pub fn get_authorization_request(&self) -> &super::rpc::AuthorizationRequest {
        self.authorization_request.as_ref().unwrap_or_else(|| <super::rpc::AuthorizationRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authorization_request(&mut self) {
        self.authorization_request.clear();
    }

    pub fn has_authorization_request(&self) -> bool {
        self.authorization_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorization_request(&mut self, v: super::rpc::AuthorizationRequest) {
        self.authorization_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorization_request(&mut self) -> &mut super::rpc::AuthorizationRequest {
        if self.authorization_request.is_none() {
            self.authorization_request.set_default();
        }
        self.authorization_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorization_request(&mut self) -> super::rpc::AuthorizationRequest {
        self.authorization_request.take().unwrap_or_else(|| super::rpc::AuthorizationRequest::new())
    }

    // .cryptohome.Key key = 3;


    pub fn get_key(&self) -> &super::key::Key {
        self.key.as_ref().unwrap_or_else(|| <super::key::Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: super::key::Key) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut super::key::Key {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> super::key::Key {
        self.key.take().unwrap_or_else(|| super::key::Key::new())
    }
}

impl ::protobuf::Message for RemoveKeyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authorization_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authorization_request)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveKeyRequest {
        RemoveKeyRequest::new()
    }

    fn default_instance() -> &'static RemoveKeyRequest {
        static instance: ::protobuf::rt::LazyV2<RemoveKeyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveKeyRequest::new)
    }
}

impl ::protobuf::Clear for RemoveKeyRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.authorization_request.clear();
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveKeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RemoveKeyReply {
    // message fields
    pub error: CryptohomeErrorCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveKeyReply {
    fn default() -> &'a RemoveKeyReply {
        <RemoveKeyReply as ::protobuf::Message>::default_instance()
    }
}

impl RemoveKeyReply {
    pub fn new() -> RemoveKeyReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }
}

impl ::protobuf::Message for RemoveKeyReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveKeyReply {
        RemoveKeyReply::new()
    }

    fn default_instance() -> &'static RemoveKeyReply {
        static instance: ::protobuf::rt::LazyV2<RemoveKeyReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveKeyReply::new)
    }
}

impl ::protobuf::Clear for RemoveKeyReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveKeyReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MassRemoveKeysRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    pub authorization_request: ::protobuf::SingularPtrField<super::rpc::AuthorizationRequest>,
    pub exempt_key_data: ::protobuf::RepeatedField<super::key::KeyData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MassRemoveKeysRequest {
    fn default() -> &'a MassRemoveKeysRequest {
        <MassRemoveKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl MassRemoveKeysRequest {
    pub fn new() -> MassRemoveKeysRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }

    // .cryptohome.AuthorizationRequest authorization_request = 2;


    pub fn get_authorization_request(&self) -> &super::rpc::AuthorizationRequest {
        self.authorization_request.as_ref().unwrap_or_else(|| <super::rpc::AuthorizationRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authorization_request(&mut self) {
        self.authorization_request.clear();
    }

    pub fn has_authorization_request(&self) -> bool {
        self.authorization_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorization_request(&mut self, v: super::rpc::AuthorizationRequest) {
        self.authorization_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorization_request(&mut self) -> &mut super::rpc::AuthorizationRequest {
        if self.authorization_request.is_none() {
            self.authorization_request.set_default();
        }
        self.authorization_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorization_request(&mut self) -> super::rpc::AuthorizationRequest {
        self.authorization_request.take().unwrap_or_else(|| super::rpc::AuthorizationRequest::new())
    }

    // repeated .cryptohome.KeyData exempt_key_data = 3;


    pub fn get_exempt_key_data(&self) -> &[super::key::KeyData] {
        &self.exempt_key_data
    }
    pub fn clear_exempt_key_data(&mut self) {
        self.exempt_key_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_exempt_key_data(&mut self, v: ::protobuf::RepeatedField<super::key::KeyData>) {
        self.exempt_key_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exempt_key_data(&mut self) -> &mut ::protobuf::RepeatedField<super::key::KeyData> {
        &mut self.exempt_key_data
    }

    // Take field
    pub fn take_exempt_key_data(&mut self) -> ::protobuf::RepeatedField<super::key::KeyData> {
        ::std::mem::replace(&mut self.exempt_key_data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MassRemoveKeysRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authorization_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exempt_key_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authorization_request)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.exempt_key_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.exempt_key_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.exempt_key_data {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MassRemoveKeysRequest {
        MassRemoveKeysRequest::new()
    }

    fn default_instance() -> &'static MassRemoveKeysRequest {
        static instance: ::protobuf::rt::LazyV2<MassRemoveKeysRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MassRemoveKeysRequest::new)
    }
}

impl ::protobuf::Clear for MassRemoveKeysRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.authorization_request.clear();
        self.exempt_key_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MassRemoveKeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MassRemoveKeysReply {
    // message fields
    pub error: CryptohomeErrorCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MassRemoveKeysReply {
    fn default() -> &'a MassRemoveKeysReply {
        <MassRemoveKeysReply as ::protobuf::Message>::default_instance()
    }
}

impl MassRemoveKeysReply {
    pub fn new() -> MassRemoveKeysReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }
}

impl ::protobuf::Message for MassRemoveKeysReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MassRemoveKeysReply {
        MassRemoveKeysReply::new()
    }

    fn default_instance() -> &'static MassRemoveKeysReply {
        static instance: ::protobuf::rt::LazyV2<MassRemoveKeysReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MassRemoveKeysReply::new)
    }
}

impl ::protobuf::Clear for MassRemoveKeysReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MassRemoveKeysReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MigrateKeyRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    pub authorization_request: ::protobuf::SingularPtrField<super::rpc::AuthorizationRequest>,
    pub secret: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MigrateKeyRequest {
    fn default() -> &'a MigrateKeyRequest {
        <MigrateKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl MigrateKeyRequest {
    pub fn new() -> MigrateKeyRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }

    // .cryptohome.AuthorizationRequest authorization_request = 2;


    pub fn get_authorization_request(&self) -> &super::rpc::AuthorizationRequest {
        self.authorization_request.as_ref().unwrap_or_else(|| <super::rpc::AuthorizationRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authorization_request(&mut self) {
        self.authorization_request.clear();
    }

    pub fn has_authorization_request(&self) -> bool {
        self.authorization_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorization_request(&mut self, v: super::rpc::AuthorizationRequest) {
        self.authorization_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorization_request(&mut self) -> &mut super::rpc::AuthorizationRequest {
        if self.authorization_request.is_none() {
            self.authorization_request.set_default();
        }
        self.authorization_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorization_request(&mut self) -> super::rpc::AuthorizationRequest {
        self.authorization_request.take().unwrap_or_else(|| super::rpc::AuthorizationRequest::new())
    }

    // bytes secret = 3;


    pub fn get_secret(&self) -> &[u8] {
        &self.secret
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: ::std::vec::Vec<u8>) {
        self.secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.secret
    }

    // Take field
    pub fn take_secret(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.secret, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for MigrateKeyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authorization_request {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authorization_request)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.secret.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.secret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.secret.is_empty() {
            os.write_bytes(3, &self.secret)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MigrateKeyRequest {
        MigrateKeyRequest::new()
    }

    fn default_instance() -> &'static MigrateKeyRequest {
        static instance: ::protobuf::rt::LazyV2<MigrateKeyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MigrateKeyRequest::new)
    }
}

impl ::protobuf::Clear for MigrateKeyRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.authorization_request.clear();
        self.secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MigrateKeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct MigrateKeyReply {
    // message fields
    pub error: CryptohomeErrorCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MigrateKeyReply {
    fn default() -> &'a MigrateKeyReply {
        <MigrateKeyReply as ::protobuf::Message>::default_instance()
    }
}

impl MigrateKeyReply {
    pub fn new() -> MigrateKeyReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }
}

impl ::protobuf::Message for MigrateKeyReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MigrateKeyReply {
        MigrateKeyReply::new()
    }

    fn default_instance() -> &'static MigrateKeyReply {
        static instance: ::protobuf::rt::LazyV2<MigrateKeyReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MigrateKeyReply::new)
    }
}

impl ::protobuf::Clear for MigrateKeyReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for MigrateKeyReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StartFingerprintAuthSessionRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartFingerprintAuthSessionRequest {
    fn default() -> &'a StartFingerprintAuthSessionRequest {
        <StartFingerprintAuthSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartFingerprintAuthSessionRequest {
    pub fn new() -> StartFingerprintAuthSessionRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }
}

impl ::protobuf::Message for StartFingerprintAuthSessionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartFingerprintAuthSessionRequest {
        StartFingerprintAuthSessionRequest::new()
    }

    fn default_instance() -> &'static StartFingerprintAuthSessionRequest {
        static instance: ::protobuf::rt::LazyV2<StartFingerprintAuthSessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartFingerprintAuthSessionRequest::new)
    }
}

impl ::protobuf::Clear for StartFingerprintAuthSessionRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StartFingerprintAuthSessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StartFingerprintAuthSessionReply {
    // message fields
    pub error: CryptohomeErrorCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartFingerprintAuthSessionReply {
    fn default() -> &'a StartFingerprintAuthSessionReply {
        <StartFingerprintAuthSessionReply as ::protobuf::Message>::default_instance()
    }
}

impl StartFingerprintAuthSessionReply {
    pub fn new() -> StartFingerprintAuthSessionReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }
}

impl ::protobuf::Message for StartFingerprintAuthSessionReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartFingerprintAuthSessionReply {
        StartFingerprintAuthSessionReply::new()
    }

    fn default_instance() -> &'static StartFingerprintAuthSessionReply {
        static instance: ::protobuf::rt::LazyV2<StartFingerprintAuthSessionReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartFingerprintAuthSessionReply::new)
    }
}

impl ::protobuf::Clear for StartFingerprintAuthSessionReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StartFingerprintAuthSessionReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EndFingerprintAuthSessionRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EndFingerprintAuthSessionRequest {
    fn default() -> &'a EndFingerprintAuthSessionRequest {
        <EndFingerprintAuthSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl EndFingerprintAuthSessionRequest {
    pub fn new() -> EndFingerprintAuthSessionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EndFingerprintAuthSessionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EndFingerprintAuthSessionRequest {
        EndFingerprintAuthSessionRequest::new()
    }

    fn default_instance() -> &'static EndFingerprintAuthSessionRequest {
        static instance: ::protobuf::rt::LazyV2<EndFingerprintAuthSessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EndFingerprintAuthSessionRequest::new)
    }
}

impl ::protobuf::Clear for EndFingerprintAuthSessionRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EndFingerprintAuthSessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct EndFingerprintAuthSessionReply {
    // message fields
    pub error: CryptohomeErrorCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EndFingerprintAuthSessionReply {
    fn default() -> &'a EndFingerprintAuthSessionReply {
        <EndFingerprintAuthSessionReply as ::protobuf::Message>::default_instance()
    }
}

impl EndFingerprintAuthSessionReply {
    pub fn new() -> EndFingerprintAuthSessionReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }
}

impl ::protobuf::Message for EndFingerprintAuthSessionReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EndFingerprintAuthSessionReply {
        EndFingerprintAuthSessionReply::new()
    }

    fn default_instance() -> &'static EndFingerprintAuthSessionReply {
        static instance: ::protobuf::rt::LazyV2<EndFingerprintAuthSessionReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EndFingerprintAuthSessionReply::new)
    }
}

impl ::protobuf::Clear for EndFingerprintAuthSessionReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for EndFingerprintAuthSessionReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWebAuthnSecretRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWebAuthnSecretRequest {
    fn default() -> &'a GetWebAuthnSecretRequest {
        <GetWebAuthnSecretRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWebAuthnSecretRequest {
    pub fn new() -> GetWebAuthnSecretRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }
}

impl ::protobuf::Message for GetWebAuthnSecretRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWebAuthnSecretRequest {
        GetWebAuthnSecretRequest::new()
    }

    fn default_instance() -> &'static GetWebAuthnSecretRequest {
        static instance: ::protobuf::rt::LazyV2<GetWebAuthnSecretRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWebAuthnSecretRequest::new)
    }
}

impl ::protobuf::Clear for GetWebAuthnSecretRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWebAuthnSecretRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWebAuthnSecretReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub webauthn_secret: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWebAuthnSecretReply {
    fn default() -> &'a GetWebAuthnSecretReply {
        <GetWebAuthnSecretReply as ::protobuf::Message>::default_instance()
    }
}

impl GetWebAuthnSecretReply {
    pub fn new() -> GetWebAuthnSecretReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // bytes webauthn_secret = 2;


    pub fn get_webauthn_secret(&self) -> &[u8] {
        &self.webauthn_secret
    }
    pub fn clear_webauthn_secret(&mut self) {
        self.webauthn_secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_webauthn_secret(&mut self, v: ::std::vec::Vec<u8>) {
        self.webauthn_secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webauthn_secret(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.webauthn_secret
    }

    // Take field
    pub fn take_webauthn_secret(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.webauthn_secret, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetWebAuthnSecretReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.webauthn_secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if !self.webauthn_secret.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.webauthn_secret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if !self.webauthn_secret.is_empty() {
            os.write_bytes(2, &self.webauthn_secret)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWebAuthnSecretReply {
        GetWebAuthnSecretReply::new()
    }

    fn default_instance() -> &'static GetWebAuthnSecretReply {
        static instance: ::protobuf::rt::LazyV2<GetWebAuthnSecretReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWebAuthnSecretReply::new)
    }
}

impl ::protobuf::Clear for GetWebAuthnSecretReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.webauthn_secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWebAuthnSecretReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWebAuthnSecretHashRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWebAuthnSecretHashRequest {
    fn default() -> &'a GetWebAuthnSecretHashRequest {
        <GetWebAuthnSecretHashRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWebAuthnSecretHashRequest {
    pub fn new() -> GetWebAuthnSecretHashRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }
}

impl ::protobuf::Message for GetWebAuthnSecretHashRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWebAuthnSecretHashRequest {
        GetWebAuthnSecretHashRequest::new()
    }

    fn default_instance() -> &'static GetWebAuthnSecretHashRequest {
        static instance: ::protobuf::rt::LazyV2<GetWebAuthnSecretHashRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWebAuthnSecretHashRequest::new)
    }
}

impl ::protobuf::Clear for GetWebAuthnSecretHashRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWebAuthnSecretHashRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetWebAuthnSecretHashReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub webauthn_secret_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetWebAuthnSecretHashReply {
    fn default() -> &'a GetWebAuthnSecretHashReply {
        <GetWebAuthnSecretHashReply as ::protobuf::Message>::default_instance()
    }
}

impl GetWebAuthnSecretHashReply {
    pub fn new() -> GetWebAuthnSecretHashReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // bytes webauthn_secret_hash = 2;


    pub fn get_webauthn_secret_hash(&self) -> &[u8] {
        &self.webauthn_secret_hash
    }
    pub fn clear_webauthn_secret_hash(&mut self) {
        self.webauthn_secret_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_webauthn_secret_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.webauthn_secret_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webauthn_secret_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.webauthn_secret_hash
    }

    // Take field
    pub fn take_webauthn_secret_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.webauthn_secret_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetWebAuthnSecretHashReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.webauthn_secret_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if !self.webauthn_secret_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.webauthn_secret_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if !self.webauthn_secret_hash.is_empty() {
            os.write_bytes(2, &self.webauthn_secret_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetWebAuthnSecretHashReply {
        GetWebAuthnSecretHashReply::new()
    }

    fn default_instance() -> &'static GetWebAuthnSecretHashReply {
        static instance: ::protobuf::rt::LazyV2<GetWebAuthnSecretHashReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetWebAuthnSecretHashReply::new)
    }
}

impl ::protobuf::Clear for GetWebAuthnSecretHashReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.webauthn_secret_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetWebAuthnSecretHashReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetHibernateSecretRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetHibernateSecretRequest {
    fn default() -> &'a GetHibernateSecretRequest {
        <GetHibernateSecretRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetHibernateSecretRequest {
    pub fn new() -> GetHibernateSecretRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }

    // bytes auth_session_id = 2;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetHibernateSecretRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.auth_session_id.is_empty() {
            os.write_bytes(2, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetHibernateSecretRequest {
        GetHibernateSecretRequest::new()
    }

    fn default_instance() -> &'static GetHibernateSecretRequest {
        static instance: ::protobuf::rt::LazyV2<GetHibernateSecretRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetHibernateSecretRequest::new)
    }
}

impl ::protobuf::Clear for GetHibernateSecretRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.auth_session_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetHibernateSecretRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetHibernateSecretReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub hibernate_secret: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetHibernateSecretReply {
    fn default() -> &'a GetHibernateSecretReply {
        <GetHibernateSecretReply as ::protobuf::Message>::default_instance()
    }
}

impl GetHibernateSecretReply {
    pub fn new() -> GetHibernateSecretReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // bytes hibernate_secret = 2;


    pub fn get_hibernate_secret(&self) -> &[u8] {
        &self.hibernate_secret
    }
    pub fn clear_hibernate_secret(&mut self) {
        self.hibernate_secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_hibernate_secret(&mut self, v: ::std::vec::Vec<u8>) {
        self.hibernate_secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hibernate_secret(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hibernate_secret
    }

    // Take field
    pub fn take_hibernate_secret(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hibernate_secret, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetHibernateSecretReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hibernate_secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if !self.hibernate_secret.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hibernate_secret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if !self.hibernate_secret.is_empty() {
            os.write_bytes(2, &self.hibernate_secret)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetHibernateSecretReply {
        GetHibernateSecretReply::new()
    }

    fn default_instance() -> &'static GetHibernateSecretReply {
        static instance: ::protobuf::rt::LazyV2<GetHibernateSecretReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetHibernateSecretReply::new)
    }
}

impl ::protobuf::Clear for GetHibernateSecretReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.hibernate_secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetHibernateSecretReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StartMigrateToDircryptoRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    pub minimal_migration: bool,
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartMigrateToDircryptoRequest {
    fn default() -> &'a StartMigrateToDircryptoRequest {
        <StartMigrateToDircryptoRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartMigrateToDircryptoRequest {
    pub fn new() -> StartMigrateToDircryptoRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }

    // bool minimal_migration = 2;


    pub fn get_minimal_migration(&self) -> bool {
        self.minimal_migration
    }
    pub fn clear_minimal_migration(&mut self) {
        self.minimal_migration = false;
    }

    // Param is passed by value, moved
    pub fn set_minimal_migration(&mut self, v: bool) {
        self.minimal_migration = v;
    }

    // bytes auth_session_id = 3;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for StartMigrateToDircryptoRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.minimal_migration = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.minimal_migration != false {
            my_size += 2;
        }
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.minimal_migration != false {
            os.write_bool(2, self.minimal_migration)?;
        }
        if !self.auth_session_id.is_empty() {
            os.write_bytes(3, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartMigrateToDircryptoRequest {
        StartMigrateToDircryptoRequest::new()
    }

    fn default_instance() -> &'static StartMigrateToDircryptoRequest {
        static instance: ::protobuf::rt::LazyV2<StartMigrateToDircryptoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartMigrateToDircryptoRequest::new)
    }
}

impl ::protobuf::Clear for StartMigrateToDircryptoRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.minimal_migration = false;
        self.auth_session_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StartMigrateToDircryptoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StartMigrateToDircryptoReply {
    // message fields
    pub error: CryptohomeErrorCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartMigrateToDircryptoReply {
    fn default() -> &'a StartMigrateToDircryptoReply {
        <StartMigrateToDircryptoReply as ::protobuf::Message>::default_instance()
    }
}

impl StartMigrateToDircryptoReply {
    pub fn new() -> StartMigrateToDircryptoReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }
}

impl ::protobuf::Message for StartMigrateToDircryptoReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartMigrateToDircryptoReply {
        StartMigrateToDircryptoReply::new()
    }

    fn default_instance() -> &'static StartMigrateToDircryptoReply {
        static instance: ::protobuf::rt::LazyV2<StartMigrateToDircryptoReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartMigrateToDircryptoReply::new)
    }
}

impl ::protobuf::Clear for StartMigrateToDircryptoReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StartMigrateToDircryptoReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct DircryptoMigrationProgress {
    // message fields
    pub status: DircryptoMigrationStatus,
    pub current_bytes: u64,
    pub total_bytes: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DircryptoMigrationProgress {
    fn default() -> &'a DircryptoMigrationProgress {
        <DircryptoMigrationProgress as ::protobuf::Message>::default_instance()
    }
}

impl DircryptoMigrationProgress {
    pub fn new() -> DircryptoMigrationProgress {
        ::std::default::Default::default()
    }

    // .user_data_auth.DircryptoMigrationStatus status = 1;


    pub fn get_status(&self) -> DircryptoMigrationStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: DircryptoMigrationStatus) {
        self.status = v;
    }

    // uint64 current_bytes = 2;


    pub fn get_current_bytes(&self) -> u64 {
        self.current_bytes
    }
    pub fn clear_current_bytes(&mut self) {
        self.current_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_bytes(&mut self, v: u64) {
        self.current_bytes = v;
    }

    // uint64 total_bytes = 3;


    pub fn get_total_bytes(&self) -> u64 {
        self.total_bytes
    }
    pub fn clear_total_bytes(&mut self) {
        self.total_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_bytes(&mut self, v: u64) {
        self.total_bytes = v;
    }
}

impl ::protobuf::Message for DircryptoMigrationProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.current_bytes = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.total_bytes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_SUCCESS {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if self.current_bytes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.current_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_bytes != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_SUCCESS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if self.current_bytes != 0 {
            os.write_uint64(2, self.current_bytes)?;
        }
        if self.total_bytes != 0 {
            os.write_uint64(3, self.total_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DircryptoMigrationProgress {
        DircryptoMigrationProgress::new()
    }

    fn default_instance() -> &'static DircryptoMigrationProgress {
        static instance: ::protobuf::rt::LazyV2<DircryptoMigrationProgress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DircryptoMigrationProgress::new)
    }
}

impl ::protobuf::Clear for DircryptoMigrationProgress {
    fn clear(&mut self) {
        self.status = DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_SUCCESS;
        self.current_bytes = 0;
        self.total_bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for DircryptoMigrationProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct NeedsDircryptoMigrationRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NeedsDircryptoMigrationRequest {
    fn default() -> &'a NeedsDircryptoMigrationRequest {
        <NeedsDircryptoMigrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl NeedsDircryptoMigrationRequest {
    pub fn new() -> NeedsDircryptoMigrationRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }
}

impl ::protobuf::Message for NeedsDircryptoMigrationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NeedsDircryptoMigrationRequest {
        NeedsDircryptoMigrationRequest::new()
    }

    fn default_instance() -> &'static NeedsDircryptoMigrationRequest {
        static instance: ::protobuf::rt::LazyV2<NeedsDircryptoMigrationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NeedsDircryptoMigrationRequest::new)
    }
}

impl ::protobuf::Clear for NeedsDircryptoMigrationRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for NeedsDircryptoMigrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct NeedsDircryptoMigrationReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub needs_dircrypto_migration: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NeedsDircryptoMigrationReply {
    fn default() -> &'a NeedsDircryptoMigrationReply {
        <NeedsDircryptoMigrationReply as ::protobuf::Message>::default_instance()
    }
}

impl NeedsDircryptoMigrationReply {
    pub fn new() -> NeedsDircryptoMigrationReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // bool needs_dircrypto_migration = 2;


    pub fn get_needs_dircrypto_migration(&self) -> bool {
        self.needs_dircrypto_migration
    }
    pub fn clear_needs_dircrypto_migration(&mut self) {
        self.needs_dircrypto_migration = false;
    }

    // Param is passed by value, moved
    pub fn set_needs_dircrypto_migration(&mut self, v: bool) {
        self.needs_dircrypto_migration = v;
    }
}

impl ::protobuf::Message for NeedsDircryptoMigrationReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needs_dircrypto_migration = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if self.needs_dircrypto_migration != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if self.needs_dircrypto_migration != false {
            os.write_bool(2, self.needs_dircrypto_migration)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NeedsDircryptoMigrationReply {
        NeedsDircryptoMigrationReply::new()
    }

    fn default_instance() -> &'static NeedsDircryptoMigrationReply {
        static instance: ::protobuf::rt::LazyV2<NeedsDircryptoMigrationReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NeedsDircryptoMigrationReply::new)
    }
}

impl ::protobuf::Clear for NeedsDircryptoMigrationReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.needs_dircrypto_migration = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for NeedsDircryptoMigrationReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSupportedKeyPoliciesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSupportedKeyPoliciesRequest {
    fn default() -> &'a GetSupportedKeyPoliciesRequest {
        <GetSupportedKeyPoliciesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSupportedKeyPoliciesRequest {
    pub fn new() -> GetSupportedKeyPoliciesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSupportedKeyPoliciesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSupportedKeyPoliciesRequest {
        GetSupportedKeyPoliciesRequest::new()
    }

    fn default_instance() -> &'static GetSupportedKeyPoliciesRequest {
        static instance: ::protobuf::rt::LazyV2<GetSupportedKeyPoliciesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSupportedKeyPoliciesRequest::new)
    }
}

impl ::protobuf::Clear for GetSupportedKeyPoliciesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSupportedKeyPoliciesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSupportedKeyPoliciesReply {
    // message fields
    pub low_entropy_credentials_supported: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSupportedKeyPoliciesReply {
    fn default() -> &'a GetSupportedKeyPoliciesReply {
        <GetSupportedKeyPoliciesReply as ::protobuf::Message>::default_instance()
    }
}

impl GetSupportedKeyPoliciesReply {
    pub fn new() -> GetSupportedKeyPoliciesReply {
        ::std::default::Default::default()
    }

    // bool low_entropy_credentials_supported = 1;


    pub fn get_low_entropy_credentials_supported(&self) -> bool {
        self.low_entropy_credentials_supported
    }
    pub fn clear_low_entropy_credentials_supported(&mut self) {
        self.low_entropy_credentials_supported = false;
    }

    // Param is passed by value, moved
    pub fn set_low_entropy_credentials_supported(&mut self, v: bool) {
        self.low_entropy_credentials_supported = v;
    }
}

impl ::protobuf::Message for GetSupportedKeyPoliciesReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.low_entropy_credentials_supported = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.low_entropy_credentials_supported != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.low_entropy_credentials_supported != false {
            os.write_bool(1, self.low_entropy_credentials_supported)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSupportedKeyPoliciesReply {
        GetSupportedKeyPoliciesReply::new()
    }

    fn default_instance() -> &'static GetSupportedKeyPoliciesReply {
        static instance: ::protobuf::rt::LazyV2<GetSupportedKeyPoliciesReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSupportedKeyPoliciesReply::new)
    }
}

impl ::protobuf::Clear for GetSupportedKeyPoliciesReply {
    fn clear(&mut self) {
        self.low_entropy_credentials_supported = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSupportedKeyPoliciesReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAccountDiskUsageRequest {
    // message fields
    pub identifier: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAccountDiskUsageRequest {
    fn default() -> &'a GetAccountDiskUsageRequest {
        <GetAccountDiskUsageRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAccountDiskUsageRequest {
    pub fn new() -> GetAccountDiskUsageRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier identifier = 1;


    pub fn get_identifier(&self) -> &super::rpc::AccountIdentifier {
        self.identifier.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identifier(&mut self) {
        self.identifier.clear();
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: super::rpc::AccountIdentifier) {
        self.identifier = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.identifier.is_none() {
            self.identifier.set_default();
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> super::rpc::AccountIdentifier {
        self.identifier.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }
}

impl ::protobuf::Message for GetAccountDiskUsageRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.identifier {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identifier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identifier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identifier.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAccountDiskUsageRequest {
        GetAccountDiskUsageRequest::new()
    }

    fn default_instance() -> &'static GetAccountDiskUsageRequest {
        static instance: ::protobuf::rt::LazyV2<GetAccountDiskUsageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAccountDiskUsageRequest::new)
    }
}

impl ::protobuf::Clear for GetAccountDiskUsageRequest {
    fn clear(&mut self) {
        self.identifier.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAccountDiskUsageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAccountDiskUsageReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub size: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAccountDiskUsageReply {
    fn default() -> &'a GetAccountDiskUsageReply {
        <GetAccountDiskUsageReply as ::protobuf::Message>::default_instance()
    }
}

impl GetAccountDiskUsageReply {
    pub fn new() -> GetAccountDiskUsageReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // int64 size = 2;


    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }
}

impl ::protobuf::Message for GetAccountDiskUsageReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if self.size != 0 {
            os.write_int64(2, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAccountDiskUsageReply {
        GetAccountDiskUsageReply::new()
    }

    fn default_instance() -> &'static GetAccountDiskUsageReply {
        static instance: ::protobuf::rt::LazyV2<GetAccountDiskUsageReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAccountDiskUsageReply::new)
    }
}

impl ::protobuf::Clear for GetAccountDiskUsageReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.size = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAccountDiskUsageReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct LowDiskSpace {
    // message fields
    pub disk_free_bytes: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LowDiskSpace {
    fn default() -> &'a LowDiskSpace {
        <LowDiskSpace as ::protobuf::Message>::default_instance()
    }
}

impl LowDiskSpace {
    pub fn new() -> LowDiskSpace {
        ::std::default::Default::default()
    }

    // uint64 disk_free_bytes = 1;


    pub fn get_disk_free_bytes(&self) -> u64 {
        self.disk_free_bytes
    }
    pub fn clear_disk_free_bytes(&mut self) {
        self.disk_free_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_disk_free_bytes(&mut self, v: u64) {
        self.disk_free_bytes = v;
    }
}

impl ::protobuf::Message for LowDiskSpace {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.disk_free_bytes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.disk_free_bytes != 0 {
            my_size += ::protobuf::rt::value_size(1, self.disk_free_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.disk_free_bytes != 0 {
            os.write_uint64(1, self.disk_free_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LowDiskSpace {
        LowDiskSpace::new()
    }

    fn default_instance() -> &'static LowDiskSpace {
        static instance: ::protobuf::rt::LazyV2<LowDiskSpace> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LowDiskSpace::new)
    }
}

impl ::protobuf::Clear for LowDiskSpace {
    fn clear(&mut self) {
        self.disk_free_bytes = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for LowDiskSpace {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StartAuthSessionRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    pub flags: u32,
    pub intent: super::auth_factor::AuthIntent,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartAuthSessionRequest {
    fn default() -> &'a StartAuthSessionRequest {
        <StartAuthSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartAuthSessionRequest {
    pub fn new() -> StartAuthSessionRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }

    // uint32 flags = 2;


    pub fn get_flags(&self) -> u32 {
        self.flags
    }
    pub fn clear_flags(&mut self) {
        self.flags = 0;
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = v;
    }

    // .user_data_auth.AuthIntent intent = 3;


    pub fn get_intent(&self) -> super::auth_factor::AuthIntent {
        self.intent
    }
    pub fn clear_intent(&mut self) {
        self.intent = super::auth_factor::AuthIntent::AUTH_INTENT_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_intent(&mut self, v: super::auth_factor::AuthIntent) {
        self.intent = v;
    }
}

impl ::protobuf::Message for StartAuthSessionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.intent, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.flags != 0 {
            my_size += ::protobuf::rt::value_size(2, self.flags, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.intent != super::auth_factor::AuthIntent::AUTH_INTENT_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.intent);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.flags != 0 {
            os.write_uint32(2, self.flags)?;
        }
        if self.intent != super::auth_factor::AuthIntent::AUTH_INTENT_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.intent))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartAuthSessionRequest {
        StartAuthSessionRequest::new()
    }

    fn default_instance() -> &'static StartAuthSessionRequest {
        static instance: ::protobuf::rt::LazyV2<StartAuthSessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartAuthSessionRequest::new)
    }
}

impl ::protobuf::Clear for StartAuthSessionRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.flags = 0;
        self.intent = super::auth_factor::AuthIntent::AUTH_INTENT_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StartAuthSessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AuthFactorWithStatus {
    // message fields
    pub auth_factor: ::protobuf::SingularPtrField<super::auth_factor::AuthFactor>,
    pub available_for_intents: ::std::vec::Vec<super::auth_factor::AuthIntent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthFactorWithStatus {
    fn default() -> &'a AuthFactorWithStatus {
        <AuthFactorWithStatus as ::protobuf::Message>::default_instance()
    }
}

impl AuthFactorWithStatus {
    pub fn new() -> AuthFactorWithStatus {
        ::std::default::Default::default()
    }

    // .user_data_auth.AuthFactor auth_factor = 1;


    pub fn get_auth_factor(&self) -> &super::auth_factor::AuthFactor {
        self.auth_factor.as_ref().unwrap_or_else(|| <super::auth_factor::AuthFactor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_auth_factor(&mut self) {
        self.auth_factor.clear();
    }

    pub fn has_auth_factor(&self) -> bool {
        self.auth_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_factor(&mut self, v: super::auth_factor::AuthFactor) {
        self.auth_factor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_factor(&mut self) -> &mut super::auth_factor::AuthFactor {
        if self.auth_factor.is_none() {
            self.auth_factor.set_default();
        }
        self.auth_factor.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_factor(&mut self) -> super::auth_factor::AuthFactor {
        self.auth_factor.take().unwrap_or_else(|| super::auth_factor::AuthFactor::new())
    }

    // repeated .user_data_auth.AuthIntent available_for_intents = 2;


    pub fn get_available_for_intents(&self) -> &[super::auth_factor::AuthIntent] {
        &self.available_for_intents
    }
    pub fn clear_available_for_intents(&mut self) {
        self.available_for_intents.clear();
    }

    // Param is passed by value, moved
    pub fn set_available_for_intents(&mut self, v: ::std::vec::Vec<super::auth_factor::AuthIntent>) {
        self.available_for_intents = v;
    }

    // Mutable pointer to the field.
    pub fn mut_available_for_intents(&mut self) -> &mut ::std::vec::Vec<super::auth_factor::AuthIntent> {
        &mut self.available_for_intents
    }

    // Take field
    pub fn take_available_for_intents(&mut self) -> ::std::vec::Vec<super::auth_factor::AuthIntent> {
        ::std::mem::replace(&mut self.available_for_intents, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for AuthFactorWithStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.auth_factor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.auth_factor)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.available_for_intents, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.auth_factor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.available_for_intents {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.auth_factor.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.available_for_intents {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthFactorWithStatus {
        AuthFactorWithStatus::new()
    }

    fn default_instance() -> &'static AuthFactorWithStatus {
        static instance: ::protobuf::rt::LazyV2<AuthFactorWithStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthFactorWithStatus::new)
    }
}

impl ::protobuf::Clear for AuthFactorWithStatus {
    fn clear(&mut self) {
        self.auth_factor.clear();
        self.available_for_intents.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthFactorWithStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct StartAuthSessionReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub auth_session_id: ::std::vec::Vec<u8>,
    pub user_exists: bool,
    pub key_label_data: ::std::collections::HashMap<::std::string::String, super::key::KeyData>,
    pub auth_factors: ::protobuf::RepeatedField<super::auth_factor::AuthFactor>,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartAuthSessionReply {
    fn default() -> &'a StartAuthSessionReply {
        <StartAuthSessionReply as ::protobuf::Message>::default_instance()
    }
}

impl StartAuthSessionReply {
    pub fn new() -> StartAuthSessionReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // bytes auth_session_id = 2;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }

    // bool user_exists = 3;


    pub fn get_user_exists(&self) -> bool {
        self.user_exists
    }
    pub fn clear_user_exists(&mut self) {
        self.user_exists = false;
    }

    // Param is passed by value, moved
    pub fn set_user_exists(&mut self, v: bool) {
        self.user_exists = v;
    }

    // repeated .user_data_auth.StartAuthSessionReply.KeyLabelDataEntry key_label_data = 4;


    pub fn get_key_label_data(&self) -> &::std::collections::HashMap<::std::string::String, super::key::KeyData> {
        &self.key_label_data
    }
    pub fn clear_key_label_data(&mut self) {
        self.key_label_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_label_data(&mut self, v: ::std::collections::HashMap<::std::string::String, super::key::KeyData>) {
        self.key_label_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_key_label_data(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::key::KeyData> {
        &mut self.key_label_data
    }

    // Take field
    pub fn take_key_label_data(&mut self) -> ::std::collections::HashMap<::std::string::String, super::key::KeyData> {
        ::std::mem::replace(&mut self.key_label_data, ::std::collections::HashMap::new())
    }

    // repeated .user_data_auth.AuthFactor auth_factors = 5;


    pub fn get_auth_factors(&self) -> &[super::auth_factor::AuthFactor] {
        &self.auth_factors
    }
    pub fn clear_auth_factors(&mut self) {
        self.auth_factors.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_factors(&mut self, v: ::protobuf::RepeatedField<super::auth_factor::AuthFactor>) {
        self.auth_factors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_auth_factors(&mut self) -> &mut ::protobuf::RepeatedField<super::auth_factor::AuthFactor> {
        &mut self.auth_factors
    }

    // Take field
    pub fn take_auth_factors(&mut self) -> ::protobuf::RepeatedField<super::auth_factor::AuthFactor> {
        ::std::mem::replace(&mut self.auth_factors, ::protobuf::RepeatedField::new())
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 6;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for StartAuthSessionReply {
    fn is_initialized(&self) -> bool {
        for v in &self.auth_factors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.user_exists = tmp;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::key::KeyData>>(wire_type, is, &mut self.key_label_data)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.auth_factors)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.auth_session_id);
        }
        if self.user_exists != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::key::KeyData>>(4, &self.key_label_data);
        for value in &self.auth_factors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if !self.auth_session_id.is_empty() {
            os.write_bytes(2, &self.auth_session_id)?;
        }
        if self.user_exists != false {
            os.write_bool(3, self.user_exists)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::key::KeyData>>(4, &self.key_label_data, os)?;
        for v in &self.auth_factors {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartAuthSessionReply {
        StartAuthSessionReply::new()
    }

    fn default_instance() -> &'static StartAuthSessionReply {
        static instance: ::protobuf::rt::LazyV2<StartAuthSessionReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartAuthSessionReply::new)
    }
}

impl ::protobuf::Clear for StartAuthSessionReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.auth_session_id.clear();
        self.user_exists = false;
        self.key_label_data.clear();
        self.auth_factors.clear();
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for StartAuthSessionReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddCredentialsRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    pub authorization: ::protobuf::SingularPtrField<super::rpc::AuthorizationRequest>,
    pub add_more_credentials: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddCredentialsRequest {
    fn default() -> &'a AddCredentialsRequest {
        <AddCredentialsRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddCredentialsRequest {
    pub fn new() -> AddCredentialsRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }

    // .cryptohome.AuthorizationRequest authorization = 2;


    pub fn get_authorization(&self) -> &super::rpc::AuthorizationRequest {
        self.authorization.as_ref().unwrap_or_else(|| <super::rpc::AuthorizationRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authorization(&mut self) {
        self.authorization.clear();
    }

    pub fn has_authorization(&self) -> bool {
        self.authorization.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorization(&mut self, v: super::rpc::AuthorizationRequest) {
        self.authorization = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorization(&mut self) -> &mut super::rpc::AuthorizationRequest {
        if self.authorization.is_none() {
            self.authorization.set_default();
        }
        self.authorization.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorization(&mut self) -> super::rpc::AuthorizationRequest {
        self.authorization.take().unwrap_or_else(|| super::rpc::AuthorizationRequest::new())
    }

    // bool add_more_credentials = 3;


    pub fn get_add_more_credentials(&self) -> bool {
        self.add_more_credentials
    }
    pub fn clear_add_more_credentials(&mut self) {
        self.add_more_credentials = false;
    }

    // Param is passed by value, moved
    pub fn set_add_more_credentials(&mut self, v: bool) {
        self.add_more_credentials = v;
    }
}

impl ::protobuf::Message for AddCredentialsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.authorization {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authorization)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.add_more_credentials = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if let Some(ref v) = self.authorization.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.add_more_credentials != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if let Some(ref v) = self.authorization.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.add_more_credentials != false {
            os.write_bool(3, self.add_more_credentials)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddCredentialsRequest {
        AddCredentialsRequest::new()
    }

    fn default_instance() -> &'static AddCredentialsRequest {
        static instance: ::protobuf::rt::LazyV2<AddCredentialsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddCredentialsRequest::new)
    }
}

impl ::protobuf::Clear for AddCredentialsRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.authorization.clear();
        self.add_more_credentials = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCredentialsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddCredentialsReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddCredentialsReply {
    fn default() -> &'a AddCredentialsReply {
        <AddCredentialsReply as ::protobuf::Message>::default_instance()
    }
}

impl AddCredentialsReply {
    pub fn new() -> AddCredentialsReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 2;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for AddCredentialsReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddCredentialsReply {
        AddCredentialsReply::new()
    }

    fn default_instance() -> &'static AddCredentialsReply {
        static instance: ::protobuf::rt::LazyV2<AddCredentialsReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddCredentialsReply::new)
    }
}

impl ::protobuf::Clear for AddCredentialsReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AddCredentialsReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AuthenticateAuthSessionRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    pub authorization: ::protobuf::SingularPtrField<super::rpc::AuthorizationRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthenticateAuthSessionRequest {
    fn default() -> &'a AuthenticateAuthSessionRequest {
        <AuthenticateAuthSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticateAuthSessionRequest {
    pub fn new() -> AuthenticateAuthSessionRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }

    // .cryptohome.AuthorizationRequest authorization = 2;


    pub fn get_authorization(&self) -> &super::rpc::AuthorizationRequest {
        self.authorization.as_ref().unwrap_or_else(|| <super::rpc::AuthorizationRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authorization(&mut self) {
        self.authorization.clear();
    }

    pub fn has_authorization(&self) -> bool {
        self.authorization.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorization(&mut self, v: super::rpc::AuthorizationRequest) {
        self.authorization = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorization(&mut self) -> &mut super::rpc::AuthorizationRequest {
        if self.authorization.is_none() {
            self.authorization.set_default();
        }
        self.authorization.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorization(&mut self) -> super::rpc::AuthorizationRequest {
        self.authorization.take().unwrap_or_else(|| super::rpc::AuthorizationRequest::new())
    }
}

impl ::protobuf::Message for AuthenticateAuthSessionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.authorization {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authorization)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if let Some(ref v) = self.authorization.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if let Some(ref v) = self.authorization.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticateAuthSessionRequest {
        AuthenticateAuthSessionRequest::new()
    }

    fn default_instance() -> &'static AuthenticateAuthSessionRequest {
        static instance: ::protobuf::rt::LazyV2<AuthenticateAuthSessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthenticateAuthSessionRequest::new)
    }
}

impl ::protobuf::Clear for AuthenticateAuthSessionRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.authorization.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateAuthSessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AuthenticateAuthSessionReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub authenticated: bool,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // message oneof groups
    pub _seconds_left: ::std::option::Option<AuthenticateAuthSessionReply_oneof__seconds_left>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthenticateAuthSessionReply {
    fn default() -> &'a AuthenticateAuthSessionReply {
        <AuthenticateAuthSessionReply as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AuthenticateAuthSessionReply_oneof__seconds_left {
    seconds_left(u32),
}

impl AuthenticateAuthSessionReply {
    pub fn new() -> AuthenticateAuthSessionReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // bool authenticated = 2;


    pub fn get_authenticated(&self) -> bool {
        self.authenticated
    }
    pub fn clear_authenticated(&mut self) {
        self.authenticated = false;
    }

    // Param is passed by value, moved
    pub fn set_authenticated(&mut self, v: bool) {
        self.authenticated = v;
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 3;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }

    // uint32 seconds_left = 4;


    pub fn get_seconds_left(&self) -> u32 {
        match self._seconds_left {
            ::std::option::Option::Some(AuthenticateAuthSessionReply_oneof__seconds_left::seconds_left(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_seconds_left(&mut self) {
        self._seconds_left = ::std::option::Option::None;
    }

    pub fn has_seconds_left(&self) -> bool {
        match self._seconds_left {
            ::std::option::Option::Some(AuthenticateAuthSessionReply_oneof__seconds_left::seconds_left(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_seconds_left(&mut self, v: u32) {
        self._seconds_left = ::std::option::Option::Some(AuthenticateAuthSessionReply_oneof__seconds_left::seconds_left(v))
    }
}

impl ::protobuf::Message for AuthenticateAuthSessionReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.authenticated = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._seconds_left = ::std::option::Option::Some(AuthenticateAuthSessionReply_oneof__seconds_left::seconds_left(is.read_uint32()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if self.authenticated != false {
            my_size += 2;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self._seconds_left {
            match v {
                &AuthenticateAuthSessionReply_oneof__seconds_left::seconds_left(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if self.authenticated != false {
            os.write_bool(2, self.authenticated)?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self._seconds_left {
            match v {
                &AuthenticateAuthSessionReply_oneof__seconds_left::seconds_left(v) => {
                    os.write_uint32(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticateAuthSessionReply {
        AuthenticateAuthSessionReply::new()
    }

    fn default_instance() -> &'static AuthenticateAuthSessionReply {
        static instance: ::protobuf::rt::LazyV2<AuthenticateAuthSessionReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthenticateAuthSessionReply::new)
    }
}

impl ::protobuf::Clear for AuthenticateAuthSessionReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.authenticated = false;
        self.error_info.clear();
        self._seconds_left = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateAuthSessionReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct InvalidateAuthSessionRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InvalidateAuthSessionRequest {
    fn default() -> &'a InvalidateAuthSessionRequest {
        <InvalidateAuthSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl InvalidateAuthSessionRequest {
    pub fn new() -> InvalidateAuthSessionRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for InvalidateAuthSessionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvalidateAuthSessionRequest {
        InvalidateAuthSessionRequest::new()
    }

    fn default_instance() -> &'static InvalidateAuthSessionRequest {
        static instance: ::protobuf::rt::LazyV2<InvalidateAuthSessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InvalidateAuthSessionRequest::new)
    }
}

impl ::protobuf::Clear for InvalidateAuthSessionRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for InvalidateAuthSessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct InvalidateAuthSessionReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InvalidateAuthSessionReply {
    fn default() -> &'a InvalidateAuthSessionReply {
        <InvalidateAuthSessionReply as ::protobuf::Message>::default_instance()
    }
}

impl InvalidateAuthSessionReply {
    pub fn new() -> InvalidateAuthSessionReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 2;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for InvalidateAuthSessionReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvalidateAuthSessionReply {
        InvalidateAuthSessionReply::new()
    }

    fn default_instance() -> &'static InvalidateAuthSessionReply {
        static instance: ::protobuf::rt::LazyV2<InvalidateAuthSessionReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InvalidateAuthSessionReply::new)
    }
}

impl ::protobuf::Clear for InvalidateAuthSessionReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for InvalidateAuthSessionReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExtendAuthSessionRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    pub extension_duration: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExtendAuthSessionRequest {
    fn default() -> &'a ExtendAuthSessionRequest {
        <ExtendAuthSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExtendAuthSessionRequest {
    pub fn new() -> ExtendAuthSessionRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }

    // uint32 extension_duration = 2;


    pub fn get_extension_duration(&self) -> u32 {
        self.extension_duration
    }
    pub fn clear_extension_duration(&mut self) {
        self.extension_duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_extension_duration(&mut self, v: u32) {
        self.extension_duration = v;
    }
}

impl ::protobuf::Message for ExtendAuthSessionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.extension_duration = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if self.extension_duration != 0 {
            my_size += ::protobuf::rt::value_size(2, self.extension_duration, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if self.extension_duration != 0 {
            os.write_uint32(2, self.extension_duration)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtendAuthSessionRequest {
        ExtendAuthSessionRequest::new()
    }

    fn default_instance() -> &'static ExtendAuthSessionRequest {
        static instance: ::protobuf::rt::LazyV2<ExtendAuthSessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExtendAuthSessionRequest::new)
    }
}

impl ::protobuf::Clear for ExtendAuthSessionRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.extension_duration = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtendAuthSessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExtendAuthSessionReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // message oneof groups
    pub _seconds_left: ::std::option::Option<ExtendAuthSessionReply_oneof__seconds_left>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExtendAuthSessionReply {
    fn default() -> &'a ExtendAuthSessionReply {
        <ExtendAuthSessionReply as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ExtendAuthSessionReply_oneof__seconds_left {
    seconds_left(u32),
}

impl ExtendAuthSessionReply {
    pub fn new() -> ExtendAuthSessionReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 2;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }

    // uint32 seconds_left = 3;


    pub fn get_seconds_left(&self) -> u32 {
        match self._seconds_left {
            ::std::option::Option::Some(ExtendAuthSessionReply_oneof__seconds_left::seconds_left(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_seconds_left(&mut self) {
        self._seconds_left = ::std::option::Option::None;
    }

    pub fn has_seconds_left(&self) -> bool {
        match self._seconds_left {
            ::std::option::Option::Some(ExtendAuthSessionReply_oneof__seconds_left::seconds_left(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_seconds_left(&mut self, v: u32) {
        self._seconds_left = ::std::option::Option::Some(ExtendAuthSessionReply_oneof__seconds_left::seconds_left(v))
    }
}

impl ::protobuf::Message for ExtendAuthSessionReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._seconds_left = ::std::option::Option::Some(ExtendAuthSessionReply_oneof__seconds_left::seconds_left(is.read_uint32()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self._seconds_left {
            match v {
                &ExtendAuthSessionReply_oneof__seconds_left::seconds_left(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self._seconds_left {
            match v {
                &ExtendAuthSessionReply_oneof__seconds_left::seconds_left(v) => {
                    os.write_uint32(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtendAuthSessionReply {
        ExtendAuthSessionReply::new()
    }

    fn default_instance() -> &'static ExtendAuthSessionReply {
        static instance: ::protobuf::rt::LazyV2<ExtendAuthSessionReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExtendAuthSessionReply::new)
    }
}

impl ::protobuf::Clear for ExtendAuthSessionReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.error_info.clear();
        self._seconds_left = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtendAuthSessionReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateCredentialRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    pub old_credential_label: ::std::string::String,
    pub authorization: ::protobuf::SingularPtrField<super::rpc::AuthorizationRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateCredentialRequest {
    fn default() -> &'a UpdateCredentialRequest {
        <UpdateCredentialRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateCredentialRequest {
    pub fn new() -> UpdateCredentialRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }

    // string old_credential_label = 2;


    pub fn get_old_credential_label(&self) -> &str {
        &self.old_credential_label
    }
    pub fn clear_old_credential_label(&mut self) {
        self.old_credential_label.clear();
    }

    // Param is passed by value, moved
    pub fn set_old_credential_label(&mut self, v: ::std::string::String) {
        self.old_credential_label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_old_credential_label(&mut self) -> &mut ::std::string::String {
        &mut self.old_credential_label
    }

    // Take field
    pub fn take_old_credential_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.old_credential_label, ::std::string::String::new())
    }

    // .cryptohome.AuthorizationRequest authorization = 3;


    pub fn get_authorization(&self) -> &super::rpc::AuthorizationRequest {
        self.authorization.as_ref().unwrap_or_else(|| <super::rpc::AuthorizationRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authorization(&mut self) {
        self.authorization.clear();
    }

    pub fn has_authorization(&self) -> bool {
        self.authorization.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorization(&mut self, v: super::rpc::AuthorizationRequest) {
        self.authorization = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorization(&mut self) -> &mut super::rpc::AuthorizationRequest {
        if self.authorization.is_none() {
            self.authorization.set_default();
        }
        self.authorization.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorization(&mut self) -> super::rpc::AuthorizationRequest {
        self.authorization.take().unwrap_or_else(|| super::rpc::AuthorizationRequest::new())
    }
}

impl ::protobuf::Message for UpdateCredentialRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.authorization {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.old_credential_label)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authorization)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if !self.old_credential_label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.old_credential_label);
        }
        if let Some(ref v) = self.authorization.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if !self.old_credential_label.is_empty() {
            os.write_string(2, &self.old_credential_label)?;
        }
        if let Some(ref v) = self.authorization.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateCredentialRequest {
        UpdateCredentialRequest::new()
    }

    fn default_instance() -> &'static UpdateCredentialRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateCredentialRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateCredentialRequest::new)
    }
}

impl ::protobuf::Clear for UpdateCredentialRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.old_credential_label.clear();
        self.authorization.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateCredentialRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateCredentialReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateCredentialReply {
    fn default() -> &'a UpdateCredentialReply {
        <UpdateCredentialReply as ::protobuf::Message>::default_instance()
    }
}

impl UpdateCredentialReply {
    pub fn new() -> UpdateCredentialReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 2;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for UpdateCredentialReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateCredentialReply {
        UpdateCredentialReply::new()
    }

    fn default_instance() -> &'static UpdateCredentialReply {
        static instance: ::protobuf::rt::LazyV2<UpdateCredentialReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateCredentialReply::new)
    }
}

impl ::protobuf::Clear for UpdateCredentialReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateCredentialReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreatePersistentUserRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreatePersistentUserRequest {
    fn default() -> &'a CreatePersistentUserRequest {
        <CreatePersistentUserRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreatePersistentUserRequest {
    pub fn new() -> CreatePersistentUserRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CreatePersistentUserRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreatePersistentUserRequest {
        CreatePersistentUserRequest::new()
    }

    fn default_instance() -> &'static CreatePersistentUserRequest {
        static instance: ::protobuf::rt::LazyV2<CreatePersistentUserRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreatePersistentUserRequest::new)
    }
}

impl ::protobuf::Clear for CreatePersistentUserRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatePersistentUserRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreatePersistentUserReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub sanitized_username: ::std::string::String,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreatePersistentUserReply {
    fn default() -> &'a CreatePersistentUserReply {
        <CreatePersistentUserReply as ::protobuf::Message>::default_instance()
    }
}

impl CreatePersistentUserReply {
    pub fn new() -> CreatePersistentUserReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // string sanitized_username = 2;


    pub fn get_sanitized_username(&self) -> &str {
        &self.sanitized_username
    }
    pub fn clear_sanitized_username(&mut self) {
        self.sanitized_username.clear();
    }

    // Param is passed by value, moved
    pub fn set_sanitized_username(&mut self, v: ::std::string::String) {
        self.sanitized_username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sanitized_username(&mut self) -> &mut ::std::string::String {
        &mut self.sanitized_username
    }

    // Take field
    pub fn take_sanitized_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sanitized_username, ::std::string::String::new())
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 3;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for CreatePersistentUserReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sanitized_username)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if !self.sanitized_username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sanitized_username);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if !self.sanitized_username.is_empty() {
            os.write_string(2, &self.sanitized_username)?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreatePersistentUserReply {
        CreatePersistentUserReply::new()
    }

    fn default_instance() -> &'static CreatePersistentUserReply {
        static instance: ::protobuf::rt::LazyV2<CreatePersistentUserReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreatePersistentUserReply::new)
    }
}

impl ::protobuf::Clear for CreatePersistentUserReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.sanitized_username.clear();
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CreatePersistentUserReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PrepareGuestVaultRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrepareGuestVaultRequest {
    fn default() -> &'a PrepareGuestVaultRequest {
        <PrepareGuestVaultRequest as ::protobuf::Message>::default_instance()
    }
}

impl PrepareGuestVaultRequest {
    pub fn new() -> PrepareGuestVaultRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PrepareGuestVaultRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrepareGuestVaultRequest {
        PrepareGuestVaultRequest::new()
    }

    fn default_instance() -> &'static PrepareGuestVaultRequest {
        static instance: ::protobuf::rt::LazyV2<PrepareGuestVaultRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrepareGuestVaultRequest::new)
    }
}

impl ::protobuf::Clear for PrepareGuestVaultRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PrepareGuestVaultRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PrepareGuestVaultReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub sanitized_username: ::std::string::String,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrepareGuestVaultReply {
    fn default() -> &'a PrepareGuestVaultReply {
        <PrepareGuestVaultReply as ::protobuf::Message>::default_instance()
    }
}

impl PrepareGuestVaultReply {
    pub fn new() -> PrepareGuestVaultReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // string sanitized_username = 2;


    pub fn get_sanitized_username(&self) -> &str {
        &self.sanitized_username
    }
    pub fn clear_sanitized_username(&mut self) {
        self.sanitized_username.clear();
    }

    // Param is passed by value, moved
    pub fn set_sanitized_username(&mut self, v: ::std::string::String) {
        self.sanitized_username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sanitized_username(&mut self) -> &mut ::std::string::String {
        &mut self.sanitized_username
    }

    // Take field
    pub fn take_sanitized_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sanitized_username, ::std::string::String::new())
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 3;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for PrepareGuestVaultReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sanitized_username)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if !self.sanitized_username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sanitized_username);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if !self.sanitized_username.is_empty() {
            os.write_string(2, &self.sanitized_username)?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrepareGuestVaultReply {
        PrepareGuestVaultReply::new()
    }

    fn default_instance() -> &'static PrepareGuestVaultReply {
        static instance: ::protobuf::rt::LazyV2<PrepareGuestVaultReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrepareGuestVaultReply::new)
    }
}

impl ::protobuf::Clear for PrepareGuestVaultReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.sanitized_username.clear();
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PrepareGuestVaultReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PrepareEphemeralVaultRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrepareEphemeralVaultRequest {
    fn default() -> &'a PrepareEphemeralVaultRequest {
        <PrepareEphemeralVaultRequest as ::protobuf::Message>::default_instance()
    }
}

impl PrepareEphemeralVaultRequest {
    pub fn new() -> PrepareEphemeralVaultRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PrepareEphemeralVaultRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrepareEphemeralVaultRequest {
        PrepareEphemeralVaultRequest::new()
    }

    fn default_instance() -> &'static PrepareEphemeralVaultRequest {
        static instance: ::protobuf::rt::LazyV2<PrepareEphemeralVaultRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrepareEphemeralVaultRequest::new)
    }
}

impl ::protobuf::Clear for PrepareEphemeralVaultRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PrepareEphemeralVaultRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PrepareEphemeralVaultReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub sanitized_username: ::std::string::String,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrepareEphemeralVaultReply {
    fn default() -> &'a PrepareEphemeralVaultReply {
        <PrepareEphemeralVaultReply as ::protobuf::Message>::default_instance()
    }
}

impl PrepareEphemeralVaultReply {
    pub fn new() -> PrepareEphemeralVaultReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // string sanitized_username = 2;


    pub fn get_sanitized_username(&self) -> &str {
        &self.sanitized_username
    }
    pub fn clear_sanitized_username(&mut self) {
        self.sanitized_username.clear();
    }

    // Param is passed by value, moved
    pub fn set_sanitized_username(&mut self, v: ::std::string::String) {
        self.sanitized_username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sanitized_username(&mut self) -> &mut ::std::string::String {
        &mut self.sanitized_username
    }

    // Take field
    pub fn take_sanitized_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sanitized_username, ::std::string::String::new())
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 3;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for PrepareEphemeralVaultReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sanitized_username)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if !self.sanitized_username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sanitized_username);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if !self.sanitized_username.is_empty() {
            os.write_string(2, &self.sanitized_username)?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrepareEphemeralVaultReply {
        PrepareEphemeralVaultReply::new()
    }

    fn default_instance() -> &'static PrepareEphemeralVaultReply {
        static instance: ::protobuf::rt::LazyV2<PrepareEphemeralVaultReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrepareEphemeralVaultReply::new)
    }
}

impl ::protobuf::Clear for PrepareEphemeralVaultReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.sanitized_username.clear();
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PrepareEphemeralVaultReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAuthSessionStatusRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAuthSessionStatusRequest {
    fn default() -> &'a GetAuthSessionStatusRequest {
        <GetAuthSessionStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAuthSessionStatusRequest {
    pub fn new() -> GetAuthSessionStatusRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetAuthSessionStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAuthSessionStatusRequest {
        GetAuthSessionStatusRequest::new()
    }

    fn default_instance() -> &'static GetAuthSessionStatusRequest {
        static instance: ::protobuf::rt::LazyV2<GetAuthSessionStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAuthSessionStatusRequest::new)
    }
}

impl ::protobuf::Clear for GetAuthSessionStatusRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAuthSessionStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetAuthSessionStatusReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub status: AuthSessionStatus,
    pub time_left: u32,
    pub authorized_for: ::std::vec::Vec<super::auth_factor::AuthIntent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAuthSessionStatusReply {
    fn default() -> &'a GetAuthSessionStatusReply {
        <GetAuthSessionStatusReply as ::protobuf::Message>::default_instance()
    }
}

impl GetAuthSessionStatusReply {
    pub fn new() -> GetAuthSessionStatusReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.AuthSessionStatus status = 2;


    pub fn get_status(&self) -> AuthSessionStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = AuthSessionStatus::AUTH_SESSION_STATUS_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: AuthSessionStatus) {
        self.status = v;
    }

    // uint32 time_left = 3;


    pub fn get_time_left(&self) -> u32 {
        self.time_left
    }
    pub fn clear_time_left(&mut self) {
        self.time_left = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_left(&mut self, v: u32) {
        self.time_left = v;
    }

    // repeated .user_data_auth.AuthIntent authorized_for = 4;


    pub fn get_authorized_for(&self) -> &[super::auth_factor::AuthIntent] {
        &self.authorized_for
    }
    pub fn clear_authorized_for(&mut self) {
        self.authorized_for.clear();
    }

    // Param is passed by value, moved
    pub fn set_authorized_for(&mut self, v: ::std::vec::Vec<super::auth_factor::AuthIntent>) {
        self.authorized_for = v;
    }

    // Mutable pointer to the field.
    pub fn mut_authorized_for(&mut self) -> &mut ::std::vec::Vec<super::auth_factor::AuthIntent> {
        &mut self.authorized_for
    }

    // Take field
    pub fn take_authorized_for(&mut self) -> ::std::vec::Vec<super::auth_factor::AuthIntent> {
        ::std::mem::replace(&mut self.authorized_for, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetAuthSessionStatusReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_left = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.authorized_for, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if self.status != AuthSessionStatus::AUTH_SESSION_STATUS_NOT_SET {
            my_size += ::protobuf::rt::enum_size(2, self.status);
        }
        if self.time_left != 0 {
            my_size += ::protobuf::rt::value_size(3, self.time_left, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.authorized_for {
            my_size += ::protobuf::rt::enum_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if self.status != AuthSessionStatus::AUTH_SESSION_STATUS_NOT_SET {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if self.time_left != 0 {
            os.write_uint32(3, self.time_left)?;
        }
        for v in &self.authorized_for {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAuthSessionStatusReply {
        GetAuthSessionStatusReply::new()
    }

    fn default_instance() -> &'static GetAuthSessionStatusReply {
        static instance: ::protobuf::rt::LazyV2<GetAuthSessionStatusReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAuthSessionStatusReply::new)
    }
}

impl ::protobuf::Clear for GetAuthSessionStatusReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.status = AuthSessionStatus::AUTH_SESSION_STATUS_NOT_SET;
        self.time_left = 0;
        self.authorized_for.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAuthSessionStatusReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PreparePersistentVaultRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    pub block_ecryptfs: bool,
    pub encryption_type: VaultEncryptionType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreparePersistentVaultRequest {
    fn default() -> &'a PreparePersistentVaultRequest {
        <PreparePersistentVaultRequest as ::protobuf::Message>::default_instance()
    }
}

impl PreparePersistentVaultRequest {
    pub fn new() -> PreparePersistentVaultRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }

    // bool block_ecryptfs = 2;


    pub fn get_block_ecryptfs(&self) -> bool {
        self.block_ecryptfs
    }
    pub fn clear_block_ecryptfs(&mut self) {
        self.block_ecryptfs = false;
    }

    // Param is passed by value, moved
    pub fn set_block_ecryptfs(&mut self, v: bool) {
        self.block_ecryptfs = v;
    }

    // .user_data_auth.VaultEncryptionType encryption_type = 3;


    pub fn get_encryption_type(&self) -> VaultEncryptionType {
        self.encryption_type
    }
    pub fn clear_encryption_type(&mut self) {
        self.encryption_type = VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ANY;
    }

    // Param is passed by value, moved
    pub fn set_encryption_type(&mut self, v: VaultEncryptionType) {
        self.encryption_type = v;
    }
}

impl ::protobuf::Message for PreparePersistentVaultRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.block_ecryptfs = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encryption_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if self.block_ecryptfs != false {
            my_size += 2;
        }
        if self.encryption_type != VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ANY {
            my_size += ::protobuf::rt::enum_size(3, self.encryption_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if self.block_ecryptfs != false {
            os.write_bool(2, self.block_ecryptfs)?;
        }
        if self.encryption_type != VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ANY {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.encryption_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreparePersistentVaultRequest {
        PreparePersistentVaultRequest::new()
    }

    fn default_instance() -> &'static PreparePersistentVaultRequest {
        static instance: ::protobuf::rt::LazyV2<PreparePersistentVaultRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PreparePersistentVaultRequest::new)
    }
}

impl ::protobuf::Clear for PreparePersistentVaultRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.block_ecryptfs = false;
        self.encryption_type = VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ANY;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PreparePersistentVaultRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PreparePersistentVaultReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub sanitized_username: ::std::string::String,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreparePersistentVaultReply {
    fn default() -> &'a PreparePersistentVaultReply {
        <PreparePersistentVaultReply as ::protobuf::Message>::default_instance()
    }
}

impl PreparePersistentVaultReply {
    pub fn new() -> PreparePersistentVaultReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // string sanitized_username = 2;


    pub fn get_sanitized_username(&self) -> &str {
        &self.sanitized_username
    }
    pub fn clear_sanitized_username(&mut self) {
        self.sanitized_username.clear();
    }

    // Param is passed by value, moved
    pub fn set_sanitized_username(&mut self, v: ::std::string::String) {
        self.sanitized_username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sanitized_username(&mut self) -> &mut ::std::string::String {
        &mut self.sanitized_username
    }

    // Take field
    pub fn take_sanitized_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sanitized_username, ::std::string::String::new())
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 3;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for PreparePersistentVaultReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sanitized_username)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if !self.sanitized_username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sanitized_username);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if !self.sanitized_username.is_empty() {
            os.write_string(2, &self.sanitized_username)?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreparePersistentVaultReply {
        PreparePersistentVaultReply::new()
    }

    fn default_instance() -> &'static PreparePersistentVaultReply {
        static instance: ::protobuf::rt::LazyV2<PreparePersistentVaultReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PreparePersistentVaultReply::new)
    }
}

impl ::protobuf::Clear for PreparePersistentVaultReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.sanitized_username.clear();
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PreparePersistentVaultReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PrepareVaultForMigrationRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrepareVaultForMigrationRequest {
    fn default() -> &'a PrepareVaultForMigrationRequest {
        <PrepareVaultForMigrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl PrepareVaultForMigrationRequest {
    pub fn new() -> PrepareVaultForMigrationRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PrepareVaultForMigrationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrepareVaultForMigrationRequest {
        PrepareVaultForMigrationRequest::new()
    }

    fn default_instance() -> &'static PrepareVaultForMigrationRequest {
        static instance: ::protobuf::rt::LazyV2<PrepareVaultForMigrationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrepareVaultForMigrationRequest::new)
    }
}

impl ::protobuf::Clear for PrepareVaultForMigrationRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PrepareVaultForMigrationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PrepareVaultForMigrationReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub sanitized_username: ::std::string::String,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrepareVaultForMigrationReply {
    fn default() -> &'a PrepareVaultForMigrationReply {
        <PrepareVaultForMigrationReply as ::protobuf::Message>::default_instance()
    }
}

impl PrepareVaultForMigrationReply {
    pub fn new() -> PrepareVaultForMigrationReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // string sanitized_username = 2;


    pub fn get_sanitized_username(&self) -> &str {
        &self.sanitized_username
    }
    pub fn clear_sanitized_username(&mut self) {
        self.sanitized_username.clear();
    }

    // Param is passed by value, moved
    pub fn set_sanitized_username(&mut self, v: ::std::string::String) {
        self.sanitized_username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sanitized_username(&mut self) -> &mut ::std::string::String {
        &mut self.sanitized_username
    }

    // Take field
    pub fn take_sanitized_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sanitized_username, ::std::string::String::new())
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 3;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for PrepareVaultForMigrationReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sanitized_username)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if !self.sanitized_username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sanitized_username);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if !self.sanitized_username.is_empty() {
            os.write_string(2, &self.sanitized_username)?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrepareVaultForMigrationReply {
        PrepareVaultForMigrationReply::new()
    }

    fn default_instance() -> &'static PrepareVaultForMigrationReply {
        static instance: ::protobuf::rt::LazyV2<PrepareVaultForMigrationReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrepareVaultForMigrationReply::new)
    }
}

impl ::protobuf::Clear for PrepareVaultForMigrationReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.sanitized_username.clear();
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PrepareVaultForMigrationReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetArcDiskFeaturesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetArcDiskFeaturesRequest {
    fn default() -> &'a GetArcDiskFeaturesRequest {
        <GetArcDiskFeaturesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetArcDiskFeaturesRequest {
    pub fn new() -> GetArcDiskFeaturesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetArcDiskFeaturesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetArcDiskFeaturesRequest {
        GetArcDiskFeaturesRequest::new()
    }

    fn default_instance() -> &'static GetArcDiskFeaturesRequest {
        static instance: ::protobuf::rt::LazyV2<GetArcDiskFeaturesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetArcDiskFeaturesRequest::new)
    }
}

impl ::protobuf::Clear for GetArcDiskFeaturesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetArcDiskFeaturesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetArcDiskFeaturesReply {
    // message fields
    pub quota_supported: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetArcDiskFeaturesReply {
    fn default() -> &'a GetArcDiskFeaturesReply {
        <GetArcDiskFeaturesReply as ::protobuf::Message>::default_instance()
    }
}

impl GetArcDiskFeaturesReply {
    pub fn new() -> GetArcDiskFeaturesReply {
        ::std::default::Default::default()
    }

    // bool quota_supported = 1;


    pub fn get_quota_supported(&self) -> bool {
        self.quota_supported
    }
    pub fn clear_quota_supported(&mut self) {
        self.quota_supported = false;
    }

    // Param is passed by value, moved
    pub fn set_quota_supported(&mut self, v: bool) {
        self.quota_supported = v;
    }
}

impl ::protobuf::Message for GetArcDiskFeaturesReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.quota_supported = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.quota_supported != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.quota_supported != false {
            os.write_bool(1, self.quota_supported)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetArcDiskFeaturesReply {
        GetArcDiskFeaturesReply::new()
    }

    fn default_instance() -> &'static GetArcDiskFeaturesReply {
        static instance: ::protobuf::rt::LazyV2<GetArcDiskFeaturesReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetArcDiskFeaturesReply::new)
    }
}

impl ::protobuf::Clear for GetArcDiskFeaturesReply {
    fn clear(&mut self) {
        self.quota_supported = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetArcDiskFeaturesReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCurrentSpaceForArcUidRequest {
    // message fields
    pub uid: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCurrentSpaceForArcUidRequest {
    fn default() -> &'a GetCurrentSpaceForArcUidRequest {
        <GetCurrentSpaceForArcUidRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentSpaceForArcUidRequest {
    pub fn new() -> GetCurrentSpaceForArcUidRequest {
        ::std::default::Default::default()
    }

    // uint32 uid = 1;


    pub fn get_uid(&self) -> u32 {
        self.uid
    }
    pub fn clear_uid(&mut self) {
        self.uid = 0;
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: u32) {
        self.uid = v;
    }
}

impl ::protobuf::Message for GetCurrentSpaceForArcUidRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.uid = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.uid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.uid, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.uid != 0 {
            os.write_uint32(1, self.uid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCurrentSpaceForArcUidRequest {
        GetCurrentSpaceForArcUidRequest::new()
    }

    fn default_instance() -> &'static GetCurrentSpaceForArcUidRequest {
        static instance: ::protobuf::rt::LazyV2<GetCurrentSpaceForArcUidRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCurrentSpaceForArcUidRequest::new)
    }
}

impl ::protobuf::Clear for GetCurrentSpaceForArcUidRequest {
    fn clear(&mut self) {
        self.uid = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentSpaceForArcUidRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCurrentSpaceForArcUidReply {
    // message fields
    pub cur_space: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCurrentSpaceForArcUidReply {
    fn default() -> &'a GetCurrentSpaceForArcUidReply {
        <GetCurrentSpaceForArcUidReply as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentSpaceForArcUidReply {
    pub fn new() -> GetCurrentSpaceForArcUidReply {
        ::std::default::Default::default()
    }

    // int64 cur_space = 1;


    pub fn get_cur_space(&self) -> i64 {
        self.cur_space
    }
    pub fn clear_cur_space(&mut self) {
        self.cur_space = 0;
    }

    // Param is passed by value, moved
    pub fn set_cur_space(&mut self, v: i64) {
        self.cur_space = v;
    }
}

impl ::protobuf::Message for GetCurrentSpaceForArcUidReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cur_space = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cur_space != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cur_space, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cur_space != 0 {
            os.write_int64(1, self.cur_space)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCurrentSpaceForArcUidReply {
        GetCurrentSpaceForArcUidReply::new()
    }

    fn default_instance() -> &'static GetCurrentSpaceForArcUidReply {
        static instance: ::protobuf::rt::LazyV2<GetCurrentSpaceForArcUidReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCurrentSpaceForArcUidReply::new)
    }
}

impl ::protobuf::Clear for GetCurrentSpaceForArcUidReply {
    fn clear(&mut self) {
        self.cur_space = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentSpaceForArcUidReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCurrentSpaceForArcGidRequest {
    // message fields
    pub gid: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCurrentSpaceForArcGidRequest {
    fn default() -> &'a GetCurrentSpaceForArcGidRequest {
        <GetCurrentSpaceForArcGidRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentSpaceForArcGidRequest {
    pub fn new() -> GetCurrentSpaceForArcGidRequest {
        ::std::default::Default::default()
    }

    // uint32 gid = 1;


    pub fn get_gid(&self) -> u32 {
        self.gid
    }
    pub fn clear_gid(&mut self) {
        self.gid = 0;
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u32) {
        self.gid = v;
    }
}

impl ::protobuf::Message for GetCurrentSpaceForArcGidRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.gid = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.gid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.gid, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.gid != 0 {
            os.write_uint32(1, self.gid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCurrentSpaceForArcGidRequest {
        GetCurrentSpaceForArcGidRequest::new()
    }

    fn default_instance() -> &'static GetCurrentSpaceForArcGidRequest {
        static instance: ::protobuf::rt::LazyV2<GetCurrentSpaceForArcGidRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCurrentSpaceForArcGidRequest::new)
    }
}

impl ::protobuf::Clear for GetCurrentSpaceForArcGidRequest {
    fn clear(&mut self) {
        self.gid = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentSpaceForArcGidRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCurrentSpaceForArcGidReply {
    // message fields
    pub cur_space: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCurrentSpaceForArcGidReply {
    fn default() -> &'a GetCurrentSpaceForArcGidReply {
        <GetCurrentSpaceForArcGidReply as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentSpaceForArcGidReply {
    pub fn new() -> GetCurrentSpaceForArcGidReply {
        ::std::default::Default::default()
    }

    // int64 cur_space = 1;


    pub fn get_cur_space(&self) -> i64 {
        self.cur_space
    }
    pub fn clear_cur_space(&mut self) {
        self.cur_space = 0;
    }

    // Param is passed by value, moved
    pub fn set_cur_space(&mut self, v: i64) {
        self.cur_space = v;
    }
}

impl ::protobuf::Message for GetCurrentSpaceForArcGidReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cur_space = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cur_space != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cur_space, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cur_space != 0 {
            os.write_int64(1, self.cur_space)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCurrentSpaceForArcGidReply {
        GetCurrentSpaceForArcGidReply::new()
    }

    fn default_instance() -> &'static GetCurrentSpaceForArcGidReply {
        static instance: ::protobuf::rt::LazyV2<GetCurrentSpaceForArcGidReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCurrentSpaceForArcGidReply::new)
    }
}

impl ::protobuf::Clear for GetCurrentSpaceForArcGidReply {
    fn clear(&mut self) {
        self.cur_space = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentSpaceForArcGidReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCurrentSpaceForArcProjectIdRequest {
    // message fields
    pub project_id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCurrentSpaceForArcProjectIdRequest {
    fn default() -> &'a GetCurrentSpaceForArcProjectIdRequest {
        <GetCurrentSpaceForArcProjectIdRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentSpaceForArcProjectIdRequest {
    pub fn new() -> GetCurrentSpaceForArcProjectIdRequest {
        ::std::default::Default::default()
    }

    // uint32 project_id = 1;


    pub fn get_project_id(&self) -> u32 {
        self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: u32) {
        self.project_id = v;
    }
}

impl ::protobuf::Message for GetCurrentSpaceForArcProjectIdRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.project_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.project_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.project_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.project_id != 0 {
            os.write_uint32(1, self.project_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCurrentSpaceForArcProjectIdRequest {
        GetCurrentSpaceForArcProjectIdRequest::new()
    }

    fn default_instance() -> &'static GetCurrentSpaceForArcProjectIdRequest {
        static instance: ::protobuf::rt::LazyV2<GetCurrentSpaceForArcProjectIdRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCurrentSpaceForArcProjectIdRequest::new)
    }
}

impl ::protobuf::Clear for GetCurrentSpaceForArcProjectIdRequest {
    fn clear(&mut self) {
        self.project_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentSpaceForArcProjectIdRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCurrentSpaceForArcProjectIdReply {
    // message fields
    pub cur_space: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCurrentSpaceForArcProjectIdReply {
    fn default() -> &'a GetCurrentSpaceForArcProjectIdReply {
        <GetCurrentSpaceForArcProjectIdReply as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentSpaceForArcProjectIdReply {
    pub fn new() -> GetCurrentSpaceForArcProjectIdReply {
        ::std::default::Default::default()
    }

    // int64 cur_space = 1;


    pub fn get_cur_space(&self) -> i64 {
        self.cur_space
    }
    pub fn clear_cur_space(&mut self) {
        self.cur_space = 0;
    }

    // Param is passed by value, moved
    pub fn set_cur_space(&mut self, v: i64) {
        self.cur_space = v;
    }
}

impl ::protobuf::Message for GetCurrentSpaceForArcProjectIdReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cur_space = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cur_space != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cur_space, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cur_space != 0 {
            os.write_int64(1, self.cur_space)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCurrentSpaceForArcProjectIdReply {
        GetCurrentSpaceForArcProjectIdReply::new()
    }

    fn default_instance() -> &'static GetCurrentSpaceForArcProjectIdReply {
        static instance: ::protobuf::rt::LazyV2<GetCurrentSpaceForArcProjectIdReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCurrentSpaceForArcProjectIdReply::new)
    }
}

impl ::protobuf::Clear for GetCurrentSpaceForArcProjectIdReply {
    fn clear(&mut self) {
        self.cur_space = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCurrentSpaceForArcProjectIdReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetMediaRWDataFileProjectIdRequest {
    // message fields
    pub project_id: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetMediaRWDataFileProjectIdRequest {
    fn default() -> &'a SetMediaRWDataFileProjectIdRequest {
        <SetMediaRWDataFileProjectIdRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetMediaRWDataFileProjectIdRequest {
    pub fn new() -> SetMediaRWDataFileProjectIdRequest {
        ::std::default::Default::default()
    }

    // uint32 project_id = 1;


    pub fn get_project_id(&self) -> u32 {
        self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: u32) {
        self.project_id = v;
    }
}

impl ::protobuf::Message for SetMediaRWDataFileProjectIdRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.project_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.project_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.project_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.project_id != 0 {
            os.write_uint32(1, self.project_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetMediaRWDataFileProjectIdRequest {
        SetMediaRWDataFileProjectIdRequest::new()
    }

    fn default_instance() -> &'static SetMediaRWDataFileProjectIdRequest {
        static instance: ::protobuf::rt::LazyV2<SetMediaRWDataFileProjectIdRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetMediaRWDataFileProjectIdRequest::new)
    }
}

impl ::protobuf::Clear for SetMediaRWDataFileProjectIdRequest {
    fn clear(&mut self) {
        self.project_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SetMediaRWDataFileProjectIdRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetMediaRWDataFileProjectIdReply {
    // message fields
    pub success: bool,
    pub error: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetMediaRWDataFileProjectIdReply {
    fn default() -> &'a SetMediaRWDataFileProjectIdReply {
        <SetMediaRWDataFileProjectIdReply as ::protobuf::Message>::default_instance()
    }
}

impl SetMediaRWDataFileProjectIdReply {
    pub fn new() -> SetMediaRWDataFileProjectIdReply {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // int32 error = 2;


    pub fn get_error(&self) -> i32 {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = 0;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: i32) {
        self.error = v;
    }
}

impl ::protobuf::Message for SetMediaRWDataFileProjectIdReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.error = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if self.error != 0 {
            my_size += ::protobuf::rt::value_size(2, self.error, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.error != 0 {
            os.write_int32(2, self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetMediaRWDataFileProjectIdReply {
        SetMediaRWDataFileProjectIdReply::new()
    }

    fn default_instance() -> &'static SetMediaRWDataFileProjectIdReply {
        static instance: ::protobuf::rt::LazyV2<SetMediaRWDataFileProjectIdReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetMediaRWDataFileProjectIdReply::new)
    }
}

impl ::protobuf::Clear for SetMediaRWDataFileProjectIdReply {
    fn clear(&mut self) {
        self.success = false;
        self.error = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SetMediaRWDataFileProjectIdReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetMediaRWDataFileProjectInheritanceFlagRequest {
    // message fields
    pub enable: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetMediaRWDataFileProjectInheritanceFlagRequest {
    fn default() -> &'a SetMediaRWDataFileProjectInheritanceFlagRequest {
        <SetMediaRWDataFileProjectInheritanceFlagRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetMediaRWDataFileProjectInheritanceFlagRequest {
    pub fn new() -> SetMediaRWDataFileProjectInheritanceFlagRequest {
        ::std::default::Default::default()
    }

    // bool enable = 1;


    pub fn get_enable(&self) -> bool {
        self.enable
    }
    pub fn clear_enable(&mut self) {
        self.enable = false;
    }

    // Param is passed by value, moved
    pub fn set_enable(&mut self, v: bool) {
        self.enable = v;
    }
}

impl ::protobuf::Message for SetMediaRWDataFileProjectInheritanceFlagRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enable != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enable != false {
            os.write_bool(1, self.enable)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetMediaRWDataFileProjectInheritanceFlagRequest {
        SetMediaRWDataFileProjectInheritanceFlagRequest::new()
    }

    fn default_instance() -> &'static SetMediaRWDataFileProjectInheritanceFlagRequest {
        static instance: ::protobuf::rt::LazyV2<SetMediaRWDataFileProjectInheritanceFlagRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetMediaRWDataFileProjectInheritanceFlagRequest::new)
    }
}

impl ::protobuf::Clear for SetMediaRWDataFileProjectInheritanceFlagRequest {
    fn clear(&mut self) {
        self.enable = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SetMediaRWDataFileProjectInheritanceFlagRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetMediaRWDataFileProjectInheritanceFlagReply {
    // message fields
    pub success: bool,
    pub error: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetMediaRWDataFileProjectInheritanceFlagReply {
    fn default() -> &'a SetMediaRWDataFileProjectInheritanceFlagReply {
        <SetMediaRWDataFileProjectInheritanceFlagReply as ::protobuf::Message>::default_instance()
    }
}

impl SetMediaRWDataFileProjectInheritanceFlagReply {
    pub fn new() -> SetMediaRWDataFileProjectInheritanceFlagReply {
        ::std::default::Default::default()
    }

    // bool success = 1;


    pub fn get_success(&self) -> bool {
        self.success
    }
    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    // int32 error = 2;


    pub fn get_error(&self) -> i32 {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = 0;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: i32) {
        self.error = v;
    }
}

impl ::protobuf::Message for SetMediaRWDataFileProjectInheritanceFlagReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.error = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if self.error != 0 {
            my_size += ::protobuf::rt::value_size(2, self.error, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.error != 0 {
            os.write_int32(2, self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetMediaRWDataFileProjectInheritanceFlagReply {
        SetMediaRWDataFileProjectInheritanceFlagReply::new()
    }

    fn default_instance() -> &'static SetMediaRWDataFileProjectInheritanceFlagReply {
        static instance: ::protobuf::rt::LazyV2<SetMediaRWDataFileProjectInheritanceFlagReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetMediaRWDataFileProjectInheritanceFlagReply::new)
    }
}

impl ::protobuf::Clear for SetMediaRWDataFileProjectInheritanceFlagReply {
    fn clear(&mut self) {
        self.success = false;
        self.error = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SetMediaRWDataFileProjectInheritanceFlagReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct TpmTokenInfo {
    // message fields
    pub label: ::std::string::String,
    pub user_pin: ::std::string::String,
    pub slot: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TpmTokenInfo {
    fn default() -> &'a TpmTokenInfo {
        <TpmTokenInfo as ::protobuf::Message>::default_instance()
    }
}

impl TpmTokenInfo {
    pub fn new() -> TpmTokenInfo {
        ::std::default::Default::default()
    }

    // string label = 1;


    pub fn get_label(&self) -> &str {
        &self.label
    }
    pub fn clear_label(&mut self) {
        self.label.clear();
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        &mut self.label
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label, ::std::string::String::new())
    }

    // string user_pin = 2;


    pub fn get_user_pin(&self) -> &str {
        &self.user_pin
    }
    pub fn clear_user_pin(&mut self) {
        self.user_pin.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_pin(&mut self, v: ::std::string::String) {
        self.user_pin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_pin(&mut self) -> &mut ::std::string::String {
        &mut self.user_pin
    }

    // Take field
    pub fn take_user_pin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user_pin, ::std::string::String::new())
    }

    // int32 slot = 3;


    pub fn get_slot(&self) -> i32 {
        self.slot
    }
    pub fn clear_slot(&mut self) {
        self.slot = 0;
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = v;
    }
}

impl ::protobuf::Message for TpmTokenInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user_pin)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.slot = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        if !self.user_pin.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user_pin);
        }
        if self.slot != 0 {
            my_size += ::protobuf::rt::value_size(3, self.slot, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        if !self.user_pin.is_empty() {
            os.write_string(2, &self.user_pin)?;
        }
        if self.slot != 0 {
            os.write_int32(3, self.slot)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TpmTokenInfo {
        TpmTokenInfo::new()
    }

    fn default_instance() -> &'static TpmTokenInfo {
        static instance: ::protobuf::rt::LazyV2<TpmTokenInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TpmTokenInfo::new)
    }
}

impl ::protobuf::Clear for TpmTokenInfo {
    fn clear(&mut self) {
        self.label.clear();
        self.user_pin.clear();
        self.slot = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for TpmTokenInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pkcs11IsTpmTokenReadyRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pkcs11IsTpmTokenReadyRequest {
    fn default() -> &'a Pkcs11IsTpmTokenReadyRequest {
        <Pkcs11IsTpmTokenReadyRequest as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11IsTpmTokenReadyRequest {
    pub fn new() -> Pkcs11IsTpmTokenReadyRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Pkcs11IsTpmTokenReadyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pkcs11IsTpmTokenReadyRequest {
        Pkcs11IsTpmTokenReadyRequest::new()
    }

    fn default_instance() -> &'static Pkcs11IsTpmTokenReadyRequest {
        static instance: ::protobuf::rt::LazyV2<Pkcs11IsTpmTokenReadyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pkcs11IsTpmTokenReadyRequest::new)
    }
}

impl ::protobuf::Clear for Pkcs11IsTpmTokenReadyRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Pkcs11IsTpmTokenReadyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pkcs11IsTpmTokenReadyReply {
    // message fields
    pub ready: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pkcs11IsTpmTokenReadyReply {
    fn default() -> &'a Pkcs11IsTpmTokenReadyReply {
        <Pkcs11IsTpmTokenReadyReply as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11IsTpmTokenReadyReply {
    pub fn new() -> Pkcs11IsTpmTokenReadyReply {
        ::std::default::Default::default()
    }

    // bool ready = 1;


    pub fn get_ready(&self) -> bool {
        self.ready
    }
    pub fn clear_ready(&mut self) {
        self.ready = false;
    }

    // Param is passed by value, moved
    pub fn set_ready(&mut self, v: bool) {
        self.ready = v;
    }
}

impl ::protobuf::Message for Pkcs11IsTpmTokenReadyReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ready = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ready != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ready != false {
            os.write_bool(1, self.ready)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pkcs11IsTpmTokenReadyReply {
        Pkcs11IsTpmTokenReadyReply::new()
    }

    fn default_instance() -> &'static Pkcs11IsTpmTokenReadyReply {
        static instance: ::protobuf::rt::LazyV2<Pkcs11IsTpmTokenReadyReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pkcs11IsTpmTokenReadyReply::new)
    }
}

impl ::protobuf::Clear for Pkcs11IsTpmTokenReadyReply {
    fn clear(&mut self) {
        self.ready = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Pkcs11IsTpmTokenReadyReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pkcs11GetTpmTokenInfoRequest {
    // message fields
    pub username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pkcs11GetTpmTokenInfoRequest {
    fn default() -> &'a Pkcs11GetTpmTokenInfoRequest {
        <Pkcs11GetTpmTokenInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11GetTpmTokenInfoRequest {
    pub fn new() -> Pkcs11GetTpmTokenInfoRequest {
        ::std::default::Default::default()
    }

    // string username = 1;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Pkcs11GetTpmTokenInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pkcs11GetTpmTokenInfoRequest {
        Pkcs11GetTpmTokenInfoRequest::new()
    }

    fn default_instance() -> &'static Pkcs11GetTpmTokenInfoRequest {
        static instance: ::protobuf::rt::LazyV2<Pkcs11GetTpmTokenInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pkcs11GetTpmTokenInfoRequest::new)
    }
}

impl ::protobuf::Clear for Pkcs11GetTpmTokenInfoRequest {
    fn clear(&mut self) {
        self.username.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Pkcs11GetTpmTokenInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pkcs11GetTpmTokenInfoReply {
    // message fields
    pub token_info: ::protobuf::SingularPtrField<TpmTokenInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pkcs11GetTpmTokenInfoReply {
    fn default() -> &'a Pkcs11GetTpmTokenInfoReply {
        <Pkcs11GetTpmTokenInfoReply as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11GetTpmTokenInfoReply {
    pub fn new() -> Pkcs11GetTpmTokenInfoReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.TpmTokenInfo token_info = 1;


    pub fn get_token_info(&self) -> &TpmTokenInfo {
        self.token_info.as_ref().unwrap_or_else(|| <TpmTokenInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_token_info(&mut self) {
        self.token_info.clear();
    }

    pub fn has_token_info(&self) -> bool {
        self.token_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token_info(&mut self, v: TpmTokenInfo) {
        self.token_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token_info(&mut self) -> &mut TpmTokenInfo {
        if self.token_info.is_none() {
            self.token_info.set_default();
        }
        self.token_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_token_info(&mut self) -> TpmTokenInfo {
        self.token_info.take().unwrap_or_else(|| TpmTokenInfo::new())
    }
}

impl ::protobuf::Message for Pkcs11GetTpmTokenInfoReply {
    fn is_initialized(&self) -> bool {
        for v in &self.token_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.token_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.token_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.token_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pkcs11GetTpmTokenInfoReply {
        Pkcs11GetTpmTokenInfoReply::new()
    }

    fn default_instance() -> &'static Pkcs11GetTpmTokenInfoReply {
        static instance: ::protobuf::rt::LazyV2<Pkcs11GetTpmTokenInfoReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pkcs11GetTpmTokenInfoReply::new)
    }
}

impl ::protobuf::Clear for Pkcs11GetTpmTokenInfoReply {
    fn clear(&mut self) {
        self.token_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Pkcs11GetTpmTokenInfoReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pkcs11TerminateRequest {
    // message fields
    pub username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pkcs11TerminateRequest {
    fn default() -> &'a Pkcs11TerminateRequest {
        <Pkcs11TerminateRequest as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11TerminateRequest {
    pub fn new() -> Pkcs11TerminateRequest {
        ::std::default::Default::default()
    }

    // string username = 1;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Pkcs11TerminateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pkcs11TerminateRequest {
        Pkcs11TerminateRequest::new()
    }

    fn default_instance() -> &'static Pkcs11TerminateRequest {
        static instance: ::protobuf::rt::LazyV2<Pkcs11TerminateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pkcs11TerminateRequest::new)
    }
}

impl ::protobuf::Clear for Pkcs11TerminateRequest {
    fn clear(&mut self) {
        self.username.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Pkcs11TerminateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pkcs11TerminateReply {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pkcs11TerminateReply {
    fn default() -> &'a Pkcs11TerminateReply {
        <Pkcs11TerminateReply as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11TerminateReply {
    pub fn new() -> Pkcs11TerminateReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Pkcs11TerminateReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pkcs11TerminateReply {
        Pkcs11TerminateReply::new()
    }

    fn default_instance() -> &'static Pkcs11TerminateReply {
        static instance: ::protobuf::rt::LazyV2<Pkcs11TerminateReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pkcs11TerminateReply::new)
    }
}

impl ::protobuf::Clear for Pkcs11TerminateReply {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Pkcs11TerminateReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pkcs11RestoreTpmTokensRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pkcs11RestoreTpmTokensRequest {
    fn default() -> &'a Pkcs11RestoreTpmTokensRequest {
        <Pkcs11RestoreTpmTokensRequest as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11RestoreTpmTokensRequest {
    pub fn new() -> Pkcs11RestoreTpmTokensRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Pkcs11RestoreTpmTokensRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pkcs11RestoreTpmTokensRequest {
        Pkcs11RestoreTpmTokensRequest::new()
    }

    fn default_instance() -> &'static Pkcs11RestoreTpmTokensRequest {
        static instance: ::protobuf::rt::LazyV2<Pkcs11RestoreTpmTokensRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pkcs11RestoreTpmTokensRequest::new)
    }
}

impl ::protobuf::Clear for Pkcs11RestoreTpmTokensRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Pkcs11RestoreTpmTokensRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pkcs11RestoreTpmTokensReply {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pkcs11RestoreTpmTokensReply {
    fn default() -> &'a Pkcs11RestoreTpmTokensReply {
        <Pkcs11RestoreTpmTokensReply as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11RestoreTpmTokensReply {
    pub fn new() -> Pkcs11RestoreTpmTokensReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Pkcs11RestoreTpmTokensReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pkcs11RestoreTpmTokensReply {
        Pkcs11RestoreTpmTokensReply::new()
    }

    fn default_instance() -> &'static Pkcs11RestoreTpmTokensReply {
        static instance: ::protobuf::rt::LazyV2<Pkcs11RestoreTpmTokensReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pkcs11RestoreTpmTokensReply::new)
    }
}

impl ::protobuf::Clear for Pkcs11RestoreTpmTokensReply {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Pkcs11RestoreTpmTokensReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct InstallAttributesGetRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstallAttributesGetRequest {
    fn default() -> &'a InstallAttributesGetRequest {
        <InstallAttributesGetRequest as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesGetRequest {
    pub fn new() -> InstallAttributesGetRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for InstallAttributesGetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstallAttributesGetRequest {
        InstallAttributesGetRequest::new()
    }

    fn default_instance() -> &'static InstallAttributesGetRequest {
        static instance: ::protobuf::rt::LazyV2<InstallAttributesGetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstallAttributesGetRequest::new)
    }
}

impl ::protobuf::Clear for InstallAttributesGetRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for InstallAttributesGetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct InstallAttributesGetReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstallAttributesGetReply {
    fn default() -> &'a InstallAttributesGetReply {
        <InstallAttributesGetReply as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesGetReply {
    pub fn new() -> InstallAttributesGetReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for InstallAttributesGetReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstallAttributesGetReply {
        InstallAttributesGetReply::new()
    }

    fn default_instance() -> &'static InstallAttributesGetReply {
        static instance: ::protobuf::rt::LazyV2<InstallAttributesGetReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstallAttributesGetReply::new)
    }
}

impl ::protobuf::Clear for InstallAttributesGetReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for InstallAttributesGetReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct InstallAttributesSetRequest {
    // message fields
    pub name: ::std::string::String,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstallAttributesSetRequest {
    fn default() -> &'a InstallAttributesSetRequest {
        <InstallAttributesSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesSetRequest {
    pub fn new() -> InstallAttributesSetRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bytes value = 2;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for InstallAttributesSetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstallAttributesSetRequest {
        InstallAttributesSetRequest::new()
    }

    fn default_instance() -> &'static InstallAttributesSetRequest {
        static instance: ::protobuf::rt::LazyV2<InstallAttributesSetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstallAttributesSetRequest::new)
    }
}

impl ::protobuf::Clear for InstallAttributesSetRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for InstallAttributesSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct InstallAttributesSetReply {
    // message fields
    pub error: CryptohomeErrorCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstallAttributesSetReply {
    fn default() -> &'a InstallAttributesSetReply {
        <InstallAttributesSetReply as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesSetReply {
    pub fn new() -> InstallAttributesSetReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }
}

impl ::protobuf::Message for InstallAttributesSetReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstallAttributesSetReply {
        InstallAttributesSetReply::new()
    }

    fn default_instance() -> &'static InstallAttributesSetReply {
        static instance: ::protobuf::rt::LazyV2<InstallAttributesSetReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstallAttributesSetReply::new)
    }
}

impl ::protobuf::Clear for InstallAttributesSetReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for InstallAttributesSetReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct InstallAttributesFinalizeRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstallAttributesFinalizeRequest {
    fn default() -> &'a InstallAttributesFinalizeRequest {
        <InstallAttributesFinalizeRequest as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesFinalizeRequest {
    pub fn new() -> InstallAttributesFinalizeRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InstallAttributesFinalizeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstallAttributesFinalizeRequest {
        InstallAttributesFinalizeRequest::new()
    }

    fn default_instance() -> &'static InstallAttributesFinalizeRequest {
        static instance: ::protobuf::rt::LazyV2<InstallAttributesFinalizeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstallAttributesFinalizeRequest::new)
    }
}

impl ::protobuf::Clear for InstallAttributesFinalizeRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for InstallAttributesFinalizeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct InstallAttributesFinalizeReply {
    // message fields
    pub error: CryptohomeErrorCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstallAttributesFinalizeReply {
    fn default() -> &'a InstallAttributesFinalizeReply {
        <InstallAttributesFinalizeReply as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesFinalizeReply {
    pub fn new() -> InstallAttributesFinalizeReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }
}

impl ::protobuf::Message for InstallAttributesFinalizeReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstallAttributesFinalizeReply {
        InstallAttributesFinalizeReply::new()
    }

    fn default_instance() -> &'static InstallAttributesFinalizeReply {
        static instance: ::protobuf::rt::LazyV2<InstallAttributesFinalizeReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstallAttributesFinalizeReply::new)
    }
}

impl ::protobuf::Clear for InstallAttributesFinalizeReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for InstallAttributesFinalizeReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct InstallAttributesGetStatusRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstallAttributesGetStatusRequest {
    fn default() -> &'a InstallAttributesGetStatusRequest {
        <InstallAttributesGetStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesGetStatusRequest {
    pub fn new() -> InstallAttributesGetStatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InstallAttributesGetStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstallAttributesGetStatusRequest {
        InstallAttributesGetStatusRequest::new()
    }

    fn default_instance() -> &'static InstallAttributesGetStatusRequest {
        static instance: ::protobuf::rt::LazyV2<InstallAttributesGetStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstallAttributesGetStatusRequest::new)
    }
}

impl ::protobuf::Clear for InstallAttributesGetStatusRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for InstallAttributesGetStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct InstallAttributesGetStatusReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub count: i32,
    pub is_secure: bool,
    pub state: InstallAttributesState,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstallAttributesGetStatusReply {
    fn default() -> &'a InstallAttributesGetStatusReply {
        <InstallAttributesGetStatusReply as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesGetStatusReply {
    pub fn new() -> InstallAttributesGetStatusReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // int32 count = 2;


    pub fn get_count(&self) -> i32 {
        self.count
    }
    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = v;
    }

    // bool is_secure = 3;


    pub fn get_is_secure(&self) -> bool {
        self.is_secure
    }
    pub fn clear_is_secure(&mut self) {
        self.is_secure = false;
    }

    // Param is passed by value, moved
    pub fn set_is_secure(&mut self, v: bool) {
        self.is_secure = v;
    }

    // .user_data_auth.InstallAttributesState state = 4;


    pub fn get_state(&self) -> InstallAttributesState {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = InstallAttributesState::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: InstallAttributesState) {
        self.state = v;
    }
}

impl ::protobuf::Message for InstallAttributesGetStatusReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_secure = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_secure != false {
            my_size += 2;
        }
        if self.state != InstallAttributesState::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(4, self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if self.count != 0 {
            os.write_int32(2, self.count)?;
        }
        if self.is_secure != false {
            os.write_bool(3, self.is_secure)?;
        }
        if self.state != InstallAttributesState::UNKNOWN {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstallAttributesGetStatusReply {
        InstallAttributesGetStatusReply::new()
    }

    fn default_instance() -> &'static InstallAttributesGetStatusReply {
        static instance: ::protobuf::rt::LazyV2<InstallAttributesGetStatusReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstallAttributesGetStatusReply::new)
    }
}

impl ::protobuf::Clear for InstallAttributesGetStatusReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.count = 0;
        self.is_secure = false;
        self.state = InstallAttributesState::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for InstallAttributesGetStatusReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FirmwareManagementParameters {
    // message fields
    pub flags: u32,
    pub developer_key_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirmwareManagementParameters {
    fn default() -> &'a FirmwareManagementParameters {
        <FirmwareManagementParameters as ::protobuf::Message>::default_instance()
    }
}

impl FirmwareManagementParameters {
    pub fn new() -> FirmwareManagementParameters {
        ::std::default::Default::default()
    }

    // uint32 flags = 1;


    pub fn get_flags(&self) -> u32 {
        self.flags
    }
    pub fn clear_flags(&mut self) {
        self.flags = 0;
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = v;
    }

    // bytes developer_key_hash = 2;


    pub fn get_developer_key_hash(&self) -> &[u8] {
        &self.developer_key_hash
    }
    pub fn clear_developer_key_hash(&mut self) {
        self.developer_key_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_developer_key_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.developer_key_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_developer_key_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.developer_key_hash
    }

    // Take field
    pub fn take_developer_key_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.developer_key_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FirmwareManagementParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flags = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.developer_key_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.flags != 0 {
            my_size += ::protobuf::rt::value_size(1, self.flags, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.developer_key_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.developer_key_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.flags != 0 {
            os.write_uint32(1, self.flags)?;
        }
        if !self.developer_key_hash.is_empty() {
            os.write_bytes(2, &self.developer_key_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirmwareManagementParameters {
        FirmwareManagementParameters::new()
    }

    fn default_instance() -> &'static FirmwareManagementParameters {
        static instance: ::protobuf::rt::LazyV2<FirmwareManagementParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirmwareManagementParameters::new)
    }
}

impl ::protobuf::Clear for FirmwareManagementParameters {
    fn clear(&mut self) {
        self.flags = 0;
        self.developer_key_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FirmwareManagementParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetFirmwareManagementParametersRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFirmwareManagementParametersRequest {
    fn default() -> &'a GetFirmwareManagementParametersRequest {
        <GetFirmwareManagementParametersRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFirmwareManagementParametersRequest {
    pub fn new() -> GetFirmwareManagementParametersRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetFirmwareManagementParametersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFirmwareManagementParametersRequest {
        GetFirmwareManagementParametersRequest::new()
    }

    fn default_instance() -> &'static GetFirmwareManagementParametersRequest {
        static instance: ::protobuf::rt::LazyV2<GetFirmwareManagementParametersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFirmwareManagementParametersRequest::new)
    }
}

impl ::protobuf::Clear for GetFirmwareManagementParametersRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFirmwareManagementParametersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetFirmwareManagementParametersReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub fwmp: ::protobuf::SingularPtrField<FirmwareManagementParameters>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFirmwareManagementParametersReply {
    fn default() -> &'a GetFirmwareManagementParametersReply {
        <GetFirmwareManagementParametersReply as ::protobuf::Message>::default_instance()
    }
}

impl GetFirmwareManagementParametersReply {
    pub fn new() -> GetFirmwareManagementParametersReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.FirmwareManagementParameters fwmp = 2;


    pub fn get_fwmp(&self) -> &FirmwareManagementParameters {
        self.fwmp.as_ref().unwrap_or_else(|| <FirmwareManagementParameters as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fwmp(&mut self) {
        self.fwmp.clear();
    }

    pub fn has_fwmp(&self) -> bool {
        self.fwmp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fwmp(&mut self, v: FirmwareManagementParameters) {
        self.fwmp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fwmp(&mut self) -> &mut FirmwareManagementParameters {
        if self.fwmp.is_none() {
            self.fwmp.set_default();
        }
        self.fwmp.as_mut().unwrap()
    }

    // Take field
    pub fn take_fwmp(&mut self) -> FirmwareManagementParameters {
        self.fwmp.take().unwrap_or_else(|| FirmwareManagementParameters::new())
    }
}

impl ::protobuf::Message for GetFirmwareManagementParametersReply {
    fn is_initialized(&self) -> bool {
        for v in &self.fwmp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fwmp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.fwmp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.fwmp.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFirmwareManagementParametersReply {
        GetFirmwareManagementParametersReply::new()
    }

    fn default_instance() -> &'static GetFirmwareManagementParametersReply {
        static instance: ::protobuf::rt::LazyV2<GetFirmwareManagementParametersReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetFirmwareManagementParametersReply::new)
    }
}

impl ::protobuf::Clear for GetFirmwareManagementParametersReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.fwmp.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFirmwareManagementParametersReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RemoveFirmwareManagementParametersRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveFirmwareManagementParametersRequest {
    fn default() -> &'a RemoveFirmwareManagementParametersRequest {
        <RemoveFirmwareManagementParametersRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveFirmwareManagementParametersRequest {
    pub fn new() -> RemoveFirmwareManagementParametersRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RemoveFirmwareManagementParametersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveFirmwareManagementParametersRequest {
        RemoveFirmwareManagementParametersRequest::new()
    }

    fn default_instance() -> &'static RemoveFirmwareManagementParametersRequest {
        static instance: ::protobuf::rt::LazyV2<RemoveFirmwareManagementParametersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveFirmwareManagementParametersRequest::new)
    }
}

impl ::protobuf::Clear for RemoveFirmwareManagementParametersRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveFirmwareManagementParametersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RemoveFirmwareManagementParametersReply {
    // message fields
    pub error: CryptohomeErrorCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveFirmwareManagementParametersReply {
    fn default() -> &'a RemoveFirmwareManagementParametersReply {
        <RemoveFirmwareManagementParametersReply as ::protobuf::Message>::default_instance()
    }
}

impl RemoveFirmwareManagementParametersReply {
    pub fn new() -> RemoveFirmwareManagementParametersReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }
}

impl ::protobuf::Message for RemoveFirmwareManagementParametersReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveFirmwareManagementParametersReply {
        RemoveFirmwareManagementParametersReply::new()
    }

    fn default_instance() -> &'static RemoveFirmwareManagementParametersReply {
        static instance: ::protobuf::rt::LazyV2<RemoveFirmwareManagementParametersReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveFirmwareManagementParametersReply::new)
    }
}

impl ::protobuf::Clear for RemoveFirmwareManagementParametersReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveFirmwareManagementParametersReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetFirmwareManagementParametersRequest {
    // message fields
    pub fwmp: ::protobuf::SingularPtrField<FirmwareManagementParameters>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetFirmwareManagementParametersRequest {
    fn default() -> &'a SetFirmwareManagementParametersRequest {
        <SetFirmwareManagementParametersRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetFirmwareManagementParametersRequest {
    pub fn new() -> SetFirmwareManagementParametersRequest {
        ::std::default::Default::default()
    }

    // .user_data_auth.FirmwareManagementParameters fwmp = 1;


    pub fn get_fwmp(&self) -> &FirmwareManagementParameters {
        self.fwmp.as_ref().unwrap_or_else(|| <FirmwareManagementParameters as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fwmp(&mut self) {
        self.fwmp.clear();
    }

    pub fn has_fwmp(&self) -> bool {
        self.fwmp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fwmp(&mut self, v: FirmwareManagementParameters) {
        self.fwmp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fwmp(&mut self) -> &mut FirmwareManagementParameters {
        if self.fwmp.is_none() {
            self.fwmp.set_default();
        }
        self.fwmp.as_mut().unwrap()
    }

    // Take field
    pub fn take_fwmp(&mut self) -> FirmwareManagementParameters {
        self.fwmp.take().unwrap_or_else(|| FirmwareManagementParameters::new())
    }
}

impl ::protobuf::Message for SetFirmwareManagementParametersRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.fwmp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fwmp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fwmp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fwmp.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetFirmwareManagementParametersRequest {
        SetFirmwareManagementParametersRequest::new()
    }

    fn default_instance() -> &'static SetFirmwareManagementParametersRequest {
        static instance: ::protobuf::rt::LazyV2<SetFirmwareManagementParametersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetFirmwareManagementParametersRequest::new)
    }
}

impl ::protobuf::Clear for SetFirmwareManagementParametersRequest {
    fn clear(&mut self) {
        self.fwmp.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SetFirmwareManagementParametersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetFirmwareManagementParametersReply {
    // message fields
    pub error: CryptohomeErrorCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetFirmwareManagementParametersReply {
    fn default() -> &'a SetFirmwareManagementParametersReply {
        <SetFirmwareManagementParametersReply as ::protobuf::Message>::default_instance()
    }
}

impl SetFirmwareManagementParametersReply {
    pub fn new() -> SetFirmwareManagementParametersReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }
}

impl ::protobuf::Message for SetFirmwareManagementParametersReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetFirmwareManagementParametersReply {
        SetFirmwareManagementParametersReply::new()
    }

    fn default_instance() -> &'static SetFirmwareManagementParametersReply {
        static instance: ::protobuf::rt::LazyV2<SetFirmwareManagementParametersReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetFirmwareManagementParametersReply::new)
    }
}

impl ::protobuf::Clear for SetFirmwareManagementParametersReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for SetFirmwareManagementParametersReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSystemSaltRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSystemSaltRequest {
    fn default() -> &'a GetSystemSaltRequest {
        <GetSystemSaltRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSystemSaltRequest {
    pub fn new() -> GetSystemSaltRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSystemSaltRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSystemSaltRequest {
        GetSystemSaltRequest::new()
    }

    fn default_instance() -> &'static GetSystemSaltRequest {
        static instance: ::protobuf::rt::LazyV2<GetSystemSaltRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSystemSaltRequest::new)
    }
}

impl ::protobuf::Clear for GetSystemSaltRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSystemSaltRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSystemSaltReply {
    // message fields
    pub salt: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSystemSaltReply {
    fn default() -> &'a GetSystemSaltReply {
        <GetSystemSaltReply as ::protobuf::Message>::default_instance()
    }
}

impl GetSystemSaltReply {
    pub fn new() -> GetSystemSaltReply {
        ::std::default::Default::default()
    }

    // bytes salt = 1;


    pub fn get_salt(&self) -> &[u8] {
        &self.salt
    }
    pub fn clear_salt(&mut self) {
        self.salt.clear();
    }

    // Param is passed by value, moved
    pub fn set_salt(&mut self, v: ::std::vec::Vec<u8>) {
        self.salt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_salt(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.salt
    }

    // Take field
    pub fn take_salt(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.salt, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetSystemSaltReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.salt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.salt.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.salt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.salt.is_empty() {
            os.write_bytes(1, &self.salt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSystemSaltReply {
        GetSystemSaltReply::new()
    }

    fn default_instance() -> &'static GetSystemSaltReply {
        static instance: ::protobuf::rt::LazyV2<GetSystemSaltReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSystemSaltReply::new)
    }
}

impl ::protobuf::Clear for GetSystemSaltReply {
    fn clear(&mut self) {
        self.salt.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSystemSaltReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateCurrentUserActivityTimestampRequest {
    // message fields
    pub time_shift_sec: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateCurrentUserActivityTimestampRequest {
    fn default() -> &'a UpdateCurrentUserActivityTimestampRequest {
        <UpdateCurrentUserActivityTimestampRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateCurrentUserActivityTimestampRequest {
    pub fn new() -> UpdateCurrentUserActivityTimestampRequest {
        ::std::default::Default::default()
    }

    // int32 time_shift_sec = 1;


    pub fn get_time_shift_sec(&self) -> i32 {
        self.time_shift_sec
    }
    pub fn clear_time_shift_sec(&mut self) {
        self.time_shift_sec = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_shift_sec(&mut self, v: i32) {
        self.time_shift_sec = v;
    }
}

impl ::protobuf::Message for UpdateCurrentUserActivityTimestampRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.time_shift_sec = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time_shift_sec != 0 {
            my_size += ::protobuf::rt::value_size(1, self.time_shift_sec, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.time_shift_sec != 0 {
            os.write_int32(1, self.time_shift_sec)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateCurrentUserActivityTimestampRequest {
        UpdateCurrentUserActivityTimestampRequest::new()
    }

    fn default_instance() -> &'static UpdateCurrentUserActivityTimestampRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateCurrentUserActivityTimestampRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateCurrentUserActivityTimestampRequest::new)
    }
}

impl ::protobuf::Clear for UpdateCurrentUserActivityTimestampRequest {
    fn clear(&mut self) {
        self.time_shift_sec = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateCurrentUserActivityTimestampRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateCurrentUserActivityTimestampReply {
    // message fields
    pub error: CryptohomeErrorCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateCurrentUserActivityTimestampReply {
    fn default() -> &'a UpdateCurrentUserActivityTimestampReply {
        <UpdateCurrentUserActivityTimestampReply as ::protobuf::Message>::default_instance()
    }
}

impl UpdateCurrentUserActivityTimestampReply {
    pub fn new() -> UpdateCurrentUserActivityTimestampReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }
}

impl ::protobuf::Message for UpdateCurrentUserActivityTimestampReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateCurrentUserActivityTimestampReply {
        UpdateCurrentUserActivityTimestampReply::new()
    }

    fn default_instance() -> &'static UpdateCurrentUserActivityTimestampReply {
        static instance: ::protobuf::rt::LazyV2<UpdateCurrentUserActivityTimestampReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateCurrentUserActivityTimestampReply::new)
    }
}

impl ::protobuf::Clear for UpdateCurrentUserActivityTimestampReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateCurrentUserActivityTimestampReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSanitizedUsernameRequest {
    // message fields
    pub username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSanitizedUsernameRequest {
    fn default() -> &'a GetSanitizedUsernameRequest {
        <GetSanitizedUsernameRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSanitizedUsernameRequest {
    pub fn new() -> GetSanitizedUsernameRequest {
        ::std::default::Default::default()
    }

    // string username = 1;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetSanitizedUsernameRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSanitizedUsernameRequest {
        GetSanitizedUsernameRequest::new()
    }

    fn default_instance() -> &'static GetSanitizedUsernameRequest {
        static instance: ::protobuf::rt::LazyV2<GetSanitizedUsernameRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSanitizedUsernameRequest::new)
    }
}

impl ::protobuf::Clear for GetSanitizedUsernameRequest {
    fn clear(&mut self) {
        self.username.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSanitizedUsernameRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetSanitizedUsernameReply {
    // message fields
    pub sanitized_username: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetSanitizedUsernameReply {
    fn default() -> &'a GetSanitizedUsernameReply {
        <GetSanitizedUsernameReply as ::protobuf::Message>::default_instance()
    }
}

impl GetSanitizedUsernameReply {
    pub fn new() -> GetSanitizedUsernameReply {
        ::std::default::Default::default()
    }

    // string sanitized_username = 1;


    pub fn get_sanitized_username(&self) -> &str {
        &self.sanitized_username
    }
    pub fn clear_sanitized_username(&mut self) {
        self.sanitized_username.clear();
    }

    // Param is passed by value, moved
    pub fn set_sanitized_username(&mut self, v: ::std::string::String) {
        self.sanitized_username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sanitized_username(&mut self) -> &mut ::std::string::String {
        &mut self.sanitized_username
    }

    // Take field
    pub fn take_sanitized_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sanitized_username, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetSanitizedUsernameReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sanitized_username)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sanitized_username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sanitized_username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sanitized_username.is_empty() {
            os.write_string(1, &self.sanitized_username)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSanitizedUsernameReply {
        GetSanitizedUsernameReply::new()
    }

    fn default_instance() -> &'static GetSanitizedUsernameReply {
        static instance: ::protobuf::rt::LazyV2<GetSanitizedUsernameReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetSanitizedUsernameReply::new)
    }
}

impl ::protobuf::Clear for GetSanitizedUsernameReply {
    fn clear(&mut self) {
        self.sanitized_username.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSanitizedUsernameReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetLoginStatusRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLoginStatusRequest {
    fn default() -> &'a GetLoginStatusRequest {
        <GetLoginStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLoginStatusRequest {
    pub fn new() -> GetLoginStatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetLoginStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLoginStatusRequest {
        GetLoginStatusRequest::new()
    }

    fn default_instance() -> &'static GetLoginStatusRequest {
        static instance: ::protobuf::rt::LazyV2<GetLoginStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLoginStatusRequest::new)
    }
}

impl ::protobuf::Clear for GetLoginStatusRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLoginStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetLoginStatusReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub owner_user_exists: bool,
    pub is_locked_to_single_user: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetLoginStatusReply {
    fn default() -> &'a GetLoginStatusReply {
        <GetLoginStatusReply as ::protobuf::Message>::default_instance()
    }
}

impl GetLoginStatusReply {
    pub fn new() -> GetLoginStatusReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // bool owner_user_exists = 2;


    pub fn get_owner_user_exists(&self) -> bool {
        self.owner_user_exists
    }
    pub fn clear_owner_user_exists(&mut self) {
        self.owner_user_exists = false;
    }

    // Param is passed by value, moved
    pub fn set_owner_user_exists(&mut self, v: bool) {
        self.owner_user_exists = v;
    }

    // bool is_locked_to_single_user = 3;


    pub fn get_is_locked_to_single_user(&self) -> bool {
        self.is_locked_to_single_user
    }
    pub fn clear_is_locked_to_single_user(&mut self) {
        self.is_locked_to_single_user = false;
    }

    // Param is passed by value, moved
    pub fn set_is_locked_to_single_user(&mut self, v: bool) {
        self.is_locked_to_single_user = v;
    }
}

impl ::protobuf::Message for GetLoginStatusReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.owner_user_exists = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_locked_to_single_user = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if self.owner_user_exists != false {
            my_size += 2;
        }
        if self.is_locked_to_single_user != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if self.owner_user_exists != false {
            os.write_bool(2, self.owner_user_exists)?;
        }
        if self.is_locked_to_single_user != false {
            os.write_bool(3, self.is_locked_to_single_user)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetLoginStatusReply {
        GetLoginStatusReply::new()
    }

    fn default_instance() -> &'static GetLoginStatusReply {
        static instance: ::protobuf::rt::LazyV2<GetLoginStatusReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetLoginStatusReply::new)
    }
}

impl ::protobuf::Clear for GetLoginStatusReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.owner_user_exists = false;
        self.is_locked_to_single_user = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetLoginStatusReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetStatusStringRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStatusStringRequest {
    fn default() -> &'a GetStatusStringRequest {
        <GetStatusStringRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetStatusStringRequest {
    pub fn new() -> GetStatusStringRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetStatusStringRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStatusStringRequest {
        GetStatusStringRequest::new()
    }

    fn default_instance() -> &'static GetStatusStringRequest {
        static instance: ::protobuf::rt::LazyV2<GetStatusStringRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetStatusStringRequest::new)
    }
}

impl ::protobuf::Clear for GetStatusStringRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStatusStringRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetStatusStringReply {
    // message fields
    pub status: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStatusStringReply {
    fn default() -> &'a GetStatusStringReply {
        <GetStatusStringReply as ::protobuf::Message>::default_instance()
    }
}

impl GetStatusStringReply {
    pub fn new() -> GetStatusStringReply {
        ::std::default::Default::default()
    }

    // string status = 1;


    pub fn get_status(&self) -> &str {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetStatusStringReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.status.is_empty() {
            os.write_string(1, &self.status)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStatusStringReply {
        GetStatusStringReply::new()
    }

    fn default_instance() -> &'static GetStatusStringReply {
        static instance: ::protobuf::rt::LazyV2<GetStatusStringReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetStatusStringReply::new)
    }
}

impl ::protobuf::Clear for GetStatusStringReply {
    fn clear(&mut self) {
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStatusStringReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct LockToSingleUserMountUntilRebootRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LockToSingleUserMountUntilRebootRequest {
    fn default() -> &'a LockToSingleUserMountUntilRebootRequest {
        <LockToSingleUserMountUntilRebootRequest as ::protobuf::Message>::default_instance()
    }
}

impl LockToSingleUserMountUntilRebootRequest {
    pub fn new() -> LockToSingleUserMountUntilRebootRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }
}

impl ::protobuf::Message for LockToSingleUserMountUntilRebootRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LockToSingleUserMountUntilRebootRequest {
        LockToSingleUserMountUntilRebootRequest::new()
    }

    fn default_instance() -> &'static LockToSingleUserMountUntilRebootRequest {
        static instance: ::protobuf::rt::LazyV2<LockToSingleUserMountUntilRebootRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LockToSingleUserMountUntilRebootRequest::new)
    }
}

impl ::protobuf::Clear for LockToSingleUserMountUntilRebootRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for LockToSingleUserMountUntilRebootRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct LockToSingleUserMountUntilRebootReply {
    // message fields
    pub error: CryptohomeErrorCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LockToSingleUserMountUntilRebootReply {
    fn default() -> &'a LockToSingleUserMountUntilRebootReply {
        <LockToSingleUserMountUntilRebootReply as ::protobuf::Message>::default_instance()
    }
}

impl LockToSingleUserMountUntilRebootReply {
    pub fn new() -> LockToSingleUserMountUntilRebootReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }
}

impl ::protobuf::Message for LockToSingleUserMountUntilRebootReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LockToSingleUserMountUntilRebootReply {
        LockToSingleUserMountUntilRebootReply::new()
    }

    fn default_instance() -> &'static LockToSingleUserMountUntilRebootReply {
        static instance: ::protobuf::rt::LazyV2<LockToSingleUserMountUntilRebootReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LockToSingleUserMountUntilRebootReply::new)
    }
}

impl ::protobuf::Clear for LockToSingleUserMountUntilRebootReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for LockToSingleUserMountUntilRebootReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetRsuDeviceIdReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub rsu_device_id: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetRsuDeviceIdReply {
    fn default() -> &'a GetRsuDeviceIdReply {
        <GetRsuDeviceIdReply as ::protobuf::Message>::default_instance()
    }
}

impl GetRsuDeviceIdReply {
    pub fn new() -> GetRsuDeviceIdReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // bytes rsu_device_id = 2;


    pub fn get_rsu_device_id(&self) -> &[u8] {
        &self.rsu_device_id
    }
    pub fn clear_rsu_device_id(&mut self) {
        self.rsu_device_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_rsu_device_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.rsu_device_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rsu_device_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.rsu_device_id
    }

    // Take field
    pub fn take_rsu_device_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.rsu_device_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetRsuDeviceIdReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.rsu_device_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if !self.rsu_device_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.rsu_device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if !self.rsu_device_id.is_empty() {
            os.write_bytes(2, &self.rsu_device_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRsuDeviceIdReply {
        GetRsuDeviceIdReply::new()
    }

    fn default_instance() -> &'static GetRsuDeviceIdReply {
        static instance: ::protobuf::rt::LazyV2<GetRsuDeviceIdReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetRsuDeviceIdReply::new)
    }
}

impl ::protobuf::Clear for GetRsuDeviceIdReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.rsu_device_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRsuDeviceIdReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetRsuDeviceIdRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetRsuDeviceIdRequest {
    fn default() -> &'a GetRsuDeviceIdRequest {
        <GetRsuDeviceIdRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetRsuDeviceIdRequest {
    pub fn new() -> GetRsuDeviceIdRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetRsuDeviceIdRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRsuDeviceIdRequest {
        GetRsuDeviceIdRequest::new()
    }

    fn default_instance() -> &'static GetRsuDeviceIdRequest {
        static instance: ::protobuf::rt::LazyV2<GetRsuDeviceIdRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetRsuDeviceIdRequest::new)
    }
}

impl ::protobuf::Clear for GetRsuDeviceIdRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRsuDeviceIdRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CheckHealthRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckHealthRequest {
    fn default() -> &'a CheckHealthRequest {
        <CheckHealthRequest as ::protobuf::Message>::default_instance()
    }
}

impl CheckHealthRequest {
    pub fn new() -> CheckHealthRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CheckHealthRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckHealthRequest {
        CheckHealthRequest::new()
    }

    fn default_instance() -> &'static CheckHealthRequest {
        static instance: ::protobuf::rt::LazyV2<CheckHealthRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckHealthRequest::new)
    }
}

impl ::protobuf::Clear for CheckHealthRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckHealthRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct CheckHealthReply {
    // message fields
    pub requires_powerwash: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckHealthReply {
    fn default() -> &'a CheckHealthReply {
        <CheckHealthReply as ::protobuf::Message>::default_instance()
    }
}

impl CheckHealthReply {
    pub fn new() -> CheckHealthReply {
        ::std::default::Default::default()
    }

    // bool requires_powerwash = 2;


    pub fn get_requires_powerwash(&self) -> bool {
        self.requires_powerwash
    }
    pub fn clear_requires_powerwash(&mut self) {
        self.requires_powerwash = false;
    }

    // Param is passed by value, moved
    pub fn set_requires_powerwash(&mut self, v: bool) {
        self.requires_powerwash = v;
    }
}

impl ::protobuf::Message for CheckHealthReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.requires_powerwash = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.requires_powerwash != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.requires_powerwash != false {
            os.write_bool(2, self.requires_powerwash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckHealthReply {
        CheckHealthReply::new()
    }

    fn default_instance() -> &'static CheckHealthReply {
        static instance: ::protobuf::rt::LazyV2<CheckHealthReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckHealthReply::new)
    }
}

impl ::protobuf::Clear for CheckHealthReply {
    fn clear(&mut self) {
        self.requires_powerwash = false;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckHealthReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResetApplicationContainerRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    pub application_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResetApplicationContainerRequest {
    fn default() -> &'a ResetApplicationContainerRequest {
        <ResetApplicationContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResetApplicationContainerRequest {
    pub fn new() -> ResetApplicationContainerRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }

    // string application_name = 2;


    pub fn get_application_name(&self) -> &str {
        &self.application_name
    }
    pub fn clear_application_name(&mut self) {
        self.application_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_application_name(&mut self, v: ::std::string::String) {
        self.application_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_application_name(&mut self) -> &mut ::std::string::String {
        &mut self.application_name
    }

    // Take field
    pub fn take_application_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.application_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ResetApplicationContainerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.application_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.application_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.application_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.application_name.is_empty() {
            os.write_string(2, &self.application_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResetApplicationContainerRequest {
        ResetApplicationContainerRequest::new()
    }

    fn default_instance() -> &'static ResetApplicationContainerRequest {
        static instance: ::protobuf::rt::LazyV2<ResetApplicationContainerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResetApplicationContainerRequest::new)
    }
}

impl ::protobuf::Clear for ResetApplicationContainerRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.application_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetApplicationContainerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResetApplicationContainerReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResetApplicationContainerReply {
    fn default() -> &'a ResetApplicationContainerReply {
        <ResetApplicationContainerReply as ::protobuf::Message>::default_instance()
    }
}

impl ResetApplicationContainerReply {
    pub fn new() -> ResetApplicationContainerReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 2;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for ResetApplicationContainerReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResetApplicationContainerReply {
        ResetApplicationContainerReply::new()
    }

    fn default_instance() -> &'static ResetApplicationContainerReply {
        static instance: ::protobuf::rt::LazyV2<ResetApplicationContainerReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResetApplicationContainerReply::new)
    }
}

impl ::protobuf::Clear for ResetApplicationContainerReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetApplicationContainerReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FidoMakeCredentialRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    pub make_credential_options: ::protobuf::SingularPtrField<super::fido::PublicKeyCredentialCreationOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FidoMakeCredentialRequest {
    fn default() -> &'a FidoMakeCredentialRequest {
        <FidoMakeCredentialRequest as ::protobuf::Message>::default_instance()
    }
}

impl FidoMakeCredentialRequest {
    pub fn new() -> FidoMakeCredentialRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }

    // .cryptohome.fido.PublicKeyCredentialCreationOptions make_credential_options = 2;


    pub fn get_make_credential_options(&self) -> &super::fido::PublicKeyCredentialCreationOptions {
        self.make_credential_options.as_ref().unwrap_or_else(|| <super::fido::PublicKeyCredentialCreationOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_make_credential_options(&mut self) {
        self.make_credential_options.clear();
    }

    pub fn has_make_credential_options(&self) -> bool {
        self.make_credential_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_make_credential_options(&mut self, v: super::fido::PublicKeyCredentialCreationOptions) {
        self.make_credential_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_make_credential_options(&mut self) -> &mut super::fido::PublicKeyCredentialCreationOptions {
        if self.make_credential_options.is_none() {
            self.make_credential_options.set_default();
        }
        self.make_credential_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_make_credential_options(&mut self) -> super::fido::PublicKeyCredentialCreationOptions {
        self.make_credential_options.take().unwrap_or_else(|| super::fido::PublicKeyCredentialCreationOptions::new())
    }
}

impl ::protobuf::Message for FidoMakeCredentialRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.make_credential_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.make_credential_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.make_credential_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.make_credential_options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FidoMakeCredentialRequest {
        FidoMakeCredentialRequest::new()
    }

    fn default_instance() -> &'static FidoMakeCredentialRequest {
        static instance: ::protobuf::rt::LazyV2<FidoMakeCredentialRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FidoMakeCredentialRequest::new)
    }
}

impl ::protobuf::Clear for FidoMakeCredentialRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.make_credential_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FidoMakeCredentialRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FidoMakeCredentialReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub make_credential_response: ::protobuf::SingularPtrField<super::fido::MakeCredentialAuthenticatorResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FidoMakeCredentialReply {
    fn default() -> &'a FidoMakeCredentialReply {
        <FidoMakeCredentialReply as ::protobuf::Message>::default_instance()
    }
}

impl FidoMakeCredentialReply {
    pub fn new() -> FidoMakeCredentialReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .cryptohome.fido.MakeCredentialAuthenticatorResponse make_credential_response = 2;


    pub fn get_make_credential_response(&self) -> &super::fido::MakeCredentialAuthenticatorResponse {
        self.make_credential_response.as_ref().unwrap_or_else(|| <super::fido::MakeCredentialAuthenticatorResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_make_credential_response(&mut self) {
        self.make_credential_response.clear();
    }

    pub fn has_make_credential_response(&self) -> bool {
        self.make_credential_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_make_credential_response(&mut self, v: super::fido::MakeCredentialAuthenticatorResponse) {
        self.make_credential_response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_make_credential_response(&mut self) -> &mut super::fido::MakeCredentialAuthenticatorResponse {
        if self.make_credential_response.is_none() {
            self.make_credential_response.set_default();
        }
        self.make_credential_response.as_mut().unwrap()
    }

    // Take field
    pub fn take_make_credential_response(&mut self) -> super::fido::MakeCredentialAuthenticatorResponse {
        self.make_credential_response.take().unwrap_or_else(|| super::fido::MakeCredentialAuthenticatorResponse::new())
    }
}

impl ::protobuf::Message for FidoMakeCredentialReply {
    fn is_initialized(&self) -> bool {
        for v in &self.make_credential_response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.make_credential_response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.make_credential_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.make_credential_response.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FidoMakeCredentialReply {
        FidoMakeCredentialReply::new()
    }

    fn default_instance() -> &'static FidoMakeCredentialReply {
        static instance: ::protobuf::rt::LazyV2<FidoMakeCredentialReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FidoMakeCredentialReply::new)
    }
}

impl ::protobuf::Clear for FidoMakeCredentialReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.make_credential_response.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FidoMakeCredentialReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FidoGetAssertionRequest {
    // message fields
    pub get_assertion_options: ::protobuf::SingularPtrField<super::fido::PublicKeyCredentialRequestOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FidoGetAssertionRequest {
    fn default() -> &'a FidoGetAssertionRequest {
        <FidoGetAssertionRequest as ::protobuf::Message>::default_instance()
    }
}

impl FidoGetAssertionRequest {
    pub fn new() -> FidoGetAssertionRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.fido.PublicKeyCredentialRequestOptions get_assertion_options = 1;


    pub fn get_get_assertion_options(&self) -> &super::fido::PublicKeyCredentialRequestOptions {
        self.get_assertion_options.as_ref().unwrap_or_else(|| <super::fido::PublicKeyCredentialRequestOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_get_assertion_options(&mut self) {
        self.get_assertion_options.clear();
    }

    pub fn has_get_assertion_options(&self) -> bool {
        self.get_assertion_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_get_assertion_options(&mut self, v: super::fido::PublicKeyCredentialRequestOptions) {
        self.get_assertion_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_get_assertion_options(&mut self) -> &mut super::fido::PublicKeyCredentialRequestOptions {
        if self.get_assertion_options.is_none() {
            self.get_assertion_options.set_default();
        }
        self.get_assertion_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_get_assertion_options(&mut self) -> super::fido::PublicKeyCredentialRequestOptions {
        self.get_assertion_options.take().unwrap_or_else(|| super::fido::PublicKeyCredentialRequestOptions::new())
    }
}

impl ::protobuf::Message for FidoGetAssertionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.get_assertion_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.get_assertion_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.get_assertion_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.get_assertion_options.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FidoGetAssertionRequest {
        FidoGetAssertionRequest::new()
    }

    fn default_instance() -> &'static FidoGetAssertionRequest {
        static instance: ::protobuf::rt::LazyV2<FidoGetAssertionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FidoGetAssertionRequest::new)
    }
}

impl ::protobuf::Clear for FidoGetAssertionRequest {
    fn clear(&mut self) {
        self.get_assertion_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FidoGetAssertionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FidoGetAssertionReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub get_assertion_response: ::protobuf::SingularPtrField<super::fido::GetAssertionAuthenticatorResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FidoGetAssertionReply {
    fn default() -> &'a FidoGetAssertionReply {
        <FidoGetAssertionReply as ::protobuf::Message>::default_instance()
    }
}

impl FidoGetAssertionReply {
    pub fn new() -> FidoGetAssertionReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .cryptohome.fido.GetAssertionAuthenticatorResponse get_assertion_response = 2;


    pub fn get_get_assertion_response(&self) -> &super::fido::GetAssertionAuthenticatorResponse {
        self.get_assertion_response.as_ref().unwrap_or_else(|| <super::fido::GetAssertionAuthenticatorResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_get_assertion_response(&mut self) {
        self.get_assertion_response.clear();
    }

    pub fn has_get_assertion_response(&self) -> bool {
        self.get_assertion_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_get_assertion_response(&mut self, v: super::fido::GetAssertionAuthenticatorResponse) {
        self.get_assertion_response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_get_assertion_response(&mut self) -> &mut super::fido::GetAssertionAuthenticatorResponse {
        if self.get_assertion_response.is_none() {
            self.get_assertion_response.set_default();
        }
        self.get_assertion_response.as_mut().unwrap()
    }

    // Take field
    pub fn take_get_assertion_response(&mut self) -> super::fido::GetAssertionAuthenticatorResponse {
        self.get_assertion_response.take().unwrap_or_else(|| super::fido::GetAssertionAuthenticatorResponse::new())
    }
}

impl ::protobuf::Message for FidoGetAssertionReply {
    fn is_initialized(&self) -> bool {
        for v in &self.get_assertion_response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.get_assertion_response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.get_assertion_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.get_assertion_response.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FidoGetAssertionReply {
        FidoGetAssertionReply::new()
    }

    fn default_instance() -> &'static FidoGetAssertionReply {
        static instance: ::protobuf::rt::LazyV2<FidoGetAssertionReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FidoGetAssertionReply::new)
    }
}

impl ::protobuf::Clear for FidoGetAssertionReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.get_assertion_response.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FidoGetAssertionReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddAuthFactorRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    pub auth_factor: ::protobuf::SingularPtrField<super::auth_factor::AuthFactor>,
    pub auth_input: ::protobuf::SingularPtrField<super::auth_factor::AuthInput>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddAuthFactorRequest {
    fn default() -> &'a AddAuthFactorRequest {
        <AddAuthFactorRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddAuthFactorRequest {
    pub fn new() -> AddAuthFactorRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }

    // .user_data_auth.AuthFactor auth_factor = 2;


    pub fn get_auth_factor(&self) -> &super::auth_factor::AuthFactor {
        self.auth_factor.as_ref().unwrap_or_else(|| <super::auth_factor::AuthFactor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_auth_factor(&mut self) {
        self.auth_factor.clear();
    }

    pub fn has_auth_factor(&self) -> bool {
        self.auth_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_factor(&mut self, v: super::auth_factor::AuthFactor) {
        self.auth_factor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_factor(&mut self) -> &mut super::auth_factor::AuthFactor {
        if self.auth_factor.is_none() {
            self.auth_factor.set_default();
        }
        self.auth_factor.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_factor(&mut self) -> super::auth_factor::AuthFactor {
        self.auth_factor.take().unwrap_or_else(|| super::auth_factor::AuthFactor::new())
    }

    // .user_data_auth.AuthInput auth_input = 3;


    pub fn get_auth_input(&self) -> &super::auth_factor::AuthInput {
        self.auth_input.as_ref().unwrap_or_else(|| <super::auth_factor::AuthInput as ::protobuf::Message>::default_instance())
    }
    pub fn clear_auth_input(&mut self) {
        self.auth_input.clear();
    }

    pub fn has_auth_input(&self) -> bool {
        self.auth_input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_input(&mut self, v: super::auth_factor::AuthInput) {
        self.auth_input = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_input(&mut self) -> &mut super::auth_factor::AuthInput {
        if self.auth_input.is_none() {
            self.auth_input.set_default();
        }
        self.auth_input.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_input(&mut self) -> super::auth_factor::AuthInput {
        self.auth_input.take().unwrap_or_else(|| super::auth_factor::AuthInput::new())
    }
}

impl ::protobuf::Message for AddAuthFactorRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.auth_factor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.auth_input {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.auth_factor)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.auth_input)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if let Some(ref v) = self.auth_factor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.auth_input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if let Some(ref v) = self.auth_factor.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.auth_input.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddAuthFactorRequest {
        AddAuthFactorRequest::new()
    }

    fn default_instance() -> &'static AddAuthFactorRequest {
        static instance: ::protobuf::rt::LazyV2<AddAuthFactorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddAuthFactorRequest::new)
    }
}

impl ::protobuf::Clear for AddAuthFactorRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.auth_factor.clear();
        self.auth_input.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AddAuthFactorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddAuthFactorReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddAuthFactorReply {
    fn default() -> &'a AddAuthFactorReply {
        <AddAuthFactorReply as ::protobuf::Message>::default_instance()
    }
}

impl AddAuthFactorReply {
    pub fn new() -> AddAuthFactorReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 2;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for AddAuthFactorReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddAuthFactorReply {
        AddAuthFactorReply::new()
    }

    fn default_instance() -> &'static AddAuthFactorReply {
        static instance: ::protobuf::rt::LazyV2<AddAuthFactorReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddAuthFactorReply::new)
    }
}

impl ::protobuf::Clear for AddAuthFactorReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AddAuthFactorReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AuthenticateAuthFactorRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    pub auth_factor_label: ::std::string::String,
    pub auth_input: ::protobuf::SingularPtrField<super::auth_factor::AuthInput>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthenticateAuthFactorRequest {
    fn default() -> &'a AuthenticateAuthFactorRequest {
        <AuthenticateAuthFactorRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticateAuthFactorRequest {
    pub fn new() -> AuthenticateAuthFactorRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }

    // string auth_factor_label = 2;


    pub fn get_auth_factor_label(&self) -> &str {
        &self.auth_factor_label
    }
    pub fn clear_auth_factor_label(&mut self) {
        self.auth_factor_label.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_factor_label(&mut self, v: ::std::string::String) {
        self.auth_factor_label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_factor_label(&mut self) -> &mut ::std::string::String {
        &mut self.auth_factor_label
    }

    // Take field
    pub fn take_auth_factor_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.auth_factor_label, ::std::string::String::new())
    }

    // .user_data_auth.AuthInput auth_input = 3;


    pub fn get_auth_input(&self) -> &super::auth_factor::AuthInput {
        self.auth_input.as_ref().unwrap_or_else(|| <super::auth_factor::AuthInput as ::protobuf::Message>::default_instance())
    }
    pub fn clear_auth_input(&mut self) {
        self.auth_input.clear();
    }

    pub fn has_auth_input(&self) -> bool {
        self.auth_input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_input(&mut self, v: super::auth_factor::AuthInput) {
        self.auth_input = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_input(&mut self) -> &mut super::auth_factor::AuthInput {
        if self.auth_input.is_none() {
            self.auth_input.set_default();
        }
        self.auth_input.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_input(&mut self) -> super::auth_factor::AuthInput {
        self.auth_input.take().unwrap_or_else(|| super::auth_factor::AuthInput::new())
    }
}

impl ::protobuf::Message for AuthenticateAuthFactorRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.auth_input {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.auth_factor_label)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.auth_input)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if !self.auth_factor_label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.auth_factor_label);
        }
        if let Some(ref v) = self.auth_input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if !self.auth_factor_label.is_empty() {
            os.write_string(2, &self.auth_factor_label)?;
        }
        if let Some(ref v) = self.auth_input.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticateAuthFactorRequest {
        AuthenticateAuthFactorRequest::new()
    }

    fn default_instance() -> &'static AuthenticateAuthFactorRequest {
        static instance: ::protobuf::rt::LazyV2<AuthenticateAuthFactorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthenticateAuthFactorRequest::new)
    }
}

impl ::protobuf::Clear for AuthenticateAuthFactorRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.auth_factor_label.clear();
        self.auth_input.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateAuthFactorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AuthenticateAuthFactorReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    pub authenticated: bool,
    pub authorized_for: ::std::vec::Vec<super::auth_factor::AuthIntent>,
    // message oneof groups
    pub _seconds_left: ::std::option::Option<AuthenticateAuthFactorReply_oneof__seconds_left>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthenticateAuthFactorReply {
    fn default() -> &'a AuthenticateAuthFactorReply {
        <AuthenticateAuthFactorReply as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AuthenticateAuthFactorReply_oneof__seconds_left {
    seconds_left(u32),
}

impl AuthenticateAuthFactorReply {
    pub fn new() -> AuthenticateAuthFactorReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 2;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }

    // bool authenticated = 3;


    pub fn get_authenticated(&self) -> bool {
        self.authenticated
    }
    pub fn clear_authenticated(&mut self) {
        self.authenticated = false;
    }

    // Param is passed by value, moved
    pub fn set_authenticated(&mut self, v: bool) {
        self.authenticated = v;
    }

    // repeated .user_data_auth.AuthIntent authorized_for = 4;


    pub fn get_authorized_for(&self) -> &[super::auth_factor::AuthIntent] {
        &self.authorized_for
    }
    pub fn clear_authorized_for(&mut self) {
        self.authorized_for.clear();
    }

    // Param is passed by value, moved
    pub fn set_authorized_for(&mut self, v: ::std::vec::Vec<super::auth_factor::AuthIntent>) {
        self.authorized_for = v;
    }

    // Mutable pointer to the field.
    pub fn mut_authorized_for(&mut self) -> &mut ::std::vec::Vec<super::auth_factor::AuthIntent> {
        &mut self.authorized_for
    }

    // Take field
    pub fn take_authorized_for(&mut self) -> ::std::vec::Vec<super::auth_factor::AuthIntent> {
        ::std::mem::replace(&mut self.authorized_for, ::std::vec::Vec::new())
    }

    // uint32 seconds_left = 5;


    pub fn get_seconds_left(&self) -> u32 {
        match self._seconds_left {
            ::std::option::Option::Some(AuthenticateAuthFactorReply_oneof__seconds_left::seconds_left(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_seconds_left(&mut self) {
        self._seconds_left = ::std::option::Option::None;
    }

    pub fn has_seconds_left(&self) -> bool {
        match self._seconds_left {
            ::std::option::Option::Some(AuthenticateAuthFactorReply_oneof__seconds_left::seconds_left(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_seconds_left(&mut self, v: u32) {
        self._seconds_left = ::std::option::Option::Some(AuthenticateAuthFactorReply_oneof__seconds_left::seconds_left(v))
    }
}

impl ::protobuf::Message for AuthenticateAuthFactorReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.authenticated = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.authorized_for, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self._seconds_left = ::std::option::Option::Some(AuthenticateAuthFactorReply_oneof__seconds_left::seconds_left(is.read_uint32()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.authenticated != false {
            my_size += 2;
        }
        for value in &self.authorized_for {
            my_size += ::protobuf::rt::enum_size(4, *value);
        };
        if let ::std::option::Option::Some(ref v) = self._seconds_left {
            match v {
                &AuthenticateAuthFactorReply_oneof__seconds_left::seconds_left(v) => {
                    my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.authenticated != false {
            os.write_bool(3, self.authenticated)?;
        }
        for v in &self.authorized_for {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let ::std::option::Option::Some(ref v) = self._seconds_left {
            match v {
                &AuthenticateAuthFactorReply_oneof__seconds_left::seconds_left(v) => {
                    os.write_uint32(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticateAuthFactorReply {
        AuthenticateAuthFactorReply::new()
    }

    fn default_instance() -> &'static AuthenticateAuthFactorReply {
        static instance: ::protobuf::rt::LazyV2<AuthenticateAuthFactorReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthenticateAuthFactorReply::new)
    }
}

impl ::protobuf::Clear for AuthenticateAuthFactorReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.error_info.clear();
        self.authenticated = false;
        self.authorized_for.clear();
        self._seconds_left = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticateAuthFactorReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateAuthFactorRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    pub auth_factor_label: ::std::string::String,
    pub auth_factor: ::protobuf::SingularPtrField<super::auth_factor::AuthFactor>,
    pub auth_input: ::protobuf::SingularPtrField<super::auth_factor::AuthInput>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateAuthFactorRequest {
    fn default() -> &'a UpdateAuthFactorRequest {
        <UpdateAuthFactorRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateAuthFactorRequest {
    pub fn new() -> UpdateAuthFactorRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }

    // string auth_factor_label = 2;


    pub fn get_auth_factor_label(&self) -> &str {
        &self.auth_factor_label
    }
    pub fn clear_auth_factor_label(&mut self) {
        self.auth_factor_label.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_factor_label(&mut self, v: ::std::string::String) {
        self.auth_factor_label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_factor_label(&mut self) -> &mut ::std::string::String {
        &mut self.auth_factor_label
    }

    // Take field
    pub fn take_auth_factor_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.auth_factor_label, ::std::string::String::new())
    }

    // .user_data_auth.AuthFactor auth_factor = 3;


    pub fn get_auth_factor(&self) -> &super::auth_factor::AuthFactor {
        self.auth_factor.as_ref().unwrap_or_else(|| <super::auth_factor::AuthFactor as ::protobuf::Message>::default_instance())
    }
    pub fn clear_auth_factor(&mut self) {
        self.auth_factor.clear();
    }

    pub fn has_auth_factor(&self) -> bool {
        self.auth_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_factor(&mut self, v: super::auth_factor::AuthFactor) {
        self.auth_factor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_factor(&mut self) -> &mut super::auth_factor::AuthFactor {
        if self.auth_factor.is_none() {
            self.auth_factor.set_default();
        }
        self.auth_factor.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_factor(&mut self) -> super::auth_factor::AuthFactor {
        self.auth_factor.take().unwrap_or_else(|| super::auth_factor::AuthFactor::new())
    }

    // .user_data_auth.AuthInput auth_input = 4;


    pub fn get_auth_input(&self) -> &super::auth_factor::AuthInput {
        self.auth_input.as_ref().unwrap_or_else(|| <super::auth_factor::AuthInput as ::protobuf::Message>::default_instance())
    }
    pub fn clear_auth_input(&mut self) {
        self.auth_input.clear();
    }

    pub fn has_auth_input(&self) -> bool {
        self.auth_input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_input(&mut self, v: super::auth_factor::AuthInput) {
        self.auth_input = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_input(&mut self) -> &mut super::auth_factor::AuthInput {
        if self.auth_input.is_none() {
            self.auth_input.set_default();
        }
        self.auth_input.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_input(&mut self) -> super::auth_factor::AuthInput {
        self.auth_input.take().unwrap_or_else(|| super::auth_factor::AuthInput::new())
    }
}

impl ::protobuf::Message for UpdateAuthFactorRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.auth_factor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.auth_input {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.auth_factor_label)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.auth_factor)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.auth_input)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if !self.auth_factor_label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.auth_factor_label);
        }
        if let Some(ref v) = self.auth_factor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.auth_input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if !self.auth_factor_label.is_empty() {
            os.write_string(2, &self.auth_factor_label)?;
        }
        if let Some(ref v) = self.auth_factor.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.auth_input.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateAuthFactorRequest {
        UpdateAuthFactorRequest::new()
    }

    fn default_instance() -> &'static UpdateAuthFactorRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateAuthFactorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateAuthFactorRequest::new)
    }
}

impl ::protobuf::Clear for UpdateAuthFactorRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.auth_factor_label.clear();
        self.auth_factor.clear();
        self.auth_input.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateAuthFactorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateAuthFactorReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateAuthFactorReply {
    fn default() -> &'a UpdateAuthFactorReply {
        <UpdateAuthFactorReply as ::protobuf::Message>::default_instance()
    }
}

impl UpdateAuthFactorReply {
    pub fn new() -> UpdateAuthFactorReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 2;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for UpdateAuthFactorReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateAuthFactorReply {
        UpdateAuthFactorReply::new()
    }

    fn default_instance() -> &'static UpdateAuthFactorReply {
        static instance: ::protobuf::rt::LazyV2<UpdateAuthFactorReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateAuthFactorReply::new)
    }
}

impl ::protobuf::Clear for UpdateAuthFactorReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateAuthFactorReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RemoveAuthFactorRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    pub auth_factor_label: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveAuthFactorRequest {
    fn default() -> &'a RemoveAuthFactorRequest {
        <RemoveAuthFactorRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveAuthFactorRequest {
    pub fn new() -> RemoveAuthFactorRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }

    // string auth_factor_label = 2;


    pub fn get_auth_factor_label(&self) -> &str {
        &self.auth_factor_label
    }
    pub fn clear_auth_factor_label(&mut self) {
        self.auth_factor_label.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_factor_label(&mut self, v: ::std::string::String) {
        self.auth_factor_label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_factor_label(&mut self) -> &mut ::std::string::String {
        &mut self.auth_factor_label
    }

    // Take field
    pub fn take_auth_factor_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.auth_factor_label, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RemoveAuthFactorRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.auth_factor_label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if !self.auth_factor_label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.auth_factor_label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if !self.auth_factor_label.is_empty() {
            os.write_string(2, &self.auth_factor_label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveAuthFactorRequest {
        RemoveAuthFactorRequest::new()
    }

    fn default_instance() -> &'static RemoveAuthFactorRequest {
        static instance: ::protobuf::rt::LazyV2<RemoveAuthFactorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveAuthFactorRequest::new)
    }
}

impl ::protobuf::Clear for RemoveAuthFactorRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.auth_factor_label.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveAuthFactorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct RemoveAuthFactorReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoveAuthFactorReply {
    fn default() -> &'a RemoveAuthFactorReply {
        <RemoveAuthFactorReply as ::protobuf::Message>::default_instance()
    }
}

impl RemoveAuthFactorReply {
    pub fn new() -> RemoveAuthFactorReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 2;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for RemoveAuthFactorReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveAuthFactorReply {
        RemoveAuthFactorReply::new()
    }

    fn default_instance() -> &'static RemoveAuthFactorReply {
        static instance: ::protobuf::rt::LazyV2<RemoveAuthFactorReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoveAuthFactorReply::new)
    }
}

impl ::protobuf::Clear for RemoveAuthFactorReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveAuthFactorReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAuthFactorsRequest {
    // message fields
    pub account_id: ::protobuf::SingularPtrField<super::rpc::AccountIdentifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAuthFactorsRequest {
    fn default() -> &'a ListAuthFactorsRequest {
        <ListAuthFactorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAuthFactorsRequest {
    pub fn new() -> ListAuthFactorsRequest {
        ::std::default::Default::default()
    }

    // .cryptohome.AccountIdentifier account_id = 1;


    pub fn get_account_id(&self) -> &super::rpc::AccountIdentifier {
        self.account_id.as_ref().unwrap_or_else(|| <super::rpc::AccountIdentifier as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_id(&mut self) {
        self.account_id.clear();
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: super::rpc::AccountIdentifier) {
        self.account_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_id(&mut self) -> &mut super::rpc::AccountIdentifier {
        if self.account_id.is_none() {
            self.account_id.set_default();
        }
        self.account_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_id(&mut self) -> super::rpc::AccountIdentifier {
        self.account_id.take().unwrap_or_else(|| super::rpc::AccountIdentifier::new())
    }
}

impl ::protobuf::Message for ListAuthFactorsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.account_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.account_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAuthFactorsRequest {
        ListAuthFactorsRequest::new()
    }

    fn default_instance() -> &'static ListAuthFactorsRequest {
        static instance: ::protobuf::rt::LazyV2<ListAuthFactorsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAuthFactorsRequest::new)
    }
}

impl ::protobuf::Clear for ListAuthFactorsRequest {
    fn clear(&mut self) {
        self.account_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAuthFactorsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListAuthFactorsReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    pub configured_auth_factors_with_status: ::protobuf::RepeatedField<AuthFactorWithStatus>,
    pub supported_auth_factors: ::std::vec::Vec<super::auth_factor::AuthFactorType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAuthFactorsReply {
    fn default() -> &'a ListAuthFactorsReply {
        <ListAuthFactorsReply as ::protobuf::Message>::default_instance()
    }
}

impl ListAuthFactorsReply {
    pub fn new() -> ListAuthFactorsReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 2;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }

    // repeated .user_data_auth.AuthFactorWithStatus configured_auth_factors_with_status = 5;


    pub fn get_configured_auth_factors_with_status(&self) -> &[AuthFactorWithStatus] {
        &self.configured_auth_factors_with_status
    }
    pub fn clear_configured_auth_factors_with_status(&mut self) {
        self.configured_auth_factors_with_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_configured_auth_factors_with_status(&mut self, v: ::protobuf::RepeatedField<AuthFactorWithStatus>) {
        self.configured_auth_factors_with_status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_configured_auth_factors_with_status(&mut self) -> &mut ::protobuf::RepeatedField<AuthFactorWithStatus> {
        &mut self.configured_auth_factors_with_status
    }

    // Take field
    pub fn take_configured_auth_factors_with_status(&mut self) -> ::protobuf::RepeatedField<AuthFactorWithStatus> {
        ::std::mem::replace(&mut self.configured_auth_factors_with_status, ::protobuf::RepeatedField::new())
    }

    // repeated .user_data_auth.AuthFactorType supported_auth_factors = 4;


    pub fn get_supported_auth_factors(&self) -> &[super::auth_factor::AuthFactorType] {
        &self.supported_auth_factors
    }
    pub fn clear_supported_auth_factors(&mut self) {
        self.supported_auth_factors.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_auth_factors(&mut self, v: ::std::vec::Vec<super::auth_factor::AuthFactorType>) {
        self.supported_auth_factors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_auth_factors(&mut self) -> &mut ::std::vec::Vec<super::auth_factor::AuthFactorType> {
        &mut self.supported_auth_factors
    }

    // Take field
    pub fn take_supported_auth_factors(&mut self) -> ::std::vec::Vec<super::auth_factor::AuthFactorType> {
        ::std::mem::replace(&mut self.supported_auth_factors, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ListAuthFactorsReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configured_auth_factors_with_status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.configured_auth_factors_with_status)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.supported_auth_factors, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.configured_auth_factors_with_status {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.supported_auth_factors {
            my_size += ::protobuf::rt::enum_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.configured_auth_factors_with_status {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.supported_auth_factors {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAuthFactorsReply {
        ListAuthFactorsReply::new()
    }

    fn default_instance() -> &'static ListAuthFactorsReply {
        static instance: ::protobuf::rt::LazyV2<ListAuthFactorsReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListAuthFactorsReply::new)
    }
}

impl ::protobuf::Clear for ListAuthFactorsReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.error_info.clear();
        self.configured_auth_factors_with_status.clear();
        self.supported_auth_factors.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAuthFactorsReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetRecoveryRequestRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    pub auth_factor_label: ::std::string::String,
    pub requestor_user_id_type: GetRecoveryRequestRequest_UserType,
    pub requestor_user_id: ::std::string::String,
    pub gaia_access_token: ::std::string::String,
    pub gaia_reauth_proof_token: ::std::string::String,
    pub epoch_response: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetRecoveryRequestRequest {
    fn default() -> &'a GetRecoveryRequestRequest {
        <GetRecoveryRequestRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetRecoveryRequestRequest {
    pub fn new() -> GetRecoveryRequestRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }

    // string auth_factor_label = 2;


    pub fn get_auth_factor_label(&self) -> &str {
        &self.auth_factor_label
    }
    pub fn clear_auth_factor_label(&mut self) {
        self.auth_factor_label.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_factor_label(&mut self, v: ::std::string::String) {
        self.auth_factor_label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_factor_label(&mut self) -> &mut ::std::string::String {
        &mut self.auth_factor_label
    }

    // Take field
    pub fn take_auth_factor_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.auth_factor_label, ::std::string::String::new())
    }

    // .user_data_auth.GetRecoveryRequestRequest.UserType requestor_user_id_type = 3;


    pub fn get_requestor_user_id_type(&self) -> GetRecoveryRequestRequest_UserType {
        self.requestor_user_id_type
    }
    pub fn clear_requestor_user_id_type(&mut self) {
        self.requestor_user_id_type = GetRecoveryRequestRequest_UserType::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_requestor_user_id_type(&mut self, v: GetRecoveryRequestRequest_UserType) {
        self.requestor_user_id_type = v;
    }

    // string requestor_user_id = 4;


    pub fn get_requestor_user_id(&self) -> &str {
        &self.requestor_user_id
    }
    pub fn clear_requestor_user_id(&mut self) {
        self.requestor_user_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_requestor_user_id(&mut self, v: ::std::string::String) {
        self.requestor_user_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requestor_user_id(&mut self) -> &mut ::std::string::String {
        &mut self.requestor_user_id
    }

    // Take field
    pub fn take_requestor_user_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.requestor_user_id, ::std::string::String::new())
    }

    // string gaia_access_token = 5;


    pub fn get_gaia_access_token(&self) -> &str {
        &self.gaia_access_token
    }
    pub fn clear_gaia_access_token(&mut self) {
        self.gaia_access_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_gaia_access_token(&mut self, v: ::std::string::String) {
        self.gaia_access_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gaia_access_token(&mut self) -> &mut ::std::string::String {
        &mut self.gaia_access_token
    }

    // Take field
    pub fn take_gaia_access_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gaia_access_token, ::std::string::String::new())
    }

    // string gaia_reauth_proof_token = 6;


    pub fn get_gaia_reauth_proof_token(&self) -> &str {
        &self.gaia_reauth_proof_token
    }
    pub fn clear_gaia_reauth_proof_token(&mut self) {
        self.gaia_reauth_proof_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_gaia_reauth_proof_token(&mut self, v: ::std::string::String) {
        self.gaia_reauth_proof_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gaia_reauth_proof_token(&mut self) -> &mut ::std::string::String {
        &mut self.gaia_reauth_proof_token
    }

    // Take field
    pub fn take_gaia_reauth_proof_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gaia_reauth_proof_token, ::std::string::String::new())
    }

    // bytes epoch_response = 7;


    pub fn get_epoch_response(&self) -> &[u8] {
        &self.epoch_response
    }
    pub fn clear_epoch_response(&mut self) {
        self.epoch_response.clear();
    }

    // Param is passed by value, moved
    pub fn set_epoch_response(&mut self, v: ::std::vec::Vec<u8>) {
        self.epoch_response = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_epoch_response(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.epoch_response
    }

    // Take field
    pub fn take_epoch_response(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.epoch_response, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetRecoveryRequestRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.auth_factor_label)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.requestor_user_id_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.requestor_user_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gaia_access_token)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gaia_reauth_proof_token)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.epoch_response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if !self.auth_factor_label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.auth_factor_label);
        }
        if self.requestor_user_id_type != GetRecoveryRequestRequest_UserType::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(3, self.requestor_user_id_type);
        }
        if !self.requestor_user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.requestor_user_id);
        }
        if !self.gaia_access_token.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.gaia_access_token);
        }
        if !self.gaia_reauth_proof_token.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.gaia_reauth_proof_token);
        }
        if !self.epoch_response.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.epoch_response);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if !self.auth_factor_label.is_empty() {
            os.write_string(2, &self.auth_factor_label)?;
        }
        if self.requestor_user_id_type != GetRecoveryRequestRequest_UserType::UNKNOWN {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.requestor_user_id_type))?;
        }
        if !self.requestor_user_id.is_empty() {
            os.write_string(4, &self.requestor_user_id)?;
        }
        if !self.gaia_access_token.is_empty() {
            os.write_string(5, &self.gaia_access_token)?;
        }
        if !self.gaia_reauth_proof_token.is_empty() {
            os.write_string(6, &self.gaia_reauth_proof_token)?;
        }
        if !self.epoch_response.is_empty() {
            os.write_bytes(7, &self.epoch_response)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRecoveryRequestRequest {
        GetRecoveryRequestRequest::new()
    }

    fn default_instance() -> &'static GetRecoveryRequestRequest {
        static instance: ::protobuf::rt::LazyV2<GetRecoveryRequestRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetRecoveryRequestRequest::new)
    }
}

impl ::protobuf::Clear for GetRecoveryRequestRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.auth_factor_label.clear();
        self.requestor_user_id_type = GetRecoveryRequestRequest_UserType::UNKNOWN;
        self.requestor_user_id.clear();
        self.gaia_access_token.clear();
        self.gaia_reauth_proof_token.clear();
        self.epoch_response.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRecoveryRequestRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GetRecoveryRequestRequest_UserType {
    UNKNOWN = 0,
    GAIA_ID = 1,
}

impl ::protobuf::ProtobufEnum for GetRecoveryRequestRequest_UserType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GetRecoveryRequestRequest_UserType> {
        match value {
            0 => ::std::option::Option::Some(GetRecoveryRequestRequest_UserType::UNKNOWN),
            1 => ::std::option::Option::Some(GetRecoveryRequestRequest_UserType::GAIA_ID),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GetRecoveryRequestRequest_UserType] = &[
            GetRecoveryRequestRequest_UserType::UNKNOWN,
            GetRecoveryRequestRequest_UserType::GAIA_ID,
        ];
        values
    }
}

impl ::std::marker::Copy for GetRecoveryRequestRequest_UserType {
}

impl ::std::default::Default for GetRecoveryRequestRequest_UserType {
    fn default() -> Self {
        GetRecoveryRequestRequest_UserType::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRecoveryRequestRequest_UserType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetRecoveryRequestReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    pub recovery_request: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetRecoveryRequestReply {
    fn default() -> &'a GetRecoveryRequestReply {
        <GetRecoveryRequestReply as ::protobuf::Message>::default_instance()
    }
}

impl GetRecoveryRequestReply {
    pub fn new() -> GetRecoveryRequestReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 2;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }

    // bytes recovery_request = 3;


    pub fn get_recovery_request(&self) -> &[u8] {
        &self.recovery_request
    }
    pub fn clear_recovery_request(&mut self) {
        self.recovery_request.clear();
    }

    // Param is passed by value, moved
    pub fn set_recovery_request(&mut self, v: ::std::vec::Vec<u8>) {
        self.recovery_request = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recovery_request(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.recovery_request
    }

    // Take field
    pub fn take_recovery_request(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.recovery_request, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetRecoveryRequestReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.recovery_request)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.recovery_request.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.recovery_request);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.recovery_request.is_empty() {
            os.write_bytes(3, &self.recovery_request)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetRecoveryRequestReply {
        GetRecoveryRequestReply::new()
    }

    fn default_instance() -> &'static GetRecoveryRequestReply {
        static instance: ::protobuf::rt::LazyV2<GetRecoveryRequestReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetRecoveryRequestReply::new)
    }
}

impl ::protobuf::Clear for GetRecoveryRequestReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.error_info.clear();
        self.recovery_request.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for GetRecoveryRequestReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PrepareAsyncAuthFactorRequest {
    // message fields
    pub auth_session_id: ::std::vec::Vec<u8>,
    pub auth_factor_type: super::auth_factor::AuthFactorType,
    pub purpose: super::auth_factor::AuthFactorPreparePurpose,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrepareAsyncAuthFactorRequest {
    fn default() -> &'a PrepareAsyncAuthFactorRequest {
        <PrepareAsyncAuthFactorRequest as ::protobuf::Message>::default_instance()
    }
}

impl PrepareAsyncAuthFactorRequest {
    pub fn new() -> PrepareAsyncAuthFactorRequest {
        ::std::default::Default::default()
    }

    // bytes auth_session_id = 1;


    pub fn get_auth_session_id(&self) -> &[u8] {
        &self.auth_session_id
    }
    pub fn clear_auth_session_id(&mut self) {
        self.auth_session_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_session_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.auth_session_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_session_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.auth_session_id
    }

    // Take field
    pub fn take_auth_session_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.auth_session_id, ::std::vec::Vec::new())
    }

    // .user_data_auth.AuthFactorType auth_factor_type = 2;


    pub fn get_auth_factor_type(&self) -> super::auth_factor::AuthFactorType {
        self.auth_factor_type
    }
    pub fn clear_auth_factor_type(&mut self) {
        self.auth_factor_type = super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_auth_factor_type(&mut self, v: super::auth_factor::AuthFactorType) {
        self.auth_factor_type = v;
    }

    // .user_data_auth.AuthFactorPreparePurpose purpose = 3;


    pub fn get_purpose(&self) -> super::auth_factor::AuthFactorPreparePurpose {
        self.purpose
    }
    pub fn clear_purpose(&mut self) {
        self.purpose = super::auth_factor::AuthFactorPreparePurpose::PURPOSE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_purpose(&mut self, v: super::auth_factor::AuthFactorPreparePurpose) {
        self.purpose = v;
    }
}

impl ::protobuf::Message for PrepareAsyncAuthFactorRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.auth_session_id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.auth_factor_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.purpose, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if self.auth_factor_type != super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.auth_factor_type);
        }
        if self.purpose != super::auth_factor::AuthFactorPreparePurpose::PURPOSE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.purpose);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if self.auth_factor_type != super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.auth_factor_type))?;
        }
        if self.purpose != super::auth_factor::AuthFactorPreparePurpose::PURPOSE_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.purpose))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrepareAsyncAuthFactorRequest {
        PrepareAsyncAuthFactorRequest::new()
    }

    fn default_instance() -> &'static PrepareAsyncAuthFactorRequest {
        static instance: ::protobuf::rt::LazyV2<PrepareAsyncAuthFactorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrepareAsyncAuthFactorRequest::new)
    }
}

impl ::protobuf::Clear for PrepareAsyncAuthFactorRequest {
    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.auth_factor_type = super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED;
        self.purpose = super::auth_factor::AuthFactorPreparePurpose::PURPOSE_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PrepareAsyncAuthFactorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct PrepareAsyncAuthFactorReply {
    // message fields
    pub error: CryptohomeErrorCode,
    pub error_info: ::protobuf::SingularPtrField<CryptohomeErrorInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrepareAsyncAuthFactorReply {
    fn default() -> &'a PrepareAsyncAuthFactorReply {
        <PrepareAsyncAuthFactorReply as ::protobuf::Message>::default_instance()
    }
}

impl PrepareAsyncAuthFactorReply {
    pub fn new() -> PrepareAsyncAuthFactorReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.CryptohomeErrorCode error = 1;


    pub fn get_error(&self) -> CryptohomeErrorCode {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: CryptohomeErrorCode) {
        self.error = v;
    }

    // .user_data_auth.CryptohomeErrorInfo error_info = 2;


    pub fn get_error_info(&self) -> &CryptohomeErrorInfo {
        self.error_info.as_ref().unwrap_or_else(|| <CryptohomeErrorInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_info(&mut self) {
        self.error_info.clear();
    }

    pub fn has_error_info(&self) -> bool {
        self.error_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_info(&mut self, v: CryptohomeErrorInfo) {
        self.error_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_info(&mut self) -> &mut CryptohomeErrorInfo {
        if self.error_info.is_none() {
            self.error_info.set_default();
        }
        self.error_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_info(&mut self) -> CryptohomeErrorInfo {
        self.error_info.take().unwrap_or_else(|| CryptohomeErrorInfo::new())
    }
}

impl ::protobuf::Message for PrepareAsyncAuthFactorReply {
    fn is_initialized(&self) -> bool {
        for v in &self.error_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            my_size += ::protobuf::rt::enum_size(1, self.error);
        }
        if let Some(ref v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.error != CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.error))?;
        }
        if let Some(ref v) = self.error_info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrepareAsyncAuthFactorReply {
        PrepareAsyncAuthFactorReply::new()
    }

    fn default_instance() -> &'static PrepareAsyncAuthFactorReply {
        static instance: ::protobuf::rt::LazyV2<PrepareAsyncAuthFactorReply> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrepareAsyncAuthFactorReply::new)
    }
}

impl ::protobuf::Clear for PrepareAsyncAuthFactorReply {
    fn clear(&mut self) {
        self.error = CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET;
        self.error_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for PrepareAsyncAuthFactorReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AsyncAuthScanResult {
    // message oneof groups
    pub scan_result: ::std::option::Option<AsyncAuthScanResult_oneof_scan_result>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AsyncAuthScanResult {
    fn default() -> &'a AsyncAuthScanResult {
        <AsyncAuthScanResult as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AsyncAuthScanResult_oneof_scan_result {
    fingerprint_result(FingerprintScanResult),
}

impl AsyncAuthScanResult {
    pub fn new() -> AsyncAuthScanResult {
        ::std::default::Default::default()
    }

    // .user_data_auth.FingerprintScanResult fingerprint_result = 1;


    pub fn get_fingerprint_result(&self) -> FingerprintScanResult {
        match self.scan_result {
            ::std::option::Option::Some(AsyncAuthScanResult_oneof_scan_result::fingerprint_result(v)) => v,
            _ => FingerprintScanResult::FINGERPRINT_SCAN_RESULT_SUCCESS,
        }
    }
    pub fn clear_fingerprint_result(&mut self) {
        self.scan_result = ::std::option::Option::None;
    }

    pub fn has_fingerprint_result(&self) -> bool {
        match self.scan_result {
            ::std::option::Option::Some(AsyncAuthScanResult_oneof_scan_result::fingerprint_result(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fingerprint_result(&mut self, v: FingerprintScanResult) {
        self.scan_result = ::std::option::Option::Some(AsyncAuthScanResult_oneof_scan_result::fingerprint_result(v))
    }
}

impl ::protobuf::Message for AsyncAuthScanResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scan_result = ::std::option::Option::Some(AsyncAuthScanResult_oneof_scan_result::fingerprint_result(is.read_enum()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.scan_result {
            match v {
                &AsyncAuthScanResult_oneof_scan_result::fingerprint_result(v) => {
                    my_size += ::protobuf::rt::enum_size(1, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.scan_result {
            match v {
                &AsyncAuthScanResult_oneof_scan_result::fingerprint_result(v) => {
                    os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AsyncAuthScanResult {
        AsyncAuthScanResult::new()
    }

    fn default_instance() -> &'static AsyncAuthScanResult {
        static instance: ::protobuf::rt::LazyV2<AsyncAuthScanResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AsyncAuthScanResult::new)
    }
}

impl ::protobuf::Clear for AsyncAuthScanResult {
    fn clear(&mut self) {
        self.scan_result = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AsyncAuthScanResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct FingerprintEnrollmentProgress {
    // message fields
    pub percent_complete: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FingerprintEnrollmentProgress {
    fn default() -> &'a FingerprintEnrollmentProgress {
        <FingerprintEnrollmentProgress as ::protobuf::Message>::default_instance()
    }
}

impl FingerprintEnrollmentProgress {
    pub fn new() -> FingerprintEnrollmentProgress {
        ::std::default::Default::default()
    }

    // int32 percent_complete = 1;


    pub fn get_percent_complete(&self) -> i32 {
        self.percent_complete
    }
    pub fn clear_percent_complete(&mut self) {
        self.percent_complete = 0;
    }

    // Param is passed by value, moved
    pub fn set_percent_complete(&mut self, v: i32) {
        self.percent_complete = v;
    }
}

impl ::protobuf::Message for FingerprintEnrollmentProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.percent_complete = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.percent_complete != 0 {
            my_size += ::protobuf::rt::value_size(1, self.percent_complete, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.percent_complete != 0 {
            os.write_int32(1, self.percent_complete)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FingerprintEnrollmentProgress {
        FingerprintEnrollmentProgress::new()
    }

    fn default_instance() -> &'static FingerprintEnrollmentProgress {
        static instance: ::protobuf::rt::LazyV2<FingerprintEnrollmentProgress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FingerprintEnrollmentProgress::new)
    }
}

impl ::protobuf::Clear for FingerprintEnrollmentProgress {
    fn clear(&mut self) {
        self.percent_complete = 0;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for FingerprintEnrollmentProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct AsyncAuthEnrollmentProgress {
    // message fields
    pub scan_result: ::protobuf::SingularPtrField<AsyncAuthScanResult>,
    pub done: bool,
    // message oneof groups
    pub progress: ::std::option::Option<AsyncAuthEnrollmentProgress_oneof_progress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AsyncAuthEnrollmentProgress {
    fn default() -> &'a AsyncAuthEnrollmentProgress {
        <AsyncAuthEnrollmentProgress as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AsyncAuthEnrollmentProgress_oneof_progress {
    fingerprint_progress(FingerprintEnrollmentProgress),
}

impl AsyncAuthEnrollmentProgress {
    pub fn new() -> AsyncAuthEnrollmentProgress {
        ::std::default::Default::default()
    }

    // .user_data_auth.AsyncAuthScanResult scan_result = 1;


    pub fn get_scan_result(&self) -> &AsyncAuthScanResult {
        self.scan_result.as_ref().unwrap_or_else(|| <AsyncAuthScanResult as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scan_result(&mut self) {
        self.scan_result.clear();
    }

    pub fn has_scan_result(&self) -> bool {
        self.scan_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scan_result(&mut self, v: AsyncAuthScanResult) {
        self.scan_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scan_result(&mut self) -> &mut AsyncAuthScanResult {
        if self.scan_result.is_none() {
            self.scan_result.set_default();
        }
        self.scan_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_scan_result(&mut self) -> AsyncAuthScanResult {
        self.scan_result.take().unwrap_or_else(|| AsyncAuthScanResult::new())
    }

    // bool done = 2;


    pub fn get_done(&self) -> bool {
        self.done
    }
    pub fn clear_done(&mut self) {
        self.done = false;
    }

    // Param is passed by value, moved
    pub fn set_done(&mut self, v: bool) {
        self.done = v;
    }

    // .user_data_auth.FingerprintEnrollmentProgress fingerprint_progress = 3;


    pub fn get_fingerprint_progress(&self) -> &FingerprintEnrollmentProgress {
        match self.progress {
            ::std::option::Option::Some(AsyncAuthEnrollmentProgress_oneof_progress::fingerprint_progress(ref v)) => v,
            _ => <FingerprintEnrollmentProgress as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_fingerprint_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_fingerprint_progress(&self) -> bool {
        match self.progress {
            ::std::option::Option::Some(AsyncAuthEnrollmentProgress_oneof_progress::fingerprint_progress(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fingerprint_progress(&mut self, v: FingerprintEnrollmentProgress) {
        self.progress = ::std::option::Option::Some(AsyncAuthEnrollmentProgress_oneof_progress::fingerprint_progress(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fingerprint_progress(&mut self) -> &mut FingerprintEnrollmentProgress {
        if let ::std::option::Option::Some(AsyncAuthEnrollmentProgress_oneof_progress::fingerprint_progress(_)) = self.progress {
        } else {
            self.progress = ::std::option::Option::Some(AsyncAuthEnrollmentProgress_oneof_progress::fingerprint_progress(FingerprintEnrollmentProgress::new()));
        }
        match self.progress {
            ::std::option::Option::Some(AsyncAuthEnrollmentProgress_oneof_progress::fingerprint_progress(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fingerprint_progress(&mut self) -> FingerprintEnrollmentProgress {
        if self.has_fingerprint_progress() {
            match self.progress.take() {
                ::std::option::Option::Some(AsyncAuthEnrollmentProgress_oneof_progress::fingerprint_progress(v)) => v,
                _ => panic!(),
            }
        } else {
            FingerprintEnrollmentProgress::new()
        }
    }
}

impl ::protobuf::Message for AsyncAuthEnrollmentProgress {
    fn is_initialized(&self) -> bool {
        for v in &self.scan_result {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(AsyncAuthEnrollmentProgress_oneof_progress::fingerprint_progress(ref v)) = self.progress {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scan_result)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.done = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.progress = ::std::option::Option::Some(AsyncAuthEnrollmentProgress_oneof_progress::fingerprint_progress(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.scan_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.done != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.progress {
            match v {
                &AsyncAuthEnrollmentProgress_oneof_progress::fingerprint_progress(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.scan_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.done != false {
            os.write_bool(2, self.done)?;
        }
        if let ::std::option::Option::Some(ref v) = self.progress {
            match v {
                &AsyncAuthEnrollmentProgress_oneof_progress::fingerprint_progress(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AsyncAuthEnrollmentProgress {
        AsyncAuthEnrollmentProgress::new()
    }

    fn default_instance() -> &'static AsyncAuthEnrollmentProgress {
        static instance: ::protobuf::rt::LazyV2<AsyncAuthEnrollmentProgress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AsyncAuthEnrollmentProgress::new)
    }
}

impl ::protobuf::Clear for AsyncAuthEnrollmentProgress {
    fn clear(&mut self) {
        self.scan_result.clear();
        self.done = false;
        self.progress = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for AsyncAuthEnrollmentProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CryptohomeErrorCode {
    CRYPTOHOME_ERROR_NOT_SET = 0,
    CRYPTOHOME_ERROR_ACCOUNT_NOT_FOUND = 1,
    CRYPTOHOME_ERROR_AUTHORIZATION_KEY_NOT_FOUND = 2,
    CRYPTOHOME_ERROR_AUTHORIZATION_KEY_FAILED = 3,
    CRYPTOHOME_ERROR_NOT_IMPLEMENTED = 4,
    CRYPTOHOME_ERROR_MOUNT_FATAL = 5,
    CRYPTOHOME_ERROR_MOUNT_MOUNT_POINT_BUSY = 6,
    CRYPTOHOME_ERROR_TPM_COMM_ERROR = 7,
    CRYPTOHOME_ERROR_TPM_DEFEND_LOCK = 8,
    CRYPTOHOME_ERROR_TPM_NEEDS_REBOOT = 9,
    CRYPTOHOME_ERROR_AUTHORIZATION_KEY_DENIED = 10,
    CRYPTOHOME_ERROR_KEY_QUOTA_EXCEEDED = 11,
    CRYPTOHOME_ERROR_KEY_LABEL_EXISTS = 12,
    CRYPTOHOME_ERROR_BACKING_STORE_FAILURE = 13,
    CRYPTOHOME_ERROR_UPDATE_SIGNATURE_INVALID = 14,
    CRYPTOHOME_ERROR_KEY_NOT_FOUND = 15,
    CRYPTOHOME_ERROR_LOCKBOX_SIGNATURE_INVALID = 16,
    CRYPTOHOME_ERROR_LOCKBOX_CANNOT_SIGN = 17,
    CRYPTOHOME_ERROR_BOOT_ATTRIBUTE_NOT_FOUND = 18,
    CRYPTOHOME_ERROR_BOOT_ATTRIBUTES_CANNOT_SIGN = 19,
    CRYPTOHOME_ERROR_TPM_EK_NOT_AVAILABLE = 20,
    CRYPTOHOME_ERROR_ATTESTATION_NOT_READY = 21,
    CRYPTOHOME_ERROR_CANNOT_CONNECT_TO_CA = 22,
    CRYPTOHOME_ERROR_CA_REFUSED_ENROLLMENT = 23,
    CRYPTOHOME_ERROR_CA_REFUSED_CERTIFICATE = 24,
    CRYPTOHOME_ERROR_INTERNAL_ATTESTATION_ERROR = 25,
    CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_INVALID = 26,
    CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_STORE = 27,
    CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_REMOVE = 28,
    CRYPTOHOME_ERROR_MOUNT_OLD_ENCRYPTION = 29,
    CRYPTOHOME_ERROR_MOUNT_PREVIOUS_MIGRATION_INCOMPLETE = 30,
    CRYPTOHOME_ERROR_MIGRATE_KEY_FAILED = 31,
    CRYPTOHOME_ERROR_REMOVE_FAILED = 32,
    CRYPTOHOME_ERROR_INVALID_ARGUMENT = 33,
    CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_GET_FAILED = 34,
    CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_SET_FAILED = 35,
    CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_FINALIZE_FAILED = 36,
    CRYPTOHOME_ERROR_UPDATE_USER_ACTIVITY_TIMESTAMP_FAILED = 37,
    CRYPTOHOME_ERROR_FAILED_TO_READ_PCR = 38,
    CRYPTOHOME_ERROR_PCR_ALREADY_EXTENDED = 39,
    CRYPTOHOME_ERROR_FAILED_TO_EXTEND_PCR = 40,
    CRYPTOHOME_ERROR_TPM_UPDATE_REQUIRED = 41,
    CRYPTOHOME_ERROR_FINGERPRINT_ERROR_INTERNAL = 42,
    CRYPTOHOME_ERROR_FINGERPRINT_RETRY_REQUIRED = 43,
    CRYPTOHOME_ERROR_FINGERPRINT_DENIED = 44,
    CRYPTOHOME_ERROR_VAULT_UNRECOVERABLE = 45,
    CRYPTOHOME_ERROR_FIDO_MAKE_CREDENTIAL_FAILED = 46,
    CRYPTOHOME_ERROR_FIDO_GET_ASSERTION_FAILED = 47,
    CRYPTOHOME_TOKEN_SERIALIZATION_FAILED = 48,
    CRYPTOHOME_INVALID_AUTH_SESSION_TOKEN = 49,
    CRYPTOHOME_ADD_CREDENTIALS_FAILED = 50,
    CRYPTOHOME_ERROR_UNAUTHENTICATED_AUTH_SESSION = 51,
    CRYPTOHOME_ERROR_UNKNOWN_LEGACY = 52,
    CRYPTOHOME_ERROR_UNUSABLE_VAULT = 53,
    CRYPTOHOME_REMOVE_CREDENTIALS_FAILED = 54,
    CRYPTOHOME_UPDATE_CREDENTIALS_FAILED = 55,
}

impl ::protobuf::ProtobufEnum for CryptohomeErrorCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CryptohomeErrorCode> {
        match value {
            0 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET),
            1 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_ACCOUNT_NOT_FOUND),
            2 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_AUTHORIZATION_KEY_NOT_FOUND),
            3 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_AUTHORIZATION_KEY_FAILED),
            4 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_IMPLEMENTED),
            5 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_FATAL),
            6 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_MOUNT_POINT_BUSY),
            7 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_COMM_ERROR),
            8 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_DEFEND_LOCK),
            9 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_NEEDS_REBOOT),
            10 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_AUTHORIZATION_KEY_DENIED),
            11 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_KEY_QUOTA_EXCEEDED),
            12 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_KEY_LABEL_EXISTS),
            13 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_BACKING_STORE_FAILURE),
            14 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_UPDATE_SIGNATURE_INVALID),
            15 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_KEY_NOT_FOUND),
            16 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_LOCKBOX_SIGNATURE_INVALID),
            17 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_LOCKBOX_CANNOT_SIGN),
            18 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_BOOT_ATTRIBUTE_NOT_FOUND),
            19 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_BOOT_ATTRIBUTES_CANNOT_SIGN),
            20 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_EK_NOT_AVAILABLE),
            21 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_ATTESTATION_NOT_READY),
            22 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_CANNOT_CONNECT_TO_CA),
            23 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_CA_REFUSED_ENROLLMENT),
            24 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_CA_REFUSED_CERTIFICATE),
            25 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_INTERNAL_ATTESTATION_ERROR),
            26 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_INVALID),
            27 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_STORE),
            28 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_REMOVE),
            29 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_OLD_ENCRYPTION),
            30 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_PREVIOUS_MIGRATION_INCOMPLETE),
            31 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_MIGRATE_KEY_FAILED),
            32 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_REMOVE_FAILED),
            33 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_INVALID_ARGUMENT),
            34 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_GET_FAILED),
            35 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_SET_FAILED),
            36 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_FINALIZE_FAILED),
            37 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_UPDATE_USER_ACTIVITY_TIMESTAMP_FAILED),
            38 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FAILED_TO_READ_PCR),
            39 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_PCR_ALREADY_EXTENDED),
            40 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FAILED_TO_EXTEND_PCR),
            41 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_UPDATE_REQUIRED),
            42 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FINGERPRINT_ERROR_INTERNAL),
            43 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FINGERPRINT_RETRY_REQUIRED),
            44 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FINGERPRINT_DENIED),
            45 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_VAULT_UNRECOVERABLE),
            46 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FIDO_MAKE_CREDENTIAL_FAILED),
            47 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FIDO_GET_ASSERTION_FAILED),
            48 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_TOKEN_SERIALIZATION_FAILED),
            49 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_INVALID_AUTH_SESSION_TOKEN),
            50 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ADD_CREDENTIALS_FAILED),
            51 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_UNAUTHENTICATED_AUTH_SESSION),
            52 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_UNKNOWN_LEGACY),
            53 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_UNUSABLE_VAULT),
            54 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_REMOVE_CREDENTIALS_FAILED),
            55 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_UPDATE_CREDENTIALS_FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CryptohomeErrorCode] = &[
            CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_ACCOUNT_NOT_FOUND,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_AUTHORIZATION_KEY_NOT_FOUND,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_AUTHORIZATION_KEY_FAILED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_IMPLEMENTED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_FATAL,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_MOUNT_POINT_BUSY,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_COMM_ERROR,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_DEFEND_LOCK,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_NEEDS_REBOOT,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_AUTHORIZATION_KEY_DENIED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_KEY_QUOTA_EXCEEDED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_KEY_LABEL_EXISTS,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_BACKING_STORE_FAILURE,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_UPDATE_SIGNATURE_INVALID,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_KEY_NOT_FOUND,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_LOCKBOX_SIGNATURE_INVALID,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_LOCKBOX_CANNOT_SIGN,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_BOOT_ATTRIBUTE_NOT_FOUND,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_BOOT_ATTRIBUTES_CANNOT_SIGN,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_EK_NOT_AVAILABLE,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_ATTESTATION_NOT_READY,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_CANNOT_CONNECT_TO_CA,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_CA_REFUSED_ENROLLMENT,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_CA_REFUSED_CERTIFICATE,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_INTERNAL_ATTESTATION_ERROR,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_INVALID,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_STORE,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_REMOVE,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_OLD_ENCRYPTION,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_PREVIOUS_MIGRATION_INCOMPLETE,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_MIGRATE_KEY_FAILED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_REMOVE_FAILED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_INVALID_ARGUMENT,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_GET_FAILED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_SET_FAILED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_FINALIZE_FAILED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_UPDATE_USER_ACTIVITY_TIMESTAMP_FAILED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_FAILED_TO_READ_PCR,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_PCR_ALREADY_EXTENDED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_FAILED_TO_EXTEND_PCR,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_UPDATE_REQUIRED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_FINGERPRINT_ERROR_INTERNAL,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_FINGERPRINT_RETRY_REQUIRED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_FINGERPRINT_DENIED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_VAULT_UNRECOVERABLE,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_FIDO_MAKE_CREDENTIAL_FAILED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_FIDO_GET_ASSERTION_FAILED,
            CryptohomeErrorCode::CRYPTOHOME_TOKEN_SERIALIZATION_FAILED,
            CryptohomeErrorCode::CRYPTOHOME_INVALID_AUTH_SESSION_TOKEN,
            CryptohomeErrorCode::CRYPTOHOME_ADD_CREDENTIALS_FAILED,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_UNAUTHENTICATED_AUTH_SESSION,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_UNKNOWN_LEGACY,
            CryptohomeErrorCode::CRYPTOHOME_ERROR_UNUSABLE_VAULT,
            CryptohomeErrorCode::CRYPTOHOME_REMOVE_CREDENTIALS_FAILED,
            CryptohomeErrorCode::CRYPTOHOME_UPDATE_CREDENTIALS_FAILED,
        ];
        values
    }
}

impl ::std::marker::Copy for CryptohomeErrorCode {
}

impl ::std::default::Default for CryptohomeErrorCode {
    fn default() -> Self {
        CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for CryptohomeErrorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PrimaryAction {
    PRIMARY_NO_ERROR = 0,
    PRIMARY_NONE = 1,
    PRIMARY_CREATE_REQUIRED = 2,
    PRIMARY_NOTIFY_OLD_ENCRYPTION_POLICY = 3,
    PRIMARY_RESUME_PREVIOUS_MIGRATION = 4,
    PRIMARY_TPM_UDPATE_REQUIRED = 5,
    PRIMARY_TPM_NEEDS_REBOOT = 6,
    PRIMARY_TPM_LOCKOUT = 7,
    PRIMARY_INCORRECT_AUTH = 8,
}

impl ::protobuf::ProtobufEnum for PrimaryAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PrimaryAction> {
        match value {
            0 => ::std::option::Option::Some(PrimaryAction::PRIMARY_NO_ERROR),
            1 => ::std::option::Option::Some(PrimaryAction::PRIMARY_NONE),
            2 => ::std::option::Option::Some(PrimaryAction::PRIMARY_CREATE_REQUIRED),
            3 => ::std::option::Option::Some(PrimaryAction::PRIMARY_NOTIFY_OLD_ENCRYPTION_POLICY),
            4 => ::std::option::Option::Some(PrimaryAction::PRIMARY_RESUME_PREVIOUS_MIGRATION),
            5 => ::std::option::Option::Some(PrimaryAction::PRIMARY_TPM_UDPATE_REQUIRED),
            6 => ::std::option::Option::Some(PrimaryAction::PRIMARY_TPM_NEEDS_REBOOT),
            7 => ::std::option::Option::Some(PrimaryAction::PRIMARY_TPM_LOCKOUT),
            8 => ::std::option::Option::Some(PrimaryAction::PRIMARY_INCORRECT_AUTH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PrimaryAction] = &[
            PrimaryAction::PRIMARY_NO_ERROR,
            PrimaryAction::PRIMARY_NONE,
            PrimaryAction::PRIMARY_CREATE_REQUIRED,
            PrimaryAction::PRIMARY_NOTIFY_OLD_ENCRYPTION_POLICY,
            PrimaryAction::PRIMARY_RESUME_PREVIOUS_MIGRATION,
            PrimaryAction::PRIMARY_TPM_UDPATE_REQUIRED,
            PrimaryAction::PRIMARY_TPM_NEEDS_REBOOT,
            PrimaryAction::PRIMARY_TPM_LOCKOUT,
            PrimaryAction::PRIMARY_INCORRECT_AUTH,
        ];
        values
    }
}

impl ::std::marker::Copy for PrimaryAction {
}

impl ::std::default::Default for PrimaryAction {
    fn default() -> Self {
        PrimaryAction::PRIMARY_NO_ERROR
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimaryAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PossibleAction {
    POSSIBLY_NONE = 0,
    POSSIBLY_RETRY = 1,
    POSSIBLY_REBOOT = 2,
    POSSIBLY_AUTH = 3,
    POSSIBLY_INCORRECT_AUTH = 4,
    POSSIBLY_DELETE_VAULT = 5,
    POSSIBLY_POWERWASH = 6,
    POSSIBLY_DEV_CHECK_UNEXPECTED_STATE = 7,
    POSSIBLY_FATAL = 8,
}

impl ::protobuf::ProtobufEnum for PossibleAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PossibleAction> {
        match value {
            0 => ::std::option::Option::Some(PossibleAction::POSSIBLY_NONE),
            1 => ::std::option::Option::Some(PossibleAction::POSSIBLY_RETRY),
            2 => ::std::option::Option::Some(PossibleAction::POSSIBLY_REBOOT),
            3 => ::std::option::Option::Some(PossibleAction::POSSIBLY_AUTH),
            4 => ::std::option::Option::Some(PossibleAction::POSSIBLY_INCORRECT_AUTH),
            5 => ::std::option::Option::Some(PossibleAction::POSSIBLY_DELETE_VAULT),
            6 => ::std::option::Option::Some(PossibleAction::POSSIBLY_POWERWASH),
            7 => ::std::option::Option::Some(PossibleAction::POSSIBLY_DEV_CHECK_UNEXPECTED_STATE),
            8 => ::std::option::Option::Some(PossibleAction::POSSIBLY_FATAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PossibleAction] = &[
            PossibleAction::POSSIBLY_NONE,
            PossibleAction::POSSIBLY_RETRY,
            PossibleAction::POSSIBLY_REBOOT,
            PossibleAction::POSSIBLY_AUTH,
            PossibleAction::POSSIBLY_INCORRECT_AUTH,
            PossibleAction::POSSIBLY_DELETE_VAULT,
            PossibleAction::POSSIBLY_POWERWASH,
            PossibleAction::POSSIBLY_DEV_CHECK_UNEXPECTED_STATE,
            PossibleAction::POSSIBLY_FATAL,
        ];
        values
    }
}

impl ::std::marker::Copy for PossibleAction {
}

impl ::std::default::Default for PossibleAction {
    fn default() -> Self {
        PossibleAction::POSSIBLY_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for PossibleAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DircryptoMigrationStatus {
    DIRCRYPTO_MIGRATION_SUCCESS = 0,
    DIRCRYPTO_MIGRATION_FAILED = 1,
    DIRCRYPTO_MIGRATION_INITIALIZING = 2,
    DIRCRYPTO_MIGRATION_IN_PROGRESS = 3,
}

impl ::protobuf::ProtobufEnum for DircryptoMigrationStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DircryptoMigrationStatus> {
        match value {
            0 => ::std::option::Option::Some(DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_SUCCESS),
            1 => ::std::option::Option::Some(DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_FAILED),
            2 => ::std::option::Option::Some(DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_INITIALIZING),
            3 => ::std::option::Option::Some(DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_IN_PROGRESS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DircryptoMigrationStatus] = &[
            DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_SUCCESS,
            DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_FAILED,
            DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_INITIALIZING,
            DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_IN_PROGRESS,
        ];
        values
    }
}

impl ::std::marker::Copy for DircryptoMigrationStatus {
}

impl ::std::default::Default for DircryptoMigrationStatus {
    fn default() -> Self {
        DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for DircryptoMigrationStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AuthSessionFlags {
    AUTH_SESSION_FLAGS_NONE = 0,
    AUTH_SESSION_FLAGS_EPHEMERAL_USER = 2,
}

impl ::protobuf::ProtobufEnum for AuthSessionFlags {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthSessionFlags> {
        match value {
            0 => ::std::option::Option::Some(AuthSessionFlags::AUTH_SESSION_FLAGS_NONE),
            2 => ::std::option::Option::Some(AuthSessionFlags::AUTH_SESSION_FLAGS_EPHEMERAL_USER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AuthSessionFlags] = &[
            AuthSessionFlags::AUTH_SESSION_FLAGS_NONE,
            AuthSessionFlags::AUTH_SESSION_FLAGS_EPHEMERAL_USER,
        ];
        values
    }
}

impl ::std::marker::Copy for AuthSessionFlags {
}

impl ::std::default::Default for AuthSessionFlags {
    fn default() -> Self {
        AuthSessionFlags::AUTH_SESSION_FLAGS_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthSessionFlags {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AuthSessionStatus {
    AUTH_SESSION_STATUS_NOT_SET = 0,
    AUTH_SESSION_STATUS_FURTHER_FACTOR_REQUIRED = 1,
    AUTH_SESSION_STATUS_AUTHENTICATED = 2,
    AUTH_SESSION_STATUS_INVALID_AUTH_SESSION = 3,
}

impl ::protobuf::ProtobufEnum for AuthSessionStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthSessionStatus> {
        match value {
            0 => ::std::option::Option::Some(AuthSessionStatus::AUTH_SESSION_STATUS_NOT_SET),
            1 => ::std::option::Option::Some(AuthSessionStatus::AUTH_SESSION_STATUS_FURTHER_FACTOR_REQUIRED),
            2 => ::std::option::Option::Some(AuthSessionStatus::AUTH_SESSION_STATUS_AUTHENTICATED),
            3 => ::std::option::Option::Some(AuthSessionStatus::AUTH_SESSION_STATUS_INVALID_AUTH_SESSION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AuthSessionStatus] = &[
            AuthSessionStatus::AUTH_SESSION_STATUS_NOT_SET,
            AuthSessionStatus::AUTH_SESSION_STATUS_FURTHER_FACTOR_REQUIRED,
            AuthSessionStatus::AUTH_SESSION_STATUS_AUTHENTICATED,
            AuthSessionStatus::AUTH_SESSION_STATUS_INVALID_AUTH_SESSION,
        ];
        values
    }
}

impl ::std::marker::Copy for AuthSessionStatus {
}

impl ::std::default::Default for AuthSessionStatus {
    fn default() -> Self {
        AuthSessionStatus::AUTH_SESSION_STATUS_NOT_SET
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthSessionStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum VaultEncryptionType {
    CRYPTOHOME_VAULT_ENCRYPTION_ANY = 0,
    CRYPTOHOME_VAULT_ENCRYPTION_ECRYPTFS = 1,
    CRYPTOHOME_VAULT_ENCRYPTION_FSCRYPT = 2,
    CRYPTOHOME_VAULT_ENCRYPTION_DMCRYPT = 3,
}

impl ::protobuf::ProtobufEnum for VaultEncryptionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VaultEncryptionType> {
        match value {
            0 => ::std::option::Option::Some(VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ANY),
            1 => ::std::option::Option::Some(VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ECRYPTFS),
            2 => ::std::option::Option::Some(VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_FSCRYPT),
            3 => ::std::option::Option::Some(VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_DMCRYPT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VaultEncryptionType] = &[
            VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ANY,
            VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ECRYPTFS,
            VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_FSCRYPT,
            VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_DMCRYPT,
        ];
        values
    }
}

impl ::std::marker::Copy for VaultEncryptionType {
}

impl ::std::default::Default for VaultEncryptionType {
    fn default() -> Self {
        VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ANY
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultEncryptionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum InstallAttributesState {
    UNKNOWN = 0,
    TPM_NOT_OWNED = 1,
    FIRST_INSTALL = 2,
    VALID = 3,
    INVALID = 4,
}

impl ::protobuf::ProtobufEnum for InstallAttributesState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InstallAttributesState> {
        match value {
            0 => ::std::option::Option::Some(InstallAttributesState::UNKNOWN),
            1 => ::std::option::Option::Some(InstallAttributesState::TPM_NOT_OWNED),
            2 => ::std::option::Option::Some(InstallAttributesState::FIRST_INSTALL),
            3 => ::std::option::Option::Some(InstallAttributesState::VALID),
            4 => ::std::option::Option::Some(InstallAttributesState::INVALID),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [InstallAttributesState] = &[
            InstallAttributesState::UNKNOWN,
            InstallAttributesState::TPM_NOT_OWNED,
            InstallAttributesState::FIRST_INSTALL,
            InstallAttributesState::VALID,
            InstallAttributesState::INVALID,
        ];
        values
    }
}

impl ::std::marker::Copy for InstallAttributesState {
}

impl ::std::default::Default for InstallAttributesState {
    fn default() -> Self {
        InstallAttributesState::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for InstallAttributesState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FingerprintScanResult {
    FINGERPRINT_SCAN_RESULT_SUCCESS = 0,
    FINGERPRINT_SCAN_RESULT_RETRY = 1,
    FINGERPRINT_SCAN_RESULT_LOCKOUT = 2,
    FINGERPRINT_SCAN_RESULT_FATAL_ERROR = 3,
}

impl ::protobuf::ProtobufEnum for FingerprintScanResult {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FingerprintScanResult> {
        match value {
            0 => ::std::option::Option::Some(FingerprintScanResult::FINGERPRINT_SCAN_RESULT_SUCCESS),
            1 => ::std::option::Option::Some(FingerprintScanResult::FINGERPRINT_SCAN_RESULT_RETRY),
            2 => ::std::option::Option::Some(FingerprintScanResult::FINGERPRINT_SCAN_RESULT_LOCKOUT),
            3 => ::std::option::Option::Some(FingerprintScanResult::FINGERPRINT_SCAN_RESULT_FATAL_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FingerprintScanResult] = &[
            FingerprintScanResult::FINGERPRINT_SCAN_RESULT_SUCCESS,
            FingerprintScanResult::FINGERPRINT_SCAN_RESULT_RETRY,
            FingerprintScanResult::FINGERPRINT_SCAN_RESULT_LOCKOUT,
            FingerprintScanResult::FINGERPRINT_SCAN_RESULT_FATAL_ERROR,
        ];
        values
    }
}

impl ::std::marker::Copy for FingerprintScanResult {
}

impl ::std::default::Default for FingerprintScanResult {
    fn default() -> Self {
        FingerprintScanResult::FINGERPRINT_SCAN_RESULT_SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for FingerprintScanResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}
