// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.21.9
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `fido.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cryptohome.fido.Url)
pub struct Url {
    // message fields
    // @@protoc_insertion_point(field:cryptohome.fido.Url.url)
    pub url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cryptohome.fido.Url.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Url {
    fn default() -> &'a Url {
        <Url as ::protobuf::Message>::default_instance()
    }
}

impl Url {
    pub fn new() -> Url {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Url {
    const NAME: &'static str = "Url";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Url {
        Url::new()
    }

    fn clear(&mut self) {
        self.url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Url {
        static instance: Url = Url {
            url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cryptohome.fido.CommonCredentialInfo)
pub struct CommonCredentialInfo {
    // message fields
    // @@protoc_insertion_point(field:cryptohome.fido.CommonCredentialInfo.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:cryptohome.fido.CommonCredentialInfo.raw_id)
    pub raw_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cryptohome.fido.CommonCredentialInfo.client_data_json)
    pub client_data_json: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:cryptohome.fido.CommonCredentialInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CommonCredentialInfo {
    fn default() -> &'a CommonCredentialInfo {
        <CommonCredentialInfo as ::protobuf::Message>::default_instance()
    }
}

impl CommonCredentialInfo {
    pub fn new() -> CommonCredentialInfo {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CommonCredentialInfo {
    const NAME: &'static str = "CommonCredentialInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.raw_id = is.read_bytes()?;
                },
                26 => {
                    self.client_data_json = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.raw_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.raw_id);
        }
        if !self.client_data_json.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.client_data_json);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.raw_id.is_empty() {
            os.write_bytes(2, &self.raw_id)?;
        }
        if !self.client_data_json.is_empty() {
            os.write_bytes(3, &self.client_data_json)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CommonCredentialInfo {
        CommonCredentialInfo::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.raw_id.clear();
        self.client_data_json.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CommonCredentialInfo {
        static instance: CommonCredentialInfo = CommonCredentialInfo {
            id: ::std::string::String::new(),
            raw_id: ::std::vec::Vec::new(),
            client_data_json: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cryptohome.fido.MakeCredentialAuthenticatorResponse)
pub struct MakeCredentialAuthenticatorResponse {
    // message fields
    // @@protoc_insertion_point(field:cryptohome.fido.MakeCredentialAuthenticatorResponse.info)
    pub info: ::protobuf::MessageField<CommonCredentialInfo>,
    // @@protoc_insertion_point(field:cryptohome.fido.MakeCredentialAuthenticatorResponse.attestation_object)
    pub attestation_object: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cryptohome.fido.MakeCredentialAuthenticatorResponse.transports)
    pub transports: ::std::vec::Vec<::protobuf::EnumOrUnknown<AuthenticatorTransport>>,
    // @@protoc_insertion_point(field:cryptohome.fido.MakeCredentialAuthenticatorResponse.echo_hmac_create_secret)
    pub echo_hmac_create_secret: bool,
    // @@protoc_insertion_point(field:cryptohome.fido.MakeCredentialAuthenticatorResponse.hmac_create_secret)
    pub hmac_create_secret: bool,
    // special fields
    // @@protoc_insertion_point(special_field:cryptohome.fido.MakeCredentialAuthenticatorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MakeCredentialAuthenticatorResponse {
    fn default() -> &'a MakeCredentialAuthenticatorResponse {
        <MakeCredentialAuthenticatorResponse as ::protobuf::Message>::default_instance()
    }
}

impl MakeCredentialAuthenticatorResponse {
    pub fn new() -> MakeCredentialAuthenticatorResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MakeCredentialAuthenticatorResponse {
    const NAME: &'static str = "MakeCredentialAuthenticatorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                18 => {
                    self.attestation_object = is.read_bytes()?;
                },
                24 => {
                    self.transports.push(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.transports)?
                },
                32 => {
                    self.echo_hmac_create_secret = is.read_bool()?;
                },
                40 => {
                    self.hmac_create_secret = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.attestation_object.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.attestation_object);
        }
        for value in &self.transports {
            my_size += ::protobuf::rt::int32_size(3, value.value());
        };
        if self.echo_hmac_create_secret != false {
            my_size += 1 + 1;
        }
        if self.hmac_create_secret != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.attestation_object.is_empty() {
            os.write_bytes(2, &self.attestation_object)?;
        }
        for v in &self.transports {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if self.echo_hmac_create_secret != false {
            os.write_bool(4, self.echo_hmac_create_secret)?;
        }
        if self.hmac_create_secret != false {
            os.write_bool(5, self.hmac_create_secret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MakeCredentialAuthenticatorResponse {
        MakeCredentialAuthenticatorResponse::new()
    }

    fn clear(&mut self) {
        self.info.clear();
        self.attestation_object.clear();
        self.transports.clear();
        self.echo_hmac_create_secret = false;
        self.hmac_create_secret = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MakeCredentialAuthenticatorResponse {
        static instance: MakeCredentialAuthenticatorResponse = MakeCredentialAuthenticatorResponse {
            info: ::protobuf::MessageField::none(),
            attestation_object: ::std::vec::Vec::new(),
            transports: ::std::vec::Vec::new(),
            echo_hmac_create_secret: false,
            hmac_create_secret: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cryptohome.fido.GetAssertionAuthenticatorResponse)
pub struct GetAssertionAuthenticatorResponse {
    // message fields
    // @@protoc_insertion_point(field:cryptohome.fido.GetAssertionAuthenticatorResponse.info)
    pub info: ::protobuf::MessageField<CommonCredentialInfo>,
    // @@protoc_insertion_point(field:cryptohome.fido.GetAssertionAuthenticatorResponse.authenticator_data)
    pub authenticator_data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cryptohome.fido.GetAssertionAuthenticatorResponse.signature)
    pub signature: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cryptohome.fido.GetAssertionAuthenticatorResponse.user_handle)
    pub user_handle: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cryptohome.fido.GetAssertionAuthenticatorResponse.echo_appid_extension)
    pub echo_appid_extension: bool,
    // @@protoc_insertion_point(field:cryptohome.fido.GetAssertionAuthenticatorResponse.appid_extension)
    pub appid_extension: bool,
    // special fields
    // @@protoc_insertion_point(special_field:cryptohome.fido.GetAssertionAuthenticatorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAssertionAuthenticatorResponse {
    fn default() -> &'a GetAssertionAuthenticatorResponse {
        <GetAssertionAuthenticatorResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAssertionAuthenticatorResponse {
    pub fn new() -> GetAssertionAuthenticatorResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetAssertionAuthenticatorResponse {
    const NAME: &'static str = "GetAssertionAuthenticatorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                18 => {
                    self.authenticator_data = is.read_bytes()?;
                },
                26 => {
                    self.signature = is.read_bytes()?;
                },
                34 => {
                    self.user_handle = is.read_bytes()?;
                },
                40 => {
                    self.echo_appid_extension = is.read_bool()?;
                },
                48 => {
                    self.appid_extension = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.authenticator_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.authenticator_data);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.signature);
        }
        if !self.user_handle.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.user_handle);
        }
        if self.echo_appid_extension != false {
            my_size += 1 + 1;
        }
        if self.appid_extension != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.authenticator_data.is_empty() {
            os.write_bytes(2, &self.authenticator_data)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(3, &self.signature)?;
        }
        if !self.user_handle.is_empty() {
            os.write_bytes(4, &self.user_handle)?;
        }
        if self.echo_appid_extension != false {
            os.write_bool(5, self.echo_appid_extension)?;
        }
        if self.appid_extension != false {
            os.write_bool(6, self.appid_extension)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAssertionAuthenticatorResponse {
        GetAssertionAuthenticatorResponse::new()
    }

    fn clear(&mut self) {
        self.info.clear();
        self.authenticator_data.clear();
        self.signature.clear();
        self.user_handle.clear();
        self.echo_appid_extension = false;
        self.appid_extension = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAssertionAuthenticatorResponse {
        static instance: GetAssertionAuthenticatorResponse = GetAssertionAuthenticatorResponse {
            info: ::protobuf::MessageField::none(),
            authenticator_data: ::std::vec::Vec::new(),
            signature: ::std::vec::Vec::new(),
            user_handle: ::std::vec::Vec::new(),
            echo_appid_extension: false,
            appid_extension: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cryptohome.fido.PublicKeyCredentialRpEntity)
pub struct PublicKeyCredentialRpEntity {
    // message fields
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialRpEntity.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialRpEntity.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialRpEntity.icon)
    pub icon: ::protobuf::MessageField<Url>,
    // special fields
    // @@protoc_insertion_point(special_field:cryptohome.fido.PublicKeyCredentialRpEntity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PublicKeyCredentialRpEntity {
    fn default() -> &'a PublicKeyCredentialRpEntity {
        <PublicKeyCredentialRpEntity as ::protobuf::Message>::default_instance()
    }
}

impl PublicKeyCredentialRpEntity {
    pub fn new() -> PublicKeyCredentialRpEntity {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PublicKeyCredentialRpEntity {
    const NAME: &'static str = "PublicKeyCredentialRpEntity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.icon)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(v) = self.icon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(v) = self.icon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PublicKeyCredentialRpEntity {
        PublicKeyCredentialRpEntity::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.icon.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PublicKeyCredentialRpEntity {
        static instance: PublicKeyCredentialRpEntity = PublicKeyCredentialRpEntity {
            id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            icon: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cryptohome.fido.PublicKeyCredentialUserEntity)
pub struct PublicKeyCredentialUserEntity {
    // message fields
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialUserEntity.id)
    pub id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialUserEntity.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialUserEntity.icon)
    pub icon: ::protobuf::MessageField<Url>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialUserEntity.display_name)
    pub display_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cryptohome.fido.PublicKeyCredentialUserEntity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PublicKeyCredentialUserEntity {
    fn default() -> &'a PublicKeyCredentialUserEntity {
        <PublicKeyCredentialUserEntity as ::protobuf::Message>::default_instance()
    }
}

impl PublicKeyCredentialUserEntity {
    pub fn new() -> PublicKeyCredentialUserEntity {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PublicKeyCredentialUserEntity {
    const NAME: &'static str = "PublicKeyCredentialUserEntity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_bytes()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.icon)?;
                },
                34 => {
                    self.display_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(v) = self.icon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.display_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_bytes(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(v) = self.icon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(4, &self.display_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PublicKeyCredentialUserEntity {
        PublicKeyCredentialUserEntity::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.icon.clear();
        self.display_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PublicKeyCredentialUserEntity {
        static instance: PublicKeyCredentialUserEntity = PublicKeyCredentialUserEntity {
            id: ::std::vec::Vec::new(),
            name: ::std::string::String::new(),
            icon: ::protobuf::MessageField::none(),
            display_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cryptohome.fido.PublicKeyCredentialParameters)
pub struct PublicKeyCredentialParameters {
    // message fields
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialParameters.type)
    pub type_: ::protobuf::EnumOrUnknown<PublicKeyCredentialType>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialParameters.algorithm_identifier)
    pub algorithm_identifier: i32,
    // special fields
    // @@protoc_insertion_point(special_field:cryptohome.fido.PublicKeyCredentialParameters.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PublicKeyCredentialParameters {
    fn default() -> &'a PublicKeyCredentialParameters {
        <PublicKeyCredentialParameters as ::protobuf::Message>::default_instance()
    }
}

impl PublicKeyCredentialParameters {
    pub fn new() -> PublicKeyCredentialParameters {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PublicKeyCredentialParameters {
    const NAME: &'static str = "PublicKeyCredentialParameters";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.algorithm_identifier = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(PublicKeyCredentialType::PUBLIC_KEY) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if self.algorithm_identifier != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.algorithm_identifier);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(PublicKeyCredentialType::PUBLIC_KEY) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.algorithm_identifier != 0 {
            os.write_int32(2, self.algorithm_identifier)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PublicKeyCredentialParameters {
        PublicKeyCredentialParameters::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(PublicKeyCredentialType::PUBLIC_KEY);
        self.algorithm_identifier = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PublicKeyCredentialParameters {
        static instance: PublicKeyCredentialParameters = PublicKeyCredentialParameters {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            algorithm_identifier: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cryptohome.fido.CableAuthentication)
pub struct CableAuthentication {
    // message fields
    // @@protoc_insertion_point(field:cryptohome.fido.CableAuthentication.version)
    pub version: u32,
    // @@protoc_insertion_point(field:cryptohome.fido.CableAuthentication.client_eid)
    pub client_eid: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cryptohome.fido.CableAuthentication.authenticator_eid)
    pub authenticator_eid: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cryptohome.fido.CableAuthentication.session_pre_key)
    pub session_pre_key: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:cryptohome.fido.CableAuthentication.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CableAuthentication {
    fn default() -> &'a CableAuthentication {
        <CableAuthentication as ::protobuf::Message>::default_instance()
    }
}

impl CableAuthentication {
    pub fn new() -> CableAuthentication {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CableAuthentication {
    const NAME: &'static str = "CableAuthentication";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = is.read_uint32()?;
                },
                18 => {
                    self.client_eid = is.read_bytes()?;
                },
                26 => {
                    self.authenticator_eid = is.read_bytes()?;
                },
                34 => {
                    self.session_pre_key = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.version != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.version);
        }
        if !self.client_eid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.client_eid);
        }
        if !self.authenticator_eid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.authenticator_eid);
        }
        if !self.session_pre_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.session_pre_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.version != 0 {
            os.write_uint32(1, self.version)?;
        }
        if !self.client_eid.is_empty() {
            os.write_bytes(2, &self.client_eid)?;
        }
        if !self.authenticator_eid.is_empty() {
            os.write_bytes(3, &self.authenticator_eid)?;
        }
        if !self.session_pre_key.is_empty() {
            os.write_bytes(4, &self.session_pre_key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CableAuthentication {
        CableAuthentication::new()
    }

    fn clear(&mut self) {
        self.version = 0;
        self.client_eid.clear();
        self.authenticator_eid.clear();
        self.session_pre_key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CableAuthentication {
        static instance: CableAuthentication = CableAuthentication {
            version: 0,
            client_eid: ::std::vec::Vec::new(),
            authenticator_eid: ::std::vec::Vec::new(),
            session_pre_key: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cryptohome.fido.CableRegistration)
pub struct CableRegistration {
    // message fields
    // @@protoc_insertion_point(field:cryptohome.fido.CableRegistration.versions)
    pub versions: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cryptohome.fido.CableRegistration.relying_party_public_key)
    pub relying_party_public_key: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:cryptohome.fido.CableRegistration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CableRegistration {
    fn default() -> &'a CableRegistration {
        <CableRegistration as ::protobuf::Message>::default_instance()
    }
}

impl CableRegistration {
    pub fn new() -> CableRegistration {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CableRegistration {
    const NAME: &'static str = "CableRegistration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.versions = is.read_bytes()?;
                },
                18 => {
                    self.relying_party_public_key = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.versions.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.versions);
        }
        if !self.relying_party_public_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.relying_party_public_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.versions.is_empty() {
            os.write_bytes(1, &self.versions)?;
        }
        if !self.relying_party_public_key.is_empty() {
            os.write_bytes(2, &self.relying_party_public_key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CableRegistration {
        CableRegistration::new()
    }

    fn clear(&mut self) {
        self.versions.clear();
        self.relying_party_public_key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CableRegistration {
        static instance: CableRegistration = CableRegistration {
            versions: ::std::vec::Vec::new(),
            relying_party_public_key: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cryptohome.fido.PublicKeyCredentialRequestOptions)
pub struct PublicKeyCredentialRequestOptions {
    // message fields
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialRequestOptions.challenge)
    pub challenge: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialRequestOptions.adjusted_timeout)
    pub adjusted_timeout: i64,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialRequestOptions.relying_party_id)
    pub relying_party_id: ::std::string::String,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialRequestOptions.allow_credentials)
    pub allow_credentials: ::std::vec::Vec<PublicKeyCredentialDescriptor>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialRequestOptions.user_verification)
    pub user_verification: ::protobuf::EnumOrUnknown<UserVerificationRequirement>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialRequestOptions.appid)
    pub appid: ::std::string::String,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialRequestOptions.cable_authentication_data)
    pub cable_authentication_data: ::std::vec::Vec<CableAuthentication>,
    // special fields
    // @@protoc_insertion_point(special_field:cryptohome.fido.PublicKeyCredentialRequestOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PublicKeyCredentialRequestOptions {
    fn default() -> &'a PublicKeyCredentialRequestOptions {
        <PublicKeyCredentialRequestOptions as ::protobuf::Message>::default_instance()
    }
}

impl PublicKeyCredentialRequestOptions {
    pub fn new() -> PublicKeyCredentialRequestOptions {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PublicKeyCredentialRequestOptions {
    const NAME: &'static str = "PublicKeyCredentialRequestOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.challenge = is.read_bytes()?;
                },
                16 => {
                    self.adjusted_timeout = is.read_int64()?;
                },
                26 => {
                    self.relying_party_id = is.read_string()?;
                },
                34 => {
                    self.allow_credentials.push(is.read_message()?);
                },
                40 => {
                    self.user_verification = is.read_enum_or_unknown()?;
                },
                50 => {
                    self.appid = is.read_string()?;
                },
                58 => {
                    self.cable_authentication_data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.challenge.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.challenge);
        }
        if self.adjusted_timeout != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.adjusted_timeout);
        }
        if !self.relying_party_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.relying_party_id);
        }
        for value in &self.allow_credentials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.user_verification != ::protobuf::EnumOrUnknown::new(UserVerificationRequirement::REQUIRED) {
            my_size += ::protobuf::rt::int32_size(5, self.user_verification.value());
        }
        if !self.appid.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.appid);
        }
        for value in &self.cable_authentication_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.challenge.is_empty() {
            os.write_bytes(1, &self.challenge)?;
        }
        if self.adjusted_timeout != 0 {
            os.write_int64(2, self.adjusted_timeout)?;
        }
        if !self.relying_party_id.is_empty() {
            os.write_string(3, &self.relying_party_id)?;
        }
        for v in &self.allow_credentials {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if self.user_verification != ::protobuf::EnumOrUnknown::new(UserVerificationRequirement::REQUIRED) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.user_verification))?;
        }
        if !self.appid.is_empty() {
            os.write_string(6, &self.appid)?;
        }
        for v in &self.cable_authentication_data {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PublicKeyCredentialRequestOptions {
        PublicKeyCredentialRequestOptions::new()
    }

    fn clear(&mut self) {
        self.challenge.clear();
        self.adjusted_timeout = 0;
        self.relying_party_id.clear();
        self.allow_credentials.clear();
        self.user_verification = ::protobuf::EnumOrUnknown::new(UserVerificationRequirement::REQUIRED);
        self.appid.clear();
        self.cable_authentication_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PublicKeyCredentialRequestOptions {
        static instance: PublicKeyCredentialRequestOptions = PublicKeyCredentialRequestOptions {
            challenge: ::std::vec::Vec::new(),
            adjusted_timeout: 0,
            relying_party_id: ::std::string::String::new(),
            allow_credentials: ::std::vec::Vec::new(),
            user_verification: ::protobuf::EnumOrUnknown::from_i32(0),
            appid: ::std::string::String::new(),
            cable_authentication_data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cryptohome.fido.AuthenticatorSelectionCriteria)
pub struct AuthenticatorSelectionCriteria {
    // message fields
    // @@protoc_insertion_point(field:cryptohome.fido.AuthenticatorSelectionCriteria.authenticator_attachment)
    pub authenticator_attachment: ::protobuf::EnumOrUnknown<AuthenticatorAttachment>,
    // @@protoc_insertion_point(field:cryptohome.fido.AuthenticatorSelectionCriteria.require_resident_key)
    pub require_resident_key: bool,
    // @@protoc_insertion_point(field:cryptohome.fido.AuthenticatorSelectionCriteria.user_verification)
    pub user_verification: ::protobuf::EnumOrUnknown<UserVerificationRequirement>,
    // special fields
    // @@protoc_insertion_point(special_field:cryptohome.fido.AuthenticatorSelectionCriteria.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthenticatorSelectionCriteria {
    fn default() -> &'a AuthenticatorSelectionCriteria {
        <AuthenticatorSelectionCriteria as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticatorSelectionCriteria {
    pub fn new() -> AuthenticatorSelectionCriteria {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthenticatorSelectionCriteria {
    const NAME: &'static str = "AuthenticatorSelectionCriteria";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.authenticator_attachment = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.require_resident_key = is.read_bool()?;
                },
                24 => {
                    self.user_verification = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.authenticator_attachment != ::protobuf::EnumOrUnknown::new(AuthenticatorAttachment::NO_PREFERENCE) {
            my_size += ::protobuf::rt::int32_size(1, self.authenticator_attachment.value());
        }
        if self.require_resident_key != false {
            my_size += 1 + 1;
        }
        if self.user_verification != ::protobuf::EnumOrUnknown::new(UserVerificationRequirement::REQUIRED) {
            my_size += ::protobuf::rt::int32_size(3, self.user_verification.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.authenticator_attachment != ::protobuf::EnumOrUnknown::new(AuthenticatorAttachment::NO_PREFERENCE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.authenticator_attachment))?;
        }
        if self.require_resident_key != false {
            os.write_bool(2, self.require_resident_key)?;
        }
        if self.user_verification != ::protobuf::EnumOrUnknown::new(UserVerificationRequirement::REQUIRED) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.user_verification))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthenticatorSelectionCriteria {
        AuthenticatorSelectionCriteria::new()
    }

    fn clear(&mut self) {
        self.authenticator_attachment = ::protobuf::EnumOrUnknown::new(AuthenticatorAttachment::NO_PREFERENCE);
        self.require_resident_key = false;
        self.user_verification = ::protobuf::EnumOrUnknown::new(UserVerificationRequirement::REQUIRED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthenticatorSelectionCriteria {
        static instance: AuthenticatorSelectionCriteria = AuthenticatorSelectionCriteria {
            authenticator_attachment: ::protobuf::EnumOrUnknown::from_i32(0),
            require_resident_key: false,
            user_verification: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cryptohome.fido.PublicKeyCredentialCreationOptions)
pub struct PublicKeyCredentialCreationOptions {
    // message fields
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialCreationOptions.relying_party)
    pub relying_party: ::protobuf::MessageField<PublicKeyCredentialRpEntity>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialCreationOptions.user)
    pub user: ::protobuf::MessageField<PublicKeyCredentialUserEntity>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialCreationOptions.challenge)
    pub challenge: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialCreationOptions.public_key_parameters)
    pub public_key_parameters: ::std::vec::Vec<PublicKeyCredentialParameters>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialCreationOptions.adjusted_timeout)
    pub adjusted_timeout: i64,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialCreationOptions.exclude_credentials)
    pub exclude_credentials: ::std::vec::Vec<PublicKeyCredentialDescriptor>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialCreationOptions.authenticator_selection)
    pub authenticator_selection: ::protobuf::MessageField<AuthenticatorSelectionCriteria>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialCreationOptions.attestation)
    pub attestation: ::protobuf::EnumOrUnknown<AttestationConveyancePreference>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialCreationOptions.cable_registration_data)
    pub cable_registration_data: ::protobuf::MessageField<CableRegistration>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialCreationOptions.hmac_create_secret)
    pub hmac_create_secret: bool,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialCreationOptions.protection_policy)
    pub protection_policy: ::protobuf::EnumOrUnknown<ProtectionPolicy>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialCreationOptions.enforce_protection_policy)
    pub enforce_protection_policy: bool,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialCreationOptions.appid_exclude)
    pub appid_exclude: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:cryptohome.fido.PublicKeyCredentialCreationOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PublicKeyCredentialCreationOptions {
    fn default() -> &'a PublicKeyCredentialCreationOptions {
        <PublicKeyCredentialCreationOptions as ::protobuf::Message>::default_instance()
    }
}

impl PublicKeyCredentialCreationOptions {
    pub fn new() -> PublicKeyCredentialCreationOptions {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PublicKeyCredentialCreationOptions {
    const NAME: &'static str = "PublicKeyCredentialCreationOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.relying_party)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.user)?;
                },
                26 => {
                    self.challenge = is.read_bytes()?;
                },
                34 => {
                    self.public_key_parameters.push(is.read_message()?);
                },
                40 => {
                    self.adjusted_timeout = is.read_int64()?;
                },
                50 => {
                    self.exclude_credentials.push(is.read_message()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.authenticator_selection)?;
                },
                64 => {
                    self.attestation = is.read_enum_or_unknown()?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cable_registration_data)?;
                },
                80 => {
                    self.hmac_create_secret = is.read_bool()?;
                },
                88 => {
                    self.protection_policy = is.read_enum_or_unknown()?;
                },
                96 => {
                    self.enforce_protection_policy = is.read_bool()?;
                },
                106 => {
                    self.appid_exclude = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.relying_party.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.challenge.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.challenge);
        }
        for value in &self.public_key_parameters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.adjusted_timeout != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.adjusted_timeout);
        }
        for value in &self.exclude_credentials {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.authenticator_selection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.attestation != ::protobuf::EnumOrUnknown::new(AttestationConveyancePreference::NONE_ATTESTATION_PREFERENCE) {
            my_size += ::protobuf::rt::int32_size(8, self.attestation.value());
        }
        if let Some(v) = self.cable_registration_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.hmac_create_secret != false {
            my_size += 1 + 1;
        }
        if self.protection_policy != ::protobuf::EnumOrUnknown::new(ProtectionPolicy::UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(11, self.protection_policy.value());
        }
        if self.enforce_protection_policy != false {
            my_size += 1 + 1;
        }
        if !self.appid_exclude.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.appid_exclude);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.relying_party.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.challenge.is_empty() {
            os.write_bytes(3, &self.challenge)?;
        }
        for v in &self.public_key_parameters {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if self.adjusted_timeout != 0 {
            os.write_int64(5, self.adjusted_timeout)?;
        }
        for v in &self.exclude_credentials {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.authenticator_selection.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if self.attestation != ::protobuf::EnumOrUnknown::new(AttestationConveyancePreference::NONE_ATTESTATION_PREFERENCE) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.attestation))?;
        }
        if let Some(v) = self.cable_registration_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if self.hmac_create_secret != false {
            os.write_bool(10, self.hmac_create_secret)?;
        }
        if self.protection_policy != ::protobuf::EnumOrUnknown::new(ProtectionPolicy::UNSPECIFIED) {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.protection_policy))?;
        }
        if self.enforce_protection_policy != false {
            os.write_bool(12, self.enforce_protection_policy)?;
        }
        if !self.appid_exclude.is_empty() {
            os.write_string(13, &self.appid_exclude)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PublicKeyCredentialCreationOptions {
        PublicKeyCredentialCreationOptions::new()
    }

    fn clear(&mut self) {
        self.relying_party.clear();
        self.user.clear();
        self.challenge.clear();
        self.public_key_parameters.clear();
        self.adjusted_timeout = 0;
        self.exclude_credentials.clear();
        self.authenticator_selection.clear();
        self.attestation = ::protobuf::EnumOrUnknown::new(AttestationConveyancePreference::NONE_ATTESTATION_PREFERENCE);
        self.cable_registration_data.clear();
        self.hmac_create_secret = false;
        self.protection_policy = ::protobuf::EnumOrUnknown::new(ProtectionPolicy::UNSPECIFIED);
        self.enforce_protection_policy = false;
        self.appid_exclude.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PublicKeyCredentialCreationOptions {
        static instance: PublicKeyCredentialCreationOptions = PublicKeyCredentialCreationOptions {
            relying_party: ::protobuf::MessageField::none(),
            user: ::protobuf::MessageField::none(),
            challenge: ::std::vec::Vec::new(),
            public_key_parameters: ::std::vec::Vec::new(),
            adjusted_timeout: 0,
            exclude_credentials: ::std::vec::Vec::new(),
            authenticator_selection: ::protobuf::MessageField::none(),
            attestation: ::protobuf::EnumOrUnknown::from_i32(0),
            cable_registration_data: ::protobuf::MessageField::none(),
            hmac_create_secret: false,
            protection_policy: ::protobuf::EnumOrUnknown::from_i32(0),
            enforce_protection_policy: false,
            appid_exclude: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:cryptohome.fido.PublicKeyCredentialDescriptor)
pub struct PublicKeyCredentialDescriptor {
    // message fields
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialDescriptor.type)
    pub type_: ::protobuf::EnumOrUnknown<PublicKeyCredentialType>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialDescriptor.id)
    pub id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:cryptohome.fido.PublicKeyCredentialDescriptor.transports)
    pub transports: ::std::vec::Vec<::protobuf::EnumOrUnknown<AuthenticatorTransport>>,
    // special fields
    // @@protoc_insertion_point(special_field:cryptohome.fido.PublicKeyCredentialDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PublicKeyCredentialDescriptor {
    fn default() -> &'a PublicKeyCredentialDescriptor {
        <PublicKeyCredentialDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl PublicKeyCredentialDescriptor {
    pub fn new() -> PublicKeyCredentialDescriptor {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PublicKeyCredentialDescriptor {
    const NAME: &'static str = "PublicKeyCredentialDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.id = is.read_bytes()?;
                },
                24 => {
                    self.transports.push(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.transports)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(PublicKeyCredentialType::PUBLIC_KEY) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.id);
        }
        for value in &self.transports {
            my_size += ::protobuf::rt::int32_size(3, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(PublicKeyCredentialType::PUBLIC_KEY) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.id.is_empty() {
            os.write_bytes(2, &self.id)?;
        }
        for v in &self.transports {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PublicKeyCredentialDescriptor {
        PublicKeyCredentialDescriptor::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(PublicKeyCredentialType::PUBLIC_KEY);
        self.id.clear();
        self.transports.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PublicKeyCredentialDescriptor {
        static instance: PublicKeyCredentialDescriptor = PublicKeyCredentialDescriptor {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            id: ::std::vec::Vec::new(),
            transports: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:cryptohome.fido.AuthenticatorStatus)
pub enum AuthenticatorStatus {
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.SUCCESS)
    SUCCESS = 0,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.PENDING_REQUEST)
    PENDING_REQUEST = 1,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.NOT_ALLOWED_ERROR)
    NOT_ALLOWED_ERROR = 2,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.INVALID_DOMAIN)
    INVALID_DOMAIN = 3,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.INVALID_ICON_URL)
    INVALID_ICON_URL = 4,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.CREDENTIAL_EXCLUDED)
    CREDENTIAL_EXCLUDED = 5,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.CREDENTIAL_NOT_RECOGNIZED)
    CREDENTIAL_NOT_RECOGNIZED = 6,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.NOT_IMPLEMENTED)
    NOT_IMPLEMENTED = 7,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.NOT_FOCUSED)
    NOT_FOCUSED = 8,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.RESIDENT_CREDENTIALS_UNSUPPORTED)
    RESIDENT_CREDENTIALS_UNSUPPORTED = 9,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.USER_VERIFICATION_UNSUPPORTED)
    USER_VERIFICATION_UNSUPPORTED = 10,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.ALGORITHM_UNSUPPORTED)
    ALGORITHM_UNSUPPORTED = 11,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.EMPTY_ALLOW_CREDENTIALS)
    EMPTY_ALLOW_CREDENTIALS = 12,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.ANDROID_NOT_SUPPORTED_ERROR)
    ANDROID_NOT_SUPPORTED_ERROR = 13,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.PROTECTION_POLICY_INCONSISTENT)
    PROTECTION_POLICY_INCONSISTENT = 14,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.ABORT_ERROR)
    ABORT_ERROR = 15,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.OPAQUE_DOMAIN)
    OPAQUE_DOMAIN = 16,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.INVALID_PROTOCOL)
    INVALID_PROTOCOL = 17,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.BAD_RELYING_PARTY_ID)
    BAD_RELYING_PARTY_ID = 18,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorStatus.UNKNOWN_ERROR)
    UNKNOWN_ERROR = 19,
}

impl ::protobuf::Enum for AuthenticatorStatus {
    const NAME: &'static str = "AuthenticatorStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthenticatorStatus> {
        match value {
            0 => ::std::option::Option::Some(AuthenticatorStatus::SUCCESS),
            1 => ::std::option::Option::Some(AuthenticatorStatus::PENDING_REQUEST),
            2 => ::std::option::Option::Some(AuthenticatorStatus::NOT_ALLOWED_ERROR),
            3 => ::std::option::Option::Some(AuthenticatorStatus::INVALID_DOMAIN),
            4 => ::std::option::Option::Some(AuthenticatorStatus::INVALID_ICON_URL),
            5 => ::std::option::Option::Some(AuthenticatorStatus::CREDENTIAL_EXCLUDED),
            6 => ::std::option::Option::Some(AuthenticatorStatus::CREDENTIAL_NOT_RECOGNIZED),
            7 => ::std::option::Option::Some(AuthenticatorStatus::NOT_IMPLEMENTED),
            8 => ::std::option::Option::Some(AuthenticatorStatus::NOT_FOCUSED),
            9 => ::std::option::Option::Some(AuthenticatorStatus::RESIDENT_CREDENTIALS_UNSUPPORTED),
            10 => ::std::option::Option::Some(AuthenticatorStatus::USER_VERIFICATION_UNSUPPORTED),
            11 => ::std::option::Option::Some(AuthenticatorStatus::ALGORITHM_UNSUPPORTED),
            12 => ::std::option::Option::Some(AuthenticatorStatus::EMPTY_ALLOW_CREDENTIALS),
            13 => ::std::option::Option::Some(AuthenticatorStatus::ANDROID_NOT_SUPPORTED_ERROR),
            14 => ::std::option::Option::Some(AuthenticatorStatus::PROTECTION_POLICY_INCONSISTENT),
            15 => ::std::option::Option::Some(AuthenticatorStatus::ABORT_ERROR),
            16 => ::std::option::Option::Some(AuthenticatorStatus::OPAQUE_DOMAIN),
            17 => ::std::option::Option::Some(AuthenticatorStatus::INVALID_PROTOCOL),
            18 => ::std::option::Option::Some(AuthenticatorStatus::BAD_RELYING_PARTY_ID),
            19 => ::std::option::Option::Some(AuthenticatorStatus::UNKNOWN_ERROR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AuthenticatorStatus] = &[
        AuthenticatorStatus::SUCCESS,
        AuthenticatorStatus::PENDING_REQUEST,
        AuthenticatorStatus::NOT_ALLOWED_ERROR,
        AuthenticatorStatus::INVALID_DOMAIN,
        AuthenticatorStatus::INVALID_ICON_URL,
        AuthenticatorStatus::CREDENTIAL_EXCLUDED,
        AuthenticatorStatus::CREDENTIAL_NOT_RECOGNIZED,
        AuthenticatorStatus::NOT_IMPLEMENTED,
        AuthenticatorStatus::NOT_FOCUSED,
        AuthenticatorStatus::RESIDENT_CREDENTIALS_UNSUPPORTED,
        AuthenticatorStatus::USER_VERIFICATION_UNSUPPORTED,
        AuthenticatorStatus::ALGORITHM_UNSUPPORTED,
        AuthenticatorStatus::EMPTY_ALLOW_CREDENTIALS,
        AuthenticatorStatus::ANDROID_NOT_SUPPORTED_ERROR,
        AuthenticatorStatus::PROTECTION_POLICY_INCONSISTENT,
        AuthenticatorStatus::ABORT_ERROR,
        AuthenticatorStatus::OPAQUE_DOMAIN,
        AuthenticatorStatus::INVALID_PROTOCOL,
        AuthenticatorStatus::BAD_RELYING_PARTY_ID,
        AuthenticatorStatus::UNKNOWN_ERROR,
    ];
}

impl ::std::default::Default for AuthenticatorStatus {
    fn default() -> Self {
        AuthenticatorStatus::SUCCESS
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:cryptohome.fido.AuthenticatorTransport)
pub enum AuthenticatorTransport {
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorTransport.USB)
    USB = 0,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorTransport.NFC)
    NFC = 1,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorTransport.BLE)
    BLE = 2,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorTransport.CABLE)
    CABLE = 3,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorTransport.INTERNAL)
    INTERNAL = 4,
}

impl ::protobuf::Enum for AuthenticatorTransport {
    const NAME: &'static str = "AuthenticatorTransport";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthenticatorTransport> {
        match value {
            0 => ::std::option::Option::Some(AuthenticatorTransport::USB),
            1 => ::std::option::Option::Some(AuthenticatorTransport::NFC),
            2 => ::std::option::Option::Some(AuthenticatorTransport::BLE),
            3 => ::std::option::Option::Some(AuthenticatorTransport::CABLE),
            4 => ::std::option::Option::Some(AuthenticatorTransport::INTERNAL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AuthenticatorTransport] = &[
        AuthenticatorTransport::USB,
        AuthenticatorTransport::NFC,
        AuthenticatorTransport::BLE,
        AuthenticatorTransport::CABLE,
        AuthenticatorTransport::INTERNAL,
    ];
}

impl ::std::default::Default for AuthenticatorTransport {
    fn default() -> Self {
        AuthenticatorTransport::USB
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:cryptohome.fido.UserVerificationRequirement)
pub enum UserVerificationRequirement {
    // @@protoc_insertion_point(enum_value:cryptohome.fido.UserVerificationRequirement.REQUIRED)
    REQUIRED = 0,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.UserVerificationRequirement.PREFERRED)
    PREFERRED = 1,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.UserVerificationRequirement.DISCOURAGED)
    DISCOURAGED = 2,
}

impl ::protobuf::Enum for UserVerificationRequirement {
    const NAME: &'static str = "UserVerificationRequirement";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UserVerificationRequirement> {
        match value {
            0 => ::std::option::Option::Some(UserVerificationRequirement::REQUIRED),
            1 => ::std::option::Option::Some(UserVerificationRequirement::PREFERRED),
            2 => ::std::option::Option::Some(UserVerificationRequirement::DISCOURAGED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [UserVerificationRequirement] = &[
        UserVerificationRequirement::REQUIRED,
        UserVerificationRequirement::PREFERRED,
        UserVerificationRequirement::DISCOURAGED,
    ];
}

impl ::std::default::Default for UserVerificationRequirement {
    fn default() -> Self {
        UserVerificationRequirement::REQUIRED
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:cryptohome.fido.AttestationConveyancePreference)
pub enum AttestationConveyancePreference {
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AttestationConveyancePreference.NONE_ATTESTATION_PREFERENCE)
    NONE_ATTESTATION_PREFERENCE = 0,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AttestationConveyancePreference.INDIRECT)
    INDIRECT = 1,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AttestationConveyancePreference.DIRECT)
    DIRECT = 2,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AttestationConveyancePreference.ENTERPRISE)
    ENTERPRISE = 3,
}

impl ::protobuf::Enum for AttestationConveyancePreference {
    const NAME: &'static str = "AttestationConveyancePreference";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AttestationConveyancePreference> {
        match value {
            0 => ::std::option::Option::Some(AttestationConveyancePreference::NONE_ATTESTATION_PREFERENCE),
            1 => ::std::option::Option::Some(AttestationConveyancePreference::INDIRECT),
            2 => ::std::option::Option::Some(AttestationConveyancePreference::DIRECT),
            3 => ::std::option::Option::Some(AttestationConveyancePreference::ENTERPRISE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AttestationConveyancePreference] = &[
        AttestationConveyancePreference::NONE_ATTESTATION_PREFERENCE,
        AttestationConveyancePreference::INDIRECT,
        AttestationConveyancePreference::DIRECT,
        AttestationConveyancePreference::ENTERPRISE,
    ];
}

impl ::std::default::Default for AttestationConveyancePreference {
    fn default() -> Self {
        AttestationConveyancePreference::NONE_ATTESTATION_PREFERENCE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:cryptohome.fido.AuthenticatorAttachment)
pub enum AuthenticatorAttachment {
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorAttachment.NO_PREFERENCE)
    NO_PREFERENCE = 0,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorAttachment.PLATFORM)
    PLATFORM = 1,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.AuthenticatorAttachment.CROSS_PLATFORM)
    CROSS_PLATFORM = 2,
}

impl ::protobuf::Enum for AuthenticatorAttachment {
    const NAME: &'static str = "AuthenticatorAttachment";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthenticatorAttachment> {
        match value {
            0 => ::std::option::Option::Some(AuthenticatorAttachment::NO_PREFERENCE),
            1 => ::std::option::Option::Some(AuthenticatorAttachment::PLATFORM),
            2 => ::std::option::Option::Some(AuthenticatorAttachment::CROSS_PLATFORM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AuthenticatorAttachment] = &[
        AuthenticatorAttachment::NO_PREFERENCE,
        AuthenticatorAttachment::PLATFORM,
        AuthenticatorAttachment::CROSS_PLATFORM,
    ];
}

impl ::std::default::Default for AuthenticatorAttachment {
    fn default() -> Self {
        AuthenticatorAttachment::NO_PREFERENCE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:cryptohome.fido.ProtectionPolicy)
pub enum ProtectionPolicy {
    // @@protoc_insertion_point(enum_value:cryptohome.fido.ProtectionPolicy.UNSPECIFIED)
    UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.ProtectionPolicy.NONE_PROTECTION_POLICY)
    NONE_PROTECTION_POLICY = 1,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.ProtectionPolicy.UV_OR_CRED_ID_REQUIRED)
    UV_OR_CRED_ID_REQUIRED = 2,
    // @@protoc_insertion_point(enum_value:cryptohome.fido.ProtectionPolicy.UV_REQUIRED)
    UV_REQUIRED = 3,
}

impl ::protobuf::Enum for ProtectionPolicy {
    const NAME: &'static str = "ProtectionPolicy";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtectionPolicy> {
        match value {
            0 => ::std::option::Option::Some(ProtectionPolicy::UNSPECIFIED),
            1 => ::std::option::Option::Some(ProtectionPolicy::NONE_PROTECTION_POLICY),
            2 => ::std::option::Option::Some(ProtectionPolicy::UV_OR_CRED_ID_REQUIRED),
            3 => ::std::option::Option::Some(ProtectionPolicy::UV_REQUIRED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtectionPolicy] = &[
        ProtectionPolicy::UNSPECIFIED,
        ProtectionPolicy::NONE_PROTECTION_POLICY,
        ProtectionPolicy::UV_OR_CRED_ID_REQUIRED,
        ProtectionPolicy::UV_REQUIRED,
    ];
}

impl ::std::default::Default for ProtectionPolicy {
    fn default() -> Self {
        ProtectionPolicy::UNSPECIFIED
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:cryptohome.fido.PublicKeyCredentialType)
pub enum PublicKeyCredentialType {
    // @@protoc_insertion_point(enum_value:cryptohome.fido.PublicKeyCredentialType.PUBLIC_KEY)
    PUBLIC_KEY = 0,
}

impl ::protobuf::Enum for PublicKeyCredentialType {
    const NAME: &'static str = "PublicKeyCredentialType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PublicKeyCredentialType> {
        match value {
            0 => ::std::option::Option::Some(PublicKeyCredentialType::PUBLIC_KEY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PublicKeyCredentialType] = &[
        PublicKeyCredentialType::PUBLIC_KEY,
    ];
}

impl ::std::default::Default for PublicKeyCredentialType {
    fn default() -> Self {
        PublicKeyCredentialType::PUBLIC_KEY
    }
}

