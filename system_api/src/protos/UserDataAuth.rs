// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.21.9
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `UserDataAuth.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.CryptohomeErrorInfo)
pub struct CryptohomeErrorInfo {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.CryptohomeErrorInfo.error_id)
    pub error_id: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.CryptohomeErrorInfo.readable_error_id)
    pub readable_error_id: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.CryptohomeErrorInfo.primary_action)
    pub primary_action: ::protobuf::EnumOrUnknown<PrimaryAction>,
    // @@protoc_insertion_point(field:user_data_auth.CryptohomeErrorInfo.possible_actions)
    pub possible_actions: ::std::vec::Vec<::protobuf::EnumOrUnknown<PossibleAction>>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.CryptohomeErrorInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CryptohomeErrorInfo {
    fn default() -> &'a CryptohomeErrorInfo {
        <CryptohomeErrorInfo as ::protobuf::Message>::default_instance()
    }
}

impl CryptohomeErrorInfo {
    pub fn new() -> CryptohomeErrorInfo {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CryptohomeErrorInfo {
    const NAME: &'static str = "CryptohomeErrorInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error_id = is.read_string()?;
                },
                18 => {
                    self.readable_error_id = is.read_string()?;
                },
                24 => {
                    self.primary_action = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.possible_actions.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.possible_actions)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error_id);
        }
        if !self.readable_error_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.readable_error_id);
        }
        if self.primary_action != ::protobuf::EnumOrUnknown::new(PrimaryAction::PRIMARY_NO_ERROR) {
            my_size += ::protobuf::rt::int32_size(3, self.primary_action.value());
        }
        for value in &self.possible_actions {
            my_size += ::protobuf::rt::int32_size(4, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error_id.is_empty() {
            os.write_string(1, &self.error_id)?;
        }
        if !self.readable_error_id.is_empty() {
            os.write_string(2, &self.readable_error_id)?;
        }
        if self.primary_action != ::protobuf::EnumOrUnknown::new(PrimaryAction::PRIMARY_NO_ERROR) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.primary_action))?;
        }
        for v in &self.possible_actions {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CryptohomeErrorInfo {
        CryptohomeErrorInfo::new()
    }

    fn clear(&mut self) {
        self.error_id.clear();
        self.readable_error_id.clear();
        self.primary_action = ::protobuf::EnumOrUnknown::new(PrimaryAction::PRIMARY_NO_ERROR);
        self.possible_actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CryptohomeErrorInfo {
        static instance: CryptohomeErrorInfo = CryptohomeErrorInfo {
            error_id: ::std::string::String::new(),
            readable_error_id: ::std::string::String::new(),
            primary_action: ::protobuf::EnumOrUnknown::from_i32(0),
            possible_actions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.IsMountedRequest)
pub struct IsMountedRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.IsMountedRequest.username)
    pub username: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.IsMountedRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IsMountedRequest {
    fn default() -> &'a IsMountedRequest {
        <IsMountedRequest as ::protobuf::Message>::default_instance()
    }
}

impl IsMountedRequest {
    pub fn new() -> IsMountedRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for IsMountedRequest {
    const NAME: &'static str = "IsMountedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.username = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IsMountedRequest {
        IsMountedRequest::new()
    }

    fn clear(&mut self) {
        self.username.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IsMountedRequest {
        static instance: IsMountedRequest = IsMountedRequest {
            username: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.IsMountedReply)
pub struct IsMountedReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.IsMountedReply.is_mounted)
    pub is_mounted: bool,
    // @@protoc_insertion_point(field:user_data_auth.IsMountedReply.is_ephemeral_mount)
    pub is_ephemeral_mount: bool,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.IsMountedReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IsMountedReply {
    fn default() -> &'a IsMountedReply {
        <IsMountedReply as ::protobuf::Message>::default_instance()
    }
}

impl IsMountedReply {
    pub fn new() -> IsMountedReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for IsMountedReply {
    const NAME: &'static str = "IsMountedReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_mounted = is.read_bool()?;
                },
                16 => {
                    self.is_ephemeral_mount = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.is_mounted != false {
            my_size += 1 + 1;
        }
        if self.is_ephemeral_mount != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.is_mounted != false {
            os.write_bool(1, self.is_mounted)?;
        }
        if self.is_ephemeral_mount != false {
            os.write_bool(2, self.is_ephemeral_mount)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IsMountedReply {
        IsMountedReply::new()
    }

    fn clear(&mut self) {
        self.is_mounted = false;
        self.is_ephemeral_mount = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IsMountedReply {
        static instance: IsMountedReply = IsMountedReply {
            is_mounted: false,
            is_ephemeral_mount: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.UnmountRequest)
pub struct UnmountRequest {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.UnmountRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnmountRequest {
    fn default() -> &'a UnmountRequest {
        <UnmountRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnmountRequest {
    pub fn new() -> UnmountRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UnmountRequest {
    const NAME: &'static str = "UnmountRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnmountRequest {
        UnmountRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnmountRequest {
        static instance: UnmountRequest = UnmountRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.UnmountReply)
pub struct UnmountReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.UnmountReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.UnmountReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.UnmountReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnmountReply {
    fn default() -> &'a UnmountReply {
        <UnmountReply as ::protobuf::Message>::default_instance()
    }
}

impl UnmountReply {
    pub fn new() -> UnmountReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UnmountReply {
    const NAME: &'static str = "UnmountReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnmountReply {
        UnmountReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnmountReply {
        static instance: UnmountReply = UnmountReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.RemoveRequest)
pub struct RemoveRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.RemoveRequest.identifier)
    pub identifier: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // @@protoc_insertion_point(field:user_data_auth.RemoveRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.RemoveRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveRequest {
    fn default() -> &'a RemoveRequest {
        <RemoveRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveRequest {
    pub fn new() -> RemoveRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RemoveRequest {
    const NAME: &'static str = "RemoveRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.identifier)?;
                },
                18 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.identifier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.identifier.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.auth_session_id.is_empty() {
            os.write_bytes(2, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveRequest {
        RemoveRequest::new()
    }

    fn clear(&mut self) {
        self.identifier.clear();
        self.auth_session_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveRequest {
        static instance: RemoveRequest = RemoveRequest {
            identifier: ::protobuf::MessageField::none(),
            auth_session_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.RemoveReply)
pub struct RemoveReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.RemoveReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.RemoveReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.RemoveReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveReply {
    fn default() -> &'a RemoveReply {
        <RemoveReply as ::protobuf::Message>::default_instance()
    }
}

impl RemoveReply {
    pub fn new() -> RemoveReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RemoveReply {
    const NAME: &'static str = "RemoveReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveReply {
        RemoveReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveReply {
        static instance: RemoveReply = RemoveReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.ListKeysRequest)
pub struct ListKeysRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.ListKeysRequest.account_id)
    pub account_id: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // @@protoc_insertion_point(field:user_data_auth.ListKeysRequest.authorization_request)
    pub authorization_request: ::protobuf::MessageField<super::rpc::AuthorizationRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.ListKeysRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListKeysRequest {
    fn default() -> &'a ListKeysRequest {
        <ListKeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListKeysRequest {
    pub fn new() -> ListKeysRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListKeysRequest {
    const NAME: &'static str = "ListKeysRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.authorization_request)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.authorization_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.authorization_request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListKeysRequest {
        ListKeysRequest::new()
    }

    fn clear(&mut self) {
        self.account_id.clear();
        self.authorization_request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListKeysRequest {
        static instance: ListKeysRequest = ListKeysRequest {
            account_id: ::protobuf::MessageField::none(),
            authorization_request: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.ListKeysReply)
pub struct ListKeysReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.ListKeysReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.ListKeysReply.labels)
    pub labels: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:user_data_auth.ListKeysReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.ListKeysReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListKeysReply {
    fn default() -> &'a ListKeysReply {
        <ListKeysReply as ::protobuf::Message>::default_instance()
    }
}

impl ListKeysReply {
    pub fn new() -> ListKeysReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListKeysReply {
    const NAME: &'static str = "ListKeysReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.labels.push(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        for value in &self.labels {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        for v in &self.labels {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListKeysReply {
        ListKeysReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.labels.clear();
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListKeysReply {
        static instance: ListKeysReply = ListKeysReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            labels: ::std::vec::Vec::new(),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.CheckKeyRequest)
pub struct CheckKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.CheckKeyRequest.account_id)
    pub account_id: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // @@protoc_insertion_point(field:user_data_auth.CheckKeyRequest.authorization_request)
    pub authorization_request: ::protobuf::MessageField<super::rpc::AuthorizationRequest>,
    // @@protoc_insertion_point(field:user_data_auth.CheckKeyRequest.unlock_webauthn_secret)
    pub unlock_webauthn_secret: bool,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.CheckKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CheckKeyRequest {
    fn default() -> &'a CheckKeyRequest {
        <CheckKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl CheckKeyRequest {
    pub fn new() -> CheckKeyRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CheckKeyRequest {
    const NAME: &'static str = "CheckKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.authorization_request)?;
                },
                24 => {
                    self.unlock_webauthn_secret = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.authorization_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.unlock_webauthn_secret != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.authorization_request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.unlock_webauthn_secret != false {
            os.write_bool(3, self.unlock_webauthn_secret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CheckKeyRequest {
        CheckKeyRequest::new()
    }

    fn clear(&mut self) {
        self.account_id.clear();
        self.authorization_request.clear();
        self.unlock_webauthn_secret = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CheckKeyRequest {
        static instance: CheckKeyRequest = CheckKeyRequest {
            account_id: ::protobuf::MessageField::none(),
            authorization_request: ::protobuf::MessageField::none(),
            unlock_webauthn_secret: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.CheckKeyReply)
pub struct CheckKeyReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.CheckKeyReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.CheckKeyReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CheckKeyReply {
    fn default() -> &'a CheckKeyReply {
        <CheckKeyReply as ::protobuf::Message>::default_instance()
    }
}

impl CheckKeyReply {
    pub fn new() -> CheckKeyReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CheckKeyReply {
    const NAME: &'static str = "CheckKeyReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CheckKeyReply {
        CheckKeyReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CheckKeyReply {
        static instance: CheckKeyReply = CheckKeyReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.StartFingerprintAuthSessionRequest)
pub struct StartFingerprintAuthSessionRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.StartFingerprintAuthSessionRequest.account_id)
    pub account_id: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.StartFingerprintAuthSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartFingerprintAuthSessionRequest {
    fn default() -> &'a StartFingerprintAuthSessionRequest {
        <StartFingerprintAuthSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartFingerprintAuthSessionRequest {
    pub fn new() -> StartFingerprintAuthSessionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartFingerprintAuthSessionRequest {
    const NAME: &'static str = "StartFingerprintAuthSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartFingerprintAuthSessionRequest {
        StartFingerprintAuthSessionRequest::new()
    }

    fn clear(&mut self) {
        self.account_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartFingerprintAuthSessionRequest {
        static instance: StartFingerprintAuthSessionRequest = StartFingerprintAuthSessionRequest {
            account_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.StartFingerprintAuthSessionReply)
pub struct StartFingerprintAuthSessionReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.StartFingerprintAuthSessionReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.StartFingerprintAuthSessionReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartFingerprintAuthSessionReply {
    fn default() -> &'a StartFingerprintAuthSessionReply {
        <StartFingerprintAuthSessionReply as ::protobuf::Message>::default_instance()
    }
}

impl StartFingerprintAuthSessionReply {
    pub fn new() -> StartFingerprintAuthSessionReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartFingerprintAuthSessionReply {
    const NAME: &'static str = "StartFingerprintAuthSessionReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartFingerprintAuthSessionReply {
        StartFingerprintAuthSessionReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartFingerprintAuthSessionReply {
        static instance: StartFingerprintAuthSessionReply = StartFingerprintAuthSessionReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.EndFingerprintAuthSessionRequest)
pub struct EndFingerprintAuthSessionRequest {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.EndFingerprintAuthSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EndFingerprintAuthSessionRequest {
    fn default() -> &'a EndFingerprintAuthSessionRequest {
        <EndFingerprintAuthSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl EndFingerprintAuthSessionRequest {
    pub fn new() -> EndFingerprintAuthSessionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EndFingerprintAuthSessionRequest {
    const NAME: &'static str = "EndFingerprintAuthSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EndFingerprintAuthSessionRequest {
        EndFingerprintAuthSessionRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EndFingerprintAuthSessionRequest {
        static instance: EndFingerprintAuthSessionRequest = EndFingerprintAuthSessionRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.EndFingerprintAuthSessionReply)
pub struct EndFingerprintAuthSessionReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.EndFingerprintAuthSessionReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.EndFingerprintAuthSessionReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EndFingerprintAuthSessionReply {
    fn default() -> &'a EndFingerprintAuthSessionReply {
        <EndFingerprintAuthSessionReply as ::protobuf::Message>::default_instance()
    }
}

impl EndFingerprintAuthSessionReply {
    pub fn new() -> EndFingerprintAuthSessionReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for EndFingerprintAuthSessionReply {
    const NAME: &'static str = "EndFingerprintAuthSessionReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EndFingerprintAuthSessionReply {
        EndFingerprintAuthSessionReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EndFingerprintAuthSessionReply {
        static instance: EndFingerprintAuthSessionReply = EndFingerprintAuthSessionReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetWebAuthnSecretRequest)
pub struct GetWebAuthnSecretRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetWebAuthnSecretRequest.account_id)
    pub account_id: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetWebAuthnSecretRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetWebAuthnSecretRequest {
    fn default() -> &'a GetWebAuthnSecretRequest {
        <GetWebAuthnSecretRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWebAuthnSecretRequest {
    pub fn new() -> GetWebAuthnSecretRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetWebAuthnSecretRequest {
    const NAME: &'static str = "GetWebAuthnSecretRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetWebAuthnSecretRequest {
        GetWebAuthnSecretRequest::new()
    }

    fn clear(&mut self) {
        self.account_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetWebAuthnSecretRequest {
        static instance: GetWebAuthnSecretRequest = GetWebAuthnSecretRequest {
            account_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetWebAuthnSecretReply)
pub struct GetWebAuthnSecretReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetWebAuthnSecretReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.GetWebAuthnSecretReply.webauthn_secret)
    pub webauthn_secret: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetWebAuthnSecretReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetWebAuthnSecretReply {
    fn default() -> &'a GetWebAuthnSecretReply {
        <GetWebAuthnSecretReply as ::protobuf::Message>::default_instance()
    }
}

impl GetWebAuthnSecretReply {
    pub fn new() -> GetWebAuthnSecretReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetWebAuthnSecretReply {
    const NAME: &'static str = "GetWebAuthnSecretReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.webauthn_secret = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if !self.webauthn_secret.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.webauthn_secret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if !self.webauthn_secret.is_empty() {
            os.write_bytes(2, &self.webauthn_secret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetWebAuthnSecretReply {
        GetWebAuthnSecretReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.webauthn_secret.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetWebAuthnSecretReply {
        static instance: GetWebAuthnSecretReply = GetWebAuthnSecretReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            webauthn_secret: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetWebAuthnSecretHashRequest)
pub struct GetWebAuthnSecretHashRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetWebAuthnSecretHashRequest.account_id)
    pub account_id: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetWebAuthnSecretHashRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetWebAuthnSecretHashRequest {
    fn default() -> &'a GetWebAuthnSecretHashRequest {
        <GetWebAuthnSecretHashRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetWebAuthnSecretHashRequest {
    pub fn new() -> GetWebAuthnSecretHashRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetWebAuthnSecretHashRequest {
    const NAME: &'static str = "GetWebAuthnSecretHashRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetWebAuthnSecretHashRequest {
        GetWebAuthnSecretHashRequest::new()
    }

    fn clear(&mut self) {
        self.account_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetWebAuthnSecretHashRequest {
        static instance: GetWebAuthnSecretHashRequest = GetWebAuthnSecretHashRequest {
            account_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetWebAuthnSecretHashReply)
pub struct GetWebAuthnSecretHashReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetWebAuthnSecretHashReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.GetWebAuthnSecretHashReply.webauthn_secret_hash)
    pub webauthn_secret_hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetWebAuthnSecretHashReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetWebAuthnSecretHashReply {
    fn default() -> &'a GetWebAuthnSecretHashReply {
        <GetWebAuthnSecretHashReply as ::protobuf::Message>::default_instance()
    }
}

impl GetWebAuthnSecretHashReply {
    pub fn new() -> GetWebAuthnSecretHashReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetWebAuthnSecretHashReply {
    const NAME: &'static str = "GetWebAuthnSecretHashReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.webauthn_secret_hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if !self.webauthn_secret_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.webauthn_secret_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if !self.webauthn_secret_hash.is_empty() {
            os.write_bytes(2, &self.webauthn_secret_hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetWebAuthnSecretHashReply {
        GetWebAuthnSecretHashReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.webauthn_secret_hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetWebAuthnSecretHashReply {
        static instance: GetWebAuthnSecretHashReply = GetWebAuthnSecretHashReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            webauthn_secret_hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetHibernateSecretRequest)
pub struct GetHibernateSecretRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetHibernateSecretRequest.account_id)
    pub account_id: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // @@protoc_insertion_point(field:user_data_auth.GetHibernateSecretRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetHibernateSecretRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetHibernateSecretRequest {
    fn default() -> &'a GetHibernateSecretRequest {
        <GetHibernateSecretRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetHibernateSecretRequest {
    pub fn new() -> GetHibernateSecretRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetHibernateSecretRequest {
    const NAME: &'static str = "GetHibernateSecretRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_id)?;
                },
                18 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.auth_session_id.is_empty() {
            os.write_bytes(2, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetHibernateSecretRequest {
        GetHibernateSecretRequest::new()
    }

    fn clear(&mut self) {
        self.account_id.clear();
        self.auth_session_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetHibernateSecretRequest {
        static instance: GetHibernateSecretRequest = GetHibernateSecretRequest {
            account_id: ::protobuf::MessageField::none(),
            auth_session_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetHibernateSecretReply)
pub struct GetHibernateSecretReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetHibernateSecretReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.GetHibernateSecretReply.hibernate_secret)
    pub hibernate_secret: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetHibernateSecretReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetHibernateSecretReply {
    fn default() -> &'a GetHibernateSecretReply {
        <GetHibernateSecretReply as ::protobuf::Message>::default_instance()
    }
}

impl GetHibernateSecretReply {
    pub fn new() -> GetHibernateSecretReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetHibernateSecretReply {
    const NAME: &'static str = "GetHibernateSecretReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.hibernate_secret = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if !self.hibernate_secret.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hibernate_secret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if !self.hibernate_secret.is_empty() {
            os.write_bytes(2, &self.hibernate_secret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetHibernateSecretReply {
        GetHibernateSecretReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.hibernate_secret.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetHibernateSecretReply {
        static instance: GetHibernateSecretReply = GetHibernateSecretReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            hibernate_secret: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetEncryptionInfoRequest)
pub struct GetEncryptionInfoRequest {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetEncryptionInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetEncryptionInfoRequest {
    fn default() -> &'a GetEncryptionInfoRequest {
        <GetEncryptionInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetEncryptionInfoRequest {
    pub fn new() -> GetEncryptionInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetEncryptionInfoRequest {
    const NAME: &'static str = "GetEncryptionInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetEncryptionInfoRequest {
        GetEncryptionInfoRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetEncryptionInfoRequest {
        static instance: GetEncryptionInfoRequest = GetEncryptionInfoRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetEncryptionInfoReply)
pub struct GetEncryptionInfoReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetEncryptionInfoReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.GetEncryptionInfoReply.keylocker_supported)
    pub keylocker_supported: bool,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetEncryptionInfoReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetEncryptionInfoReply {
    fn default() -> &'a GetEncryptionInfoReply {
        <GetEncryptionInfoReply as ::protobuf::Message>::default_instance()
    }
}

impl GetEncryptionInfoReply {
    pub fn new() -> GetEncryptionInfoReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetEncryptionInfoReply {
    const NAME: &'static str = "GetEncryptionInfoReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.keylocker_supported = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if self.keylocker_supported != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if self.keylocker_supported != false {
            os.write_bool(2, self.keylocker_supported)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetEncryptionInfoReply {
        GetEncryptionInfoReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.keylocker_supported = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetEncryptionInfoReply {
        static instance: GetEncryptionInfoReply = GetEncryptionInfoReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            keylocker_supported: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.StartMigrateToDircryptoRequest)
pub struct StartMigrateToDircryptoRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.StartMigrateToDircryptoRequest.account_id)
    pub account_id: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // @@protoc_insertion_point(field:user_data_auth.StartMigrateToDircryptoRequest.minimal_migration)
    pub minimal_migration: bool,
    // @@protoc_insertion_point(field:user_data_auth.StartMigrateToDircryptoRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.StartMigrateToDircryptoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartMigrateToDircryptoRequest {
    fn default() -> &'a StartMigrateToDircryptoRequest {
        <StartMigrateToDircryptoRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartMigrateToDircryptoRequest {
    pub fn new() -> StartMigrateToDircryptoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartMigrateToDircryptoRequest {
    const NAME: &'static str = "StartMigrateToDircryptoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_id)?;
                },
                16 => {
                    self.minimal_migration = is.read_bool()?;
                },
                26 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.minimal_migration != false {
            my_size += 1 + 1;
        }
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.minimal_migration != false {
            os.write_bool(2, self.minimal_migration)?;
        }
        if !self.auth_session_id.is_empty() {
            os.write_bytes(3, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartMigrateToDircryptoRequest {
        StartMigrateToDircryptoRequest::new()
    }

    fn clear(&mut self) {
        self.account_id.clear();
        self.minimal_migration = false;
        self.auth_session_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartMigrateToDircryptoRequest {
        static instance: StartMigrateToDircryptoRequest = StartMigrateToDircryptoRequest {
            account_id: ::protobuf::MessageField::none(),
            minimal_migration: false,
            auth_session_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.StartMigrateToDircryptoReply)
pub struct StartMigrateToDircryptoReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.StartMigrateToDircryptoReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.StartMigrateToDircryptoReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartMigrateToDircryptoReply {
    fn default() -> &'a StartMigrateToDircryptoReply {
        <StartMigrateToDircryptoReply as ::protobuf::Message>::default_instance()
    }
}

impl StartMigrateToDircryptoReply {
    pub fn new() -> StartMigrateToDircryptoReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartMigrateToDircryptoReply {
    const NAME: &'static str = "StartMigrateToDircryptoReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartMigrateToDircryptoReply {
        StartMigrateToDircryptoReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartMigrateToDircryptoReply {
        static instance: StartMigrateToDircryptoReply = StartMigrateToDircryptoReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.DircryptoMigrationProgress)
pub struct DircryptoMigrationProgress {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.DircryptoMigrationProgress.status)
    pub status: ::protobuf::EnumOrUnknown<DircryptoMigrationStatus>,
    // @@protoc_insertion_point(field:user_data_auth.DircryptoMigrationProgress.current_bytes)
    pub current_bytes: u64,
    // @@protoc_insertion_point(field:user_data_auth.DircryptoMigrationProgress.total_bytes)
    pub total_bytes: u64,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.DircryptoMigrationProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DircryptoMigrationProgress {
    fn default() -> &'a DircryptoMigrationProgress {
        <DircryptoMigrationProgress as ::protobuf::Message>::default_instance()
    }
}

impl DircryptoMigrationProgress {
    pub fn new() -> DircryptoMigrationProgress {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DircryptoMigrationProgress {
    const NAME: &'static str = "DircryptoMigrationProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.current_bytes = is.read_uint64()?;
                },
                24 => {
                    self.total_bytes = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.status != ::protobuf::EnumOrUnknown::new(DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_SUCCESS) {
            my_size += ::protobuf::rt::int32_size(1, self.status.value());
        }
        if self.current_bytes != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.current_bytes);
        }
        if self.total_bytes != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.total_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.status != ::protobuf::EnumOrUnknown::new(DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_SUCCESS) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if self.current_bytes != 0 {
            os.write_uint64(2, self.current_bytes)?;
        }
        if self.total_bytes != 0 {
            os.write_uint64(3, self.total_bytes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DircryptoMigrationProgress {
        DircryptoMigrationProgress::new()
    }

    fn clear(&mut self) {
        self.status = ::protobuf::EnumOrUnknown::new(DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_SUCCESS);
        self.current_bytes = 0;
        self.total_bytes = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DircryptoMigrationProgress {
        static instance: DircryptoMigrationProgress = DircryptoMigrationProgress {
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            current_bytes: 0,
            total_bytes: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.NeedsDircryptoMigrationRequest)
pub struct NeedsDircryptoMigrationRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.NeedsDircryptoMigrationRequest.account_id)
    pub account_id: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.NeedsDircryptoMigrationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NeedsDircryptoMigrationRequest {
    fn default() -> &'a NeedsDircryptoMigrationRequest {
        <NeedsDircryptoMigrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl NeedsDircryptoMigrationRequest {
    pub fn new() -> NeedsDircryptoMigrationRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for NeedsDircryptoMigrationRequest {
    const NAME: &'static str = "NeedsDircryptoMigrationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NeedsDircryptoMigrationRequest {
        NeedsDircryptoMigrationRequest::new()
    }

    fn clear(&mut self) {
        self.account_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NeedsDircryptoMigrationRequest {
        static instance: NeedsDircryptoMigrationRequest = NeedsDircryptoMigrationRequest {
            account_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.NeedsDircryptoMigrationReply)
pub struct NeedsDircryptoMigrationReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.NeedsDircryptoMigrationReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.NeedsDircryptoMigrationReply.needs_dircrypto_migration)
    pub needs_dircrypto_migration: bool,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.NeedsDircryptoMigrationReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NeedsDircryptoMigrationReply {
    fn default() -> &'a NeedsDircryptoMigrationReply {
        <NeedsDircryptoMigrationReply as ::protobuf::Message>::default_instance()
    }
}

impl NeedsDircryptoMigrationReply {
    pub fn new() -> NeedsDircryptoMigrationReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for NeedsDircryptoMigrationReply {
    const NAME: &'static str = "NeedsDircryptoMigrationReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.needs_dircrypto_migration = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if self.needs_dircrypto_migration != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if self.needs_dircrypto_migration != false {
            os.write_bool(2, self.needs_dircrypto_migration)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NeedsDircryptoMigrationReply {
        NeedsDircryptoMigrationReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.needs_dircrypto_migration = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NeedsDircryptoMigrationReply {
        static instance: NeedsDircryptoMigrationReply = NeedsDircryptoMigrationReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            needs_dircrypto_migration: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetSupportedKeyPoliciesRequest)
pub struct GetSupportedKeyPoliciesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetSupportedKeyPoliciesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSupportedKeyPoliciesRequest {
    fn default() -> &'a GetSupportedKeyPoliciesRequest {
        <GetSupportedKeyPoliciesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSupportedKeyPoliciesRequest {
    pub fn new() -> GetSupportedKeyPoliciesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSupportedKeyPoliciesRequest {
    const NAME: &'static str = "GetSupportedKeyPoliciesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSupportedKeyPoliciesRequest {
        GetSupportedKeyPoliciesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSupportedKeyPoliciesRequest {
        static instance: GetSupportedKeyPoliciesRequest = GetSupportedKeyPoliciesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetSupportedKeyPoliciesReply)
pub struct GetSupportedKeyPoliciesReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetSupportedKeyPoliciesReply.low_entropy_credentials_supported)
    pub low_entropy_credentials_supported: bool,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetSupportedKeyPoliciesReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSupportedKeyPoliciesReply {
    fn default() -> &'a GetSupportedKeyPoliciesReply {
        <GetSupportedKeyPoliciesReply as ::protobuf::Message>::default_instance()
    }
}

impl GetSupportedKeyPoliciesReply {
    pub fn new() -> GetSupportedKeyPoliciesReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSupportedKeyPoliciesReply {
    const NAME: &'static str = "GetSupportedKeyPoliciesReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.low_entropy_credentials_supported = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.low_entropy_credentials_supported != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.low_entropy_credentials_supported != false {
            os.write_bool(1, self.low_entropy_credentials_supported)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSupportedKeyPoliciesReply {
        GetSupportedKeyPoliciesReply::new()
    }

    fn clear(&mut self) {
        self.low_entropy_credentials_supported = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSupportedKeyPoliciesReply {
        static instance: GetSupportedKeyPoliciesReply = GetSupportedKeyPoliciesReply {
            low_entropy_credentials_supported: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetAccountDiskUsageRequest)
pub struct GetAccountDiskUsageRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetAccountDiskUsageRequest.identifier)
    pub identifier: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetAccountDiskUsageRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAccountDiskUsageRequest {
    fn default() -> &'a GetAccountDiskUsageRequest {
        <GetAccountDiskUsageRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAccountDiskUsageRequest {
    pub fn new() -> GetAccountDiskUsageRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetAccountDiskUsageRequest {
    const NAME: &'static str = "GetAccountDiskUsageRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.identifier)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.identifier.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.identifier.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAccountDiskUsageRequest {
        GetAccountDiskUsageRequest::new()
    }

    fn clear(&mut self) {
        self.identifier.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAccountDiskUsageRequest {
        static instance: GetAccountDiskUsageRequest = GetAccountDiskUsageRequest {
            identifier: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetAccountDiskUsageReply)
pub struct GetAccountDiskUsageReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetAccountDiskUsageReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.GetAccountDiskUsageReply.size)
    pub size: i64,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetAccountDiskUsageReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAccountDiskUsageReply {
    fn default() -> &'a GetAccountDiskUsageReply {
        <GetAccountDiskUsageReply as ::protobuf::Message>::default_instance()
    }
}

impl GetAccountDiskUsageReply {
    pub fn new() -> GetAccountDiskUsageReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetAccountDiskUsageReply {
    const NAME: &'static str = "GetAccountDiskUsageReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.size = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if self.size != 0 {
            os.write_int64(2, self.size)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAccountDiskUsageReply {
        GetAccountDiskUsageReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.size = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAccountDiskUsageReply {
        static instance: GetAccountDiskUsageReply = GetAccountDiskUsageReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            size: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.LowDiskSpace)
pub struct LowDiskSpace {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.LowDiskSpace.disk_free_bytes)
    pub disk_free_bytes: u64,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.LowDiskSpace.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LowDiskSpace {
    fn default() -> &'a LowDiskSpace {
        <LowDiskSpace as ::protobuf::Message>::default_instance()
    }
}

impl LowDiskSpace {
    pub fn new() -> LowDiskSpace {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LowDiskSpace {
    const NAME: &'static str = "LowDiskSpace";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.disk_free_bytes = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.disk_free_bytes != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.disk_free_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.disk_free_bytes != 0 {
            os.write_uint64(1, self.disk_free_bytes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LowDiskSpace {
        LowDiskSpace::new()
    }

    fn clear(&mut self) {
        self.disk_free_bytes = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LowDiskSpace {
        static instance: LowDiskSpace = LowDiskSpace {
            disk_free_bytes: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.StartAuthSessionRequest)
pub struct StartAuthSessionRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.StartAuthSessionRequest.account_id)
    pub account_id: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // @@protoc_insertion_point(field:user_data_auth.StartAuthSessionRequest.flags)
    pub flags: u32,
    // @@protoc_insertion_point(field:user_data_auth.StartAuthSessionRequest.intent)
    pub intent: ::protobuf::EnumOrUnknown<super::auth_factor::AuthIntent>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.StartAuthSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartAuthSessionRequest {
    fn default() -> &'a StartAuthSessionRequest {
        <StartAuthSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartAuthSessionRequest {
    pub fn new() -> StartAuthSessionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartAuthSessionRequest {
    const NAME: &'static str = "StartAuthSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_id)?;
                },
                16 => {
                    self.flags = is.read_uint32()?;
                },
                24 => {
                    self.intent = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.flags != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.flags);
        }
        if self.intent != ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthIntent::AUTH_INTENT_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(3, self.intent.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.flags != 0 {
            os.write_uint32(2, self.flags)?;
        }
        if self.intent != ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthIntent::AUTH_INTENT_UNSPECIFIED) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.intent))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartAuthSessionRequest {
        StartAuthSessionRequest::new()
    }

    fn clear(&mut self) {
        self.account_id.clear();
        self.flags = 0;
        self.intent = ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthIntent::AUTH_INTENT_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartAuthSessionRequest {
        static instance: StartAuthSessionRequest = StartAuthSessionRequest {
            account_id: ::protobuf::MessageField::none(),
            flags: 0,
            intent: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.AuthFactorWithStatus)
pub struct AuthFactorWithStatus {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.AuthFactorWithStatus.auth_factor)
    pub auth_factor: ::protobuf::MessageField<super::auth_factor::AuthFactor>,
    // @@protoc_insertion_point(field:user_data_auth.AuthFactorWithStatus.available_for_intents)
    pub available_for_intents: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::auth_factor::AuthIntent>>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.AuthFactorWithStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthFactorWithStatus {
    fn default() -> &'a AuthFactorWithStatus {
        <AuthFactorWithStatus as ::protobuf::Message>::default_instance()
    }
}

impl AuthFactorWithStatus {
    pub fn new() -> AuthFactorWithStatus {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthFactorWithStatus {
    const NAME: &'static str = "AuthFactorWithStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.auth_factor)?;
                },
                16 => {
                    self.available_for_intents.push(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.available_for_intents)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.auth_factor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.available_for_intents {
            my_size += ::protobuf::rt::int32_size(2, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.auth_factor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.available_for_intents {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthFactorWithStatus {
        AuthFactorWithStatus::new()
    }

    fn clear(&mut self) {
        self.auth_factor.clear();
        self.available_for_intents.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthFactorWithStatus {
        static instance: AuthFactorWithStatus = AuthFactorWithStatus {
            auth_factor: ::protobuf::MessageField::none(),
            available_for_intents: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.StartAuthSessionReply)
pub struct StartAuthSessionReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.StartAuthSessionReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.StartAuthSessionReply.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:user_data_auth.StartAuthSessionReply.user_exists)
    pub user_exists: bool,
    // @@protoc_insertion_point(field:user_data_auth.StartAuthSessionReply.auth_factors)
    pub auth_factors: ::std::vec::Vec<super::auth_factor::AuthFactor>,
    // @@protoc_insertion_point(field:user_data_auth.StartAuthSessionReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.StartAuthSessionReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StartAuthSessionReply {
    fn default() -> &'a StartAuthSessionReply {
        <StartAuthSessionReply as ::protobuf::Message>::default_instance()
    }
}

impl StartAuthSessionReply {
    pub fn new() -> StartAuthSessionReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartAuthSessionReply {
    const NAME: &'static str = "StartAuthSessionReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                24 => {
                    self.user_exists = is.read_bool()?;
                },
                42 => {
                    self.auth_factors.push(is.read_message()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.auth_session_id);
        }
        if self.user_exists != false {
            my_size += 1 + 1;
        }
        for value in &self.auth_factors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if !self.auth_session_id.is_empty() {
            os.write_bytes(2, &self.auth_session_id)?;
        }
        if self.user_exists != false {
            os.write_bool(3, self.user_exists)?;
        }
        for v in &self.auth_factors {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StartAuthSessionReply {
        StartAuthSessionReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.auth_session_id.clear();
        self.user_exists = false;
        self.auth_factors.clear();
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StartAuthSessionReply {
        static instance: StartAuthSessionReply = StartAuthSessionReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            auth_session_id: ::std::vec::Vec::new(),
            user_exists: false,
            auth_factors: ::std::vec::Vec::new(),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.InvalidateAuthSessionRequest)
pub struct InvalidateAuthSessionRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.InvalidateAuthSessionRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.InvalidateAuthSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InvalidateAuthSessionRequest {
    fn default() -> &'a InvalidateAuthSessionRequest {
        <InvalidateAuthSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl InvalidateAuthSessionRequest {
    pub fn new() -> InvalidateAuthSessionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InvalidateAuthSessionRequest {
    const NAME: &'static str = "InvalidateAuthSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InvalidateAuthSessionRequest {
        InvalidateAuthSessionRequest::new()
    }

    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InvalidateAuthSessionRequest {
        static instance: InvalidateAuthSessionRequest = InvalidateAuthSessionRequest {
            auth_session_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.InvalidateAuthSessionReply)
pub struct InvalidateAuthSessionReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.InvalidateAuthSessionReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.InvalidateAuthSessionReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.InvalidateAuthSessionReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InvalidateAuthSessionReply {
    fn default() -> &'a InvalidateAuthSessionReply {
        <InvalidateAuthSessionReply as ::protobuf::Message>::default_instance()
    }
}

impl InvalidateAuthSessionReply {
    pub fn new() -> InvalidateAuthSessionReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InvalidateAuthSessionReply {
    const NAME: &'static str = "InvalidateAuthSessionReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InvalidateAuthSessionReply {
        InvalidateAuthSessionReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InvalidateAuthSessionReply {
        static instance: InvalidateAuthSessionReply = InvalidateAuthSessionReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.ExtendAuthSessionRequest)
pub struct ExtendAuthSessionRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.ExtendAuthSessionRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:user_data_auth.ExtendAuthSessionRequest.extension_duration)
    pub extension_duration: u32,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.ExtendAuthSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExtendAuthSessionRequest {
    fn default() -> &'a ExtendAuthSessionRequest {
        <ExtendAuthSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExtendAuthSessionRequest {
    pub fn new() -> ExtendAuthSessionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ExtendAuthSessionRequest {
    const NAME: &'static str = "ExtendAuthSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                16 => {
                    self.extension_duration = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if self.extension_duration != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.extension_duration);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if self.extension_duration != 0 {
            os.write_uint32(2, self.extension_duration)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExtendAuthSessionRequest {
        ExtendAuthSessionRequest::new()
    }

    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.extension_duration = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExtendAuthSessionRequest {
        static instance: ExtendAuthSessionRequest = ExtendAuthSessionRequest {
            auth_session_id: ::std::vec::Vec::new(),
            extension_duration: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.ExtendAuthSessionReply)
pub struct ExtendAuthSessionReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.ExtendAuthSessionReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.ExtendAuthSessionReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // @@protoc_insertion_point(field:user_data_auth.ExtendAuthSessionReply.seconds_left)
    pub seconds_left: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.ExtendAuthSessionReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExtendAuthSessionReply {
    fn default() -> &'a ExtendAuthSessionReply {
        <ExtendAuthSessionReply as ::protobuf::Message>::default_instance()
    }
}

impl ExtendAuthSessionReply {
    pub fn new() -> ExtendAuthSessionReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ExtendAuthSessionReply {
    const NAME: &'static str = "ExtendAuthSessionReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                24 => {
                    self.seconds_left = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.seconds_left {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.seconds_left {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExtendAuthSessionReply {
        ExtendAuthSessionReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.error_info.clear();
        self.seconds_left = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExtendAuthSessionReply {
        static instance: ExtendAuthSessionReply = ExtendAuthSessionReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            error_info: ::protobuf::MessageField::none(),
            seconds_left: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.CreatePersistentUserRequest)
pub struct CreatePersistentUserRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.CreatePersistentUserRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.CreatePersistentUserRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreatePersistentUserRequest {
    fn default() -> &'a CreatePersistentUserRequest {
        <CreatePersistentUserRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreatePersistentUserRequest {
    pub fn new() -> CreatePersistentUserRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CreatePersistentUserRequest {
    const NAME: &'static str = "CreatePersistentUserRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreatePersistentUserRequest {
        CreatePersistentUserRequest::new()
    }

    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreatePersistentUserRequest {
        static instance: CreatePersistentUserRequest = CreatePersistentUserRequest {
            auth_session_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.CreatePersistentUserReply)
pub struct CreatePersistentUserReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.CreatePersistentUserReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.CreatePersistentUserReply.sanitized_username)
    pub sanitized_username: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.CreatePersistentUserReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.CreatePersistentUserReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreatePersistentUserReply {
    fn default() -> &'a CreatePersistentUserReply {
        <CreatePersistentUserReply as ::protobuf::Message>::default_instance()
    }
}

impl CreatePersistentUserReply {
    pub fn new() -> CreatePersistentUserReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CreatePersistentUserReply {
    const NAME: &'static str = "CreatePersistentUserReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.sanitized_username = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if !self.sanitized_username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sanitized_username);
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if !self.sanitized_username.is_empty() {
            os.write_string(2, &self.sanitized_username)?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreatePersistentUserReply {
        CreatePersistentUserReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.sanitized_username.clear();
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreatePersistentUserReply {
        static instance: CreatePersistentUserReply = CreatePersistentUserReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            sanitized_username: ::std::string::String::new(),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PrepareGuestVaultRequest)
pub struct PrepareGuestVaultRequest {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PrepareGuestVaultRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrepareGuestVaultRequest {
    fn default() -> &'a PrepareGuestVaultRequest {
        <PrepareGuestVaultRequest as ::protobuf::Message>::default_instance()
    }
}

impl PrepareGuestVaultRequest {
    pub fn new() -> PrepareGuestVaultRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PrepareGuestVaultRequest {
    const NAME: &'static str = "PrepareGuestVaultRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrepareGuestVaultRequest {
        PrepareGuestVaultRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrepareGuestVaultRequest {
        static instance: PrepareGuestVaultRequest = PrepareGuestVaultRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PrepareGuestVaultReply)
pub struct PrepareGuestVaultReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.PrepareGuestVaultReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.PrepareGuestVaultReply.sanitized_username)
    pub sanitized_username: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.PrepareGuestVaultReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PrepareGuestVaultReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrepareGuestVaultReply {
    fn default() -> &'a PrepareGuestVaultReply {
        <PrepareGuestVaultReply as ::protobuf::Message>::default_instance()
    }
}

impl PrepareGuestVaultReply {
    pub fn new() -> PrepareGuestVaultReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PrepareGuestVaultReply {
    const NAME: &'static str = "PrepareGuestVaultReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.sanitized_username = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if !self.sanitized_username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sanitized_username);
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if !self.sanitized_username.is_empty() {
            os.write_string(2, &self.sanitized_username)?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrepareGuestVaultReply {
        PrepareGuestVaultReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.sanitized_username.clear();
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrepareGuestVaultReply {
        static instance: PrepareGuestVaultReply = PrepareGuestVaultReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            sanitized_username: ::std::string::String::new(),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PrepareEphemeralVaultRequest)
pub struct PrepareEphemeralVaultRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.PrepareEphemeralVaultRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PrepareEphemeralVaultRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrepareEphemeralVaultRequest {
    fn default() -> &'a PrepareEphemeralVaultRequest {
        <PrepareEphemeralVaultRequest as ::protobuf::Message>::default_instance()
    }
}

impl PrepareEphemeralVaultRequest {
    pub fn new() -> PrepareEphemeralVaultRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PrepareEphemeralVaultRequest {
    const NAME: &'static str = "PrepareEphemeralVaultRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrepareEphemeralVaultRequest {
        PrepareEphemeralVaultRequest::new()
    }

    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrepareEphemeralVaultRequest {
        static instance: PrepareEphemeralVaultRequest = PrepareEphemeralVaultRequest {
            auth_session_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PrepareEphemeralVaultReply)
pub struct PrepareEphemeralVaultReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.PrepareEphemeralVaultReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.PrepareEphemeralVaultReply.sanitized_username)
    pub sanitized_username: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.PrepareEphemeralVaultReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PrepareEphemeralVaultReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrepareEphemeralVaultReply {
    fn default() -> &'a PrepareEphemeralVaultReply {
        <PrepareEphemeralVaultReply as ::protobuf::Message>::default_instance()
    }
}

impl PrepareEphemeralVaultReply {
    pub fn new() -> PrepareEphemeralVaultReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PrepareEphemeralVaultReply {
    const NAME: &'static str = "PrepareEphemeralVaultReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.sanitized_username = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if !self.sanitized_username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sanitized_username);
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if !self.sanitized_username.is_empty() {
            os.write_string(2, &self.sanitized_username)?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrepareEphemeralVaultReply {
        PrepareEphemeralVaultReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.sanitized_username.clear();
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrepareEphemeralVaultReply {
        static instance: PrepareEphemeralVaultReply = PrepareEphemeralVaultReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            sanitized_username: ::std::string::String::new(),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetAuthSessionStatusRequest)
pub struct GetAuthSessionStatusRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetAuthSessionStatusRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetAuthSessionStatusRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAuthSessionStatusRequest {
    fn default() -> &'a GetAuthSessionStatusRequest {
        <GetAuthSessionStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAuthSessionStatusRequest {
    pub fn new() -> GetAuthSessionStatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetAuthSessionStatusRequest {
    const NAME: &'static str = "GetAuthSessionStatusRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAuthSessionStatusRequest {
        GetAuthSessionStatusRequest::new()
    }

    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAuthSessionStatusRequest {
        static instance: GetAuthSessionStatusRequest = GetAuthSessionStatusRequest {
            auth_session_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetAuthSessionStatusReply)
pub struct GetAuthSessionStatusReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetAuthSessionStatusReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.GetAuthSessionStatusReply.status)
    pub status: ::protobuf::EnumOrUnknown<AuthSessionStatus>,
    // @@protoc_insertion_point(field:user_data_auth.GetAuthSessionStatusReply.time_left)
    pub time_left: u32,
    // @@protoc_insertion_point(field:user_data_auth.GetAuthSessionStatusReply.authorized_for)
    pub authorized_for: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::auth_factor::AuthIntent>>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetAuthSessionStatusReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAuthSessionStatusReply {
    fn default() -> &'a GetAuthSessionStatusReply {
        <GetAuthSessionStatusReply as ::protobuf::Message>::default_instance()
    }
}

impl GetAuthSessionStatusReply {
    pub fn new() -> GetAuthSessionStatusReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetAuthSessionStatusReply {
    const NAME: &'static str = "GetAuthSessionStatusReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.time_left = is.read_uint32()?;
                },
                32 => {
                    self.authorized_for.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.authorized_for)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if self.status != ::protobuf::EnumOrUnknown::new(AuthSessionStatus::AUTH_SESSION_STATUS_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(2, self.status.value());
        }
        if self.time_left != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.time_left);
        }
        for value in &self.authorized_for {
            my_size += ::protobuf::rt::int32_size(4, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(AuthSessionStatus::AUTH_SESSION_STATUS_NOT_SET) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        if self.time_left != 0 {
            os.write_uint32(3, self.time_left)?;
        }
        for v in &self.authorized_for {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAuthSessionStatusReply {
        GetAuthSessionStatusReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.status = ::protobuf::EnumOrUnknown::new(AuthSessionStatus::AUTH_SESSION_STATUS_NOT_SET);
        self.time_left = 0;
        self.authorized_for.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAuthSessionStatusReply {
        static instance: GetAuthSessionStatusReply = GetAuthSessionStatusReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            time_left: 0,
            authorized_for: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PreparePersistentVaultRequest)
pub struct PreparePersistentVaultRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.PreparePersistentVaultRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:user_data_auth.PreparePersistentVaultRequest.block_ecryptfs)
    pub block_ecryptfs: bool,
    // @@protoc_insertion_point(field:user_data_auth.PreparePersistentVaultRequest.encryption_type)
    pub encryption_type: ::protobuf::EnumOrUnknown<VaultEncryptionType>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PreparePersistentVaultRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PreparePersistentVaultRequest {
    fn default() -> &'a PreparePersistentVaultRequest {
        <PreparePersistentVaultRequest as ::protobuf::Message>::default_instance()
    }
}

impl PreparePersistentVaultRequest {
    pub fn new() -> PreparePersistentVaultRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PreparePersistentVaultRequest {
    const NAME: &'static str = "PreparePersistentVaultRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                16 => {
                    self.block_ecryptfs = is.read_bool()?;
                },
                24 => {
                    self.encryption_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if self.block_ecryptfs != false {
            my_size += 1 + 1;
        }
        if self.encryption_type != ::protobuf::EnumOrUnknown::new(VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ANY) {
            my_size += ::protobuf::rt::int32_size(3, self.encryption_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if self.block_ecryptfs != false {
            os.write_bool(2, self.block_ecryptfs)?;
        }
        if self.encryption_type != ::protobuf::EnumOrUnknown::new(VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ANY) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.encryption_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PreparePersistentVaultRequest {
        PreparePersistentVaultRequest::new()
    }

    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.block_ecryptfs = false;
        self.encryption_type = ::protobuf::EnumOrUnknown::new(VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ANY);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PreparePersistentVaultRequest {
        static instance: PreparePersistentVaultRequest = PreparePersistentVaultRequest {
            auth_session_id: ::std::vec::Vec::new(),
            block_ecryptfs: false,
            encryption_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PreparePersistentVaultReply)
pub struct PreparePersistentVaultReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.PreparePersistentVaultReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.PreparePersistentVaultReply.sanitized_username)
    pub sanitized_username: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.PreparePersistentVaultReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PreparePersistentVaultReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PreparePersistentVaultReply {
    fn default() -> &'a PreparePersistentVaultReply {
        <PreparePersistentVaultReply as ::protobuf::Message>::default_instance()
    }
}

impl PreparePersistentVaultReply {
    pub fn new() -> PreparePersistentVaultReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PreparePersistentVaultReply {
    const NAME: &'static str = "PreparePersistentVaultReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.sanitized_username = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if !self.sanitized_username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sanitized_username);
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if !self.sanitized_username.is_empty() {
            os.write_string(2, &self.sanitized_username)?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PreparePersistentVaultReply {
        PreparePersistentVaultReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.sanitized_username.clear();
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PreparePersistentVaultReply {
        static instance: PreparePersistentVaultReply = PreparePersistentVaultReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            sanitized_username: ::std::string::String::new(),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PrepareVaultForMigrationRequest)
pub struct PrepareVaultForMigrationRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.PrepareVaultForMigrationRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PrepareVaultForMigrationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrepareVaultForMigrationRequest {
    fn default() -> &'a PrepareVaultForMigrationRequest {
        <PrepareVaultForMigrationRequest as ::protobuf::Message>::default_instance()
    }
}

impl PrepareVaultForMigrationRequest {
    pub fn new() -> PrepareVaultForMigrationRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PrepareVaultForMigrationRequest {
    const NAME: &'static str = "PrepareVaultForMigrationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrepareVaultForMigrationRequest {
        PrepareVaultForMigrationRequest::new()
    }

    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrepareVaultForMigrationRequest {
        static instance: PrepareVaultForMigrationRequest = PrepareVaultForMigrationRequest {
            auth_session_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PrepareVaultForMigrationReply)
pub struct PrepareVaultForMigrationReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.PrepareVaultForMigrationReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.PrepareVaultForMigrationReply.sanitized_username)
    pub sanitized_username: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.PrepareVaultForMigrationReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PrepareVaultForMigrationReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrepareVaultForMigrationReply {
    fn default() -> &'a PrepareVaultForMigrationReply {
        <PrepareVaultForMigrationReply as ::protobuf::Message>::default_instance()
    }
}

impl PrepareVaultForMigrationReply {
    pub fn new() -> PrepareVaultForMigrationReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PrepareVaultForMigrationReply {
    const NAME: &'static str = "PrepareVaultForMigrationReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.sanitized_username = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if !self.sanitized_username.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sanitized_username);
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if !self.sanitized_username.is_empty() {
            os.write_string(2, &self.sanitized_username)?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrepareVaultForMigrationReply {
        PrepareVaultForMigrationReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.sanitized_username.clear();
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrepareVaultForMigrationReply {
        static instance: PrepareVaultForMigrationReply = PrepareVaultForMigrationReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            sanitized_username: ::std::string::String::new(),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetArcDiskFeaturesRequest)
pub struct GetArcDiskFeaturesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetArcDiskFeaturesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetArcDiskFeaturesRequest {
    fn default() -> &'a GetArcDiskFeaturesRequest {
        <GetArcDiskFeaturesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetArcDiskFeaturesRequest {
    pub fn new() -> GetArcDiskFeaturesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetArcDiskFeaturesRequest {
    const NAME: &'static str = "GetArcDiskFeaturesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetArcDiskFeaturesRequest {
        GetArcDiskFeaturesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetArcDiskFeaturesRequest {
        static instance: GetArcDiskFeaturesRequest = GetArcDiskFeaturesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetArcDiskFeaturesReply)
pub struct GetArcDiskFeaturesReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetArcDiskFeaturesReply.quota_supported)
    pub quota_supported: bool,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetArcDiskFeaturesReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetArcDiskFeaturesReply {
    fn default() -> &'a GetArcDiskFeaturesReply {
        <GetArcDiskFeaturesReply as ::protobuf::Message>::default_instance()
    }
}

impl GetArcDiskFeaturesReply {
    pub fn new() -> GetArcDiskFeaturesReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetArcDiskFeaturesReply {
    const NAME: &'static str = "GetArcDiskFeaturesReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quota_supported = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.quota_supported != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.quota_supported != false {
            os.write_bool(1, self.quota_supported)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetArcDiskFeaturesReply {
        GetArcDiskFeaturesReply::new()
    }

    fn clear(&mut self) {
        self.quota_supported = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetArcDiskFeaturesReply {
        static instance: GetArcDiskFeaturesReply = GetArcDiskFeaturesReply {
            quota_supported: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetCurrentSpaceForArcUidRequest)
pub struct GetCurrentSpaceForArcUidRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetCurrentSpaceForArcUidRequest.uid)
    pub uid: u32,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetCurrentSpaceForArcUidRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCurrentSpaceForArcUidRequest {
    fn default() -> &'a GetCurrentSpaceForArcUidRequest {
        <GetCurrentSpaceForArcUidRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentSpaceForArcUidRequest {
    pub fn new() -> GetCurrentSpaceForArcUidRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCurrentSpaceForArcUidRequest {
    const NAME: &'static str = "GetCurrentSpaceForArcUidRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.uid = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.uid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.uid != 0 {
            os.write_uint32(1, self.uid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCurrentSpaceForArcUidRequest {
        GetCurrentSpaceForArcUidRequest::new()
    }

    fn clear(&mut self) {
        self.uid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCurrentSpaceForArcUidRequest {
        static instance: GetCurrentSpaceForArcUidRequest = GetCurrentSpaceForArcUidRequest {
            uid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetCurrentSpaceForArcUidReply)
pub struct GetCurrentSpaceForArcUidReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetCurrentSpaceForArcUidReply.cur_space)
    pub cur_space: i64,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetCurrentSpaceForArcUidReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCurrentSpaceForArcUidReply {
    fn default() -> &'a GetCurrentSpaceForArcUidReply {
        <GetCurrentSpaceForArcUidReply as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentSpaceForArcUidReply {
    pub fn new() -> GetCurrentSpaceForArcUidReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCurrentSpaceForArcUidReply {
    const NAME: &'static str = "GetCurrentSpaceForArcUidReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cur_space = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.cur_space != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.cur_space);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.cur_space != 0 {
            os.write_int64(1, self.cur_space)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCurrentSpaceForArcUidReply {
        GetCurrentSpaceForArcUidReply::new()
    }

    fn clear(&mut self) {
        self.cur_space = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCurrentSpaceForArcUidReply {
        static instance: GetCurrentSpaceForArcUidReply = GetCurrentSpaceForArcUidReply {
            cur_space: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetCurrentSpaceForArcGidRequest)
pub struct GetCurrentSpaceForArcGidRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetCurrentSpaceForArcGidRequest.gid)
    pub gid: u32,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetCurrentSpaceForArcGidRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCurrentSpaceForArcGidRequest {
    fn default() -> &'a GetCurrentSpaceForArcGidRequest {
        <GetCurrentSpaceForArcGidRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentSpaceForArcGidRequest {
    pub fn new() -> GetCurrentSpaceForArcGidRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCurrentSpaceForArcGidRequest {
    const NAME: &'static str = "GetCurrentSpaceForArcGidRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gid = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.gid != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.gid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.gid != 0 {
            os.write_uint32(1, self.gid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCurrentSpaceForArcGidRequest {
        GetCurrentSpaceForArcGidRequest::new()
    }

    fn clear(&mut self) {
        self.gid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCurrentSpaceForArcGidRequest {
        static instance: GetCurrentSpaceForArcGidRequest = GetCurrentSpaceForArcGidRequest {
            gid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetCurrentSpaceForArcGidReply)
pub struct GetCurrentSpaceForArcGidReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetCurrentSpaceForArcGidReply.cur_space)
    pub cur_space: i64,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetCurrentSpaceForArcGidReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCurrentSpaceForArcGidReply {
    fn default() -> &'a GetCurrentSpaceForArcGidReply {
        <GetCurrentSpaceForArcGidReply as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentSpaceForArcGidReply {
    pub fn new() -> GetCurrentSpaceForArcGidReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCurrentSpaceForArcGidReply {
    const NAME: &'static str = "GetCurrentSpaceForArcGidReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cur_space = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.cur_space != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.cur_space);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.cur_space != 0 {
            os.write_int64(1, self.cur_space)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCurrentSpaceForArcGidReply {
        GetCurrentSpaceForArcGidReply::new()
    }

    fn clear(&mut self) {
        self.cur_space = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCurrentSpaceForArcGidReply {
        static instance: GetCurrentSpaceForArcGidReply = GetCurrentSpaceForArcGidReply {
            cur_space: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetCurrentSpaceForArcProjectIdRequest)
pub struct GetCurrentSpaceForArcProjectIdRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetCurrentSpaceForArcProjectIdRequest.project_id)
    pub project_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetCurrentSpaceForArcProjectIdRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCurrentSpaceForArcProjectIdRequest {
    fn default() -> &'a GetCurrentSpaceForArcProjectIdRequest {
        <GetCurrentSpaceForArcProjectIdRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentSpaceForArcProjectIdRequest {
    pub fn new() -> GetCurrentSpaceForArcProjectIdRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCurrentSpaceForArcProjectIdRequest {
    const NAME: &'static str = "GetCurrentSpaceForArcProjectIdRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.project_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.project_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.project_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.project_id != 0 {
            os.write_uint32(1, self.project_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCurrentSpaceForArcProjectIdRequest {
        GetCurrentSpaceForArcProjectIdRequest::new()
    }

    fn clear(&mut self) {
        self.project_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCurrentSpaceForArcProjectIdRequest {
        static instance: GetCurrentSpaceForArcProjectIdRequest = GetCurrentSpaceForArcProjectIdRequest {
            project_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetCurrentSpaceForArcProjectIdReply)
pub struct GetCurrentSpaceForArcProjectIdReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetCurrentSpaceForArcProjectIdReply.cur_space)
    pub cur_space: i64,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetCurrentSpaceForArcProjectIdReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCurrentSpaceForArcProjectIdReply {
    fn default() -> &'a GetCurrentSpaceForArcProjectIdReply {
        <GetCurrentSpaceForArcProjectIdReply as ::protobuf::Message>::default_instance()
    }
}

impl GetCurrentSpaceForArcProjectIdReply {
    pub fn new() -> GetCurrentSpaceForArcProjectIdReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetCurrentSpaceForArcProjectIdReply {
    const NAME: &'static str = "GetCurrentSpaceForArcProjectIdReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cur_space = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.cur_space != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.cur_space);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.cur_space != 0 {
            os.write_int64(1, self.cur_space)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCurrentSpaceForArcProjectIdReply {
        GetCurrentSpaceForArcProjectIdReply::new()
    }

    fn clear(&mut self) {
        self.cur_space = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCurrentSpaceForArcProjectIdReply {
        static instance: GetCurrentSpaceForArcProjectIdReply = GetCurrentSpaceForArcProjectIdReply {
            cur_space: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.SetMediaRWDataFileProjectIdRequest)
pub struct SetMediaRWDataFileProjectIdRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.SetMediaRWDataFileProjectIdRequest.project_id)
    pub project_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.SetMediaRWDataFileProjectIdRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetMediaRWDataFileProjectIdRequest {
    fn default() -> &'a SetMediaRWDataFileProjectIdRequest {
        <SetMediaRWDataFileProjectIdRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetMediaRWDataFileProjectIdRequest {
    pub fn new() -> SetMediaRWDataFileProjectIdRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetMediaRWDataFileProjectIdRequest {
    const NAME: &'static str = "SetMediaRWDataFileProjectIdRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.project_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.project_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.project_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.project_id != 0 {
            os.write_uint32(1, self.project_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetMediaRWDataFileProjectIdRequest {
        SetMediaRWDataFileProjectIdRequest::new()
    }

    fn clear(&mut self) {
        self.project_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetMediaRWDataFileProjectIdRequest {
        static instance: SetMediaRWDataFileProjectIdRequest = SetMediaRWDataFileProjectIdRequest {
            project_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.SetMediaRWDataFileProjectIdReply)
pub struct SetMediaRWDataFileProjectIdReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.SetMediaRWDataFileProjectIdReply.success)
    pub success: bool,
    // @@protoc_insertion_point(field:user_data_auth.SetMediaRWDataFileProjectIdReply.error)
    pub error: i32,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.SetMediaRWDataFileProjectIdReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetMediaRWDataFileProjectIdReply {
    fn default() -> &'a SetMediaRWDataFileProjectIdReply {
        <SetMediaRWDataFileProjectIdReply as ::protobuf::Message>::default_instance()
    }
}

impl SetMediaRWDataFileProjectIdReply {
    pub fn new() -> SetMediaRWDataFileProjectIdReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetMediaRWDataFileProjectIdReply {
    const NAME: &'static str = "SetMediaRWDataFileProjectIdReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                16 => {
                    self.error = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.error != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.error != 0 {
            os.write_int32(2, self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetMediaRWDataFileProjectIdReply {
        SetMediaRWDataFileProjectIdReply::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.error = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetMediaRWDataFileProjectIdReply {
        static instance: SetMediaRWDataFileProjectIdReply = SetMediaRWDataFileProjectIdReply {
            success: false,
            error: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.SetMediaRWDataFileProjectInheritanceFlagRequest)
pub struct SetMediaRWDataFileProjectInheritanceFlagRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.SetMediaRWDataFileProjectInheritanceFlagRequest.enable)
    pub enable: bool,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.SetMediaRWDataFileProjectInheritanceFlagRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetMediaRWDataFileProjectInheritanceFlagRequest {
    fn default() -> &'a SetMediaRWDataFileProjectInheritanceFlagRequest {
        <SetMediaRWDataFileProjectInheritanceFlagRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetMediaRWDataFileProjectInheritanceFlagRequest {
    pub fn new() -> SetMediaRWDataFileProjectInheritanceFlagRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetMediaRWDataFileProjectInheritanceFlagRequest {
    const NAME: &'static str = "SetMediaRWDataFileProjectInheritanceFlagRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enable = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.enable != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.enable != false {
            os.write_bool(1, self.enable)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetMediaRWDataFileProjectInheritanceFlagRequest {
        SetMediaRWDataFileProjectInheritanceFlagRequest::new()
    }

    fn clear(&mut self) {
        self.enable = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetMediaRWDataFileProjectInheritanceFlagRequest {
        static instance: SetMediaRWDataFileProjectInheritanceFlagRequest = SetMediaRWDataFileProjectInheritanceFlagRequest {
            enable: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.SetMediaRWDataFileProjectInheritanceFlagReply)
pub struct SetMediaRWDataFileProjectInheritanceFlagReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.SetMediaRWDataFileProjectInheritanceFlagReply.success)
    pub success: bool,
    // @@protoc_insertion_point(field:user_data_auth.SetMediaRWDataFileProjectInheritanceFlagReply.error)
    pub error: i32,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.SetMediaRWDataFileProjectInheritanceFlagReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetMediaRWDataFileProjectInheritanceFlagReply {
    fn default() -> &'a SetMediaRWDataFileProjectInheritanceFlagReply {
        <SetMediaRWDataFileProjectInheritanceFlagReply as ::protobuf::Message>::default_instance()
    }
}

impl SetMediaRWDataFileProjectInheritanceFlagReply {
    pub fn new() -> SetMediaRWDataFileProjectInheritanceFlagReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetMediaRWDataFileProjectInheritanceFlagReply {
    const NAME: &'static str = "SetMediaRWDataFileProjectInheritanceFlagReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                16 => {
                    self.error = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.error != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if self.error != 0 {
            os.write_int32(2, self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetMediaRWDataFileProjectInheritanceFlagReply {
        SetMediaRWDataFileProjectInheritanceFlagReply::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.error = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetMediaRWDataFileProjectInheritanceFlagReply {
        static instance: SetMediaRWDataFileProjectInheritanceFlagReply = SetMediaRWDataFileProjectInheritanceFlagReply {
            success: false,
            error: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.TpmTokenInfo)
pub struct TpmTokenInfo {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.TpmTokenInfo.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.TpmTokenInfo.user_pin)
    pub user_pin: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.TpmTokenInfo.slot)
    pub slot: i32,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.TpmTokenInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TpmTokenInfo {
    fn default() -> &'a TpmTokenInfo {
        <TpmTokenInfo as ::protobuf::Message>::default_instance()
    }
}

impl TpmTokenInfo {
    pub fn new() -> TpmTokenInfo {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TpmTokenInfo {
    const NAME: &'static str = "TpmTokenInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.label = is.read_string()?;
                },
                18 => {
                    self.user_pin = is.read_string()?;
                },
                24 => {
                    self.slot = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        if !self.user_pin.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user_pin);
        }
        if self.slot != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.slot);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        if !self.user_pin.is_empty() {
            os.write_string(2, &self.user_pin)?;
        }
        if self.slot != 0 {
            os.write_int32(3, self.slot)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TpmTokenInfo {
        TpmTokenInfo::new()
    }

    fn clear(&mut self) {
        self.label.clear();
        self.user_pin.clear();
        self.slot = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TpmTokenInfo {
        static instance: TpmTokenInfo = TpmTokenInfo {
            label: ::std::string::String::new(),
            user_pin: ::std::string::String::new(),
            slot: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.Pkcs11IsTpmTokenReadyRequest)
pub struct Pkcs11IsTpmTokenReadyRequest {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.Pkcs11IsTpmTokenReadyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pkcs11IsTpmTokenReadyRequest {
    fn default() -> &'a Pkcs11IsTpmTokenReadyRequest {
        <Pkcs11IsTpmTokenReadyRequest as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11IsTpmTokenReadyRequest {
    pub fn new() -> Pkcs11IsTpmTokenReadyRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Pkcs11IsTpmTokenReadyRequest {
    const NAME: &'static str = "Pkcs11IsTpmTokenReadyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pkcs11IsTpmTokenReadyRequest {
        Pkcs11IsTpmTokenReadyRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pkcs11IsTpmTokenReadyRequest {
        static instance: Pkcs11IsTpmTokenReadyRequest = Pkcs11IsTpmTokenReadyRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.Pkcs11IsTpmTokenReadyReply)
pub struct Pkcs11IsTpmTokenReadyReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.Pkcs11IsTpmTokenReadyReply.ready)
    pub ready: bool,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.Pkcs11IsTpmTokenReadyReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pkcs11IsTpmTokenReadyReply {
    fn default() -> &'a Pkcs11IsTpmTokenReadyReply {
        <Pkcs11IsTpmTokenReadyReply as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11IsTpmTokenReadyReply {
    pub fn new() -> Pkcs11IsTpmTokenReadyReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Pkcs11IsTpmTokenReadyReply {
    const NAME: &'static str = "Pkcs11IsTpmTokenReadyReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ready = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ready != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ready != false {
            os.write_bool(1, self.ready)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pkcs11IsTpmTokenReadyReply {
        Pkcs11IsTpmTokenReadyReply::new()
    }

    fn clear(&mut self) {
        self.ready = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pkcs11IsTpmTokenReadyReply {
        static instance: Pkcs11IsTpmTokenReadyReply = Pkcs11IsTpmTokenReadyReply {
            ready: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.Pkcs11GetTpmTokenInfoRequest)
pub struct Pkcs11GetTpmTokenInfoRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.Pkcs11GetTpmTokenInfoRequest.username)
    pub username: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.Pkcs11GetTpmTokenInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pkcs11GetTpmTokenInfoRequest {
    fn default() -> &'a Pkcs11GetTpmTokenInfoRequest {
        <Pkcs11GetTpmTokenInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11GetTpmTokenInfoRequest {
    pub fn new() -> Pkcs11GetTpmTokenInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Pkcs11GetTpmTokenInfoRequest {
    const NAME: &'static str = "Pkcs11GetTpmTokenInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.username = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pkcs11GetTpmTokenInfoRequest {
        Pkcs11GetTpmTokenInfoRequest::new()
    }

    fn clear(&mut self) {
        self.username.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pkcs11GetTpmTokenInfoRequest {
        static instance: Pkcs11GetTpmTokenInfoRequest = Pkcs11GetTpmTokenInfoRequest {
            username: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.Pkcs11GetTpmTokenInfoReply)
pub struct Pkcs11GetTpmTokenInfoReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.Pkcs11GetTpmTokenInfoReply.token_info)
    pub token_info: ::protobuf::MessageField<TpmTokenInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.Pkcs11GetTpmTokenInfoReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pkcs11GetTpmTokenInfoReply {
    fn default() -> &'a Pkcs11GetTpmTokenInfoReply {
        <Pkcs11GetTpmTokenInfoReply as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11GetTpmTokenInfoReply {
    pub fn new() -> Pkcs11GetTpmTokenInfoReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Pkcs11GetTpmTokenInfoReply {
    const NAME: &'static str = "Pkcs11GetTpmTokenInfoReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pkcs11GetTpmTokenInfoReply {
        Pkcs11GetTpmTokenInfoReply::new()
    }

    fn clear(&mut self) {
        self.token_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pkcs11GetTpmTokenInfoReply {
        static instance: Pkcs11GetTpmTokenInfoReply = Pkcs11GetTpmTokenInfoReply {
            token_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.Pkcs11TerminateRequest)
pub struct Pkcs11TerminateRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.Pkcs11TerminateRequest.username)
    pub username: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.Pkcs11TerminateRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pkcs11TerminateRequest {
    fn default() -> &'a Pkcs11TerminateRequest {
        <Pkcs11TerminateRequest as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11TerminateRequest {
    pub fn new() -> Pkcs11TerminateRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Pkcs11TerminateRequest {
    const NAME: &'static str = "Pkcs11TerminateRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.username = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pkcs11TerminateRequest {
        Pkcs11TerminateRequest::new()
    }

    fn clear(&mut self) {
        self.username.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pkcs11TerminateRequest {
        static instance: Pkcs11TerminateRequest = Pkcs11TerminateRequest {
            username: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.Pkcs11TerminateReply)
pub struct Pkcs11TerminateReply {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.Pkcs11TerminateReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pkcs11TerminateReply {
    fn default() -> &'a Pkcs11TerminateReply {
        <Pkcs11TerminateReply as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11TerminateReply {
    pub fn new() -> Pkcs11TerminateReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Pkcs11TerminateReply {
    const NAME: &'static str = "Pkcs11TerminateReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pkcs11TerminateReply {
        Pkcs11TerminateReply::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pkcs11TerminateReply {
        static instance: Pkcs11TerminateReply = Pkcs11TerminateReply {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.Pkcs11RestoreTpmTokensRequest)
pub struct Pkcs11RestoreTpmTokensRequest {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.Pkcs11RestoreTpmTokensRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pkcs11RestoreTpmTokensRequest {
    fn default() -> &'a Pkcs11RestoreTpmTokensRequest {
        <Pkcs11RestoreTpmTokensRequest as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11RestoreTpmTokensRequest {
    pub fn new() -> Pkcs11RestoreTpmTokensRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Pkcs11RestoreTpmTokensRequest {
    const NAME: &'static str = "Pkcs11RestoreTpmTokensRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pkcs11RestoreTpmTokensRequest {
        Pkcs11RestoreTpmTokensRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pkcs11RestoreTpmTokensRequest {
        static instance: Pkcs11RestoreTpmTokensRequest = Pkcs11RestoreTpmTokensRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.Pkcs11RestoreTpmTokensReply)
pub struct Pkcs11RestoreTpmTokensReply {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.Pkcs11RestoreTpmTokensReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pkcs11RestoreTpmTokensReply {
    fn default() -> &'a Pkcs11RestoreTpmTokensReply {
        <Pkcs11RestoreTpmTokensReply as ::protobuf::Message>::default_instance()
    }
}

impl Pkcs11RestoreTpmTokensReply {
    pub fn new() -> Pkcs11RestoreTpmTokensReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Pkcs11RestoreTpmTokensReply {
    const NAME: &'static str = "Pkcs11RestoreTpmTokensReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pkcs11RestoreTpmTokensReply {
        Pkcs11RestoreTpmTokensReply::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pkcs11RestoreTpmTokensReply {
        static instance: Pkcs11RestoreTpmTokensReply = Pkcs11RestoreTpmTokensReply {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.InstallAttributesGetRequest)
pub struct InstallAttributesGetRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.InstallAttributesGetRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.InstallAttributesGetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstallAttributesGetRequest {
    fn default() -> &'a InstallAttributesGetRequest {
        <InstallAttributesGetRequest as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesGetRequest {
    pub fn new() -> InstallAttributesGetRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InstallAttributesGetRequest {
    const NAME: &'static str = "InstallAttributesGetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstallAttributesGetRequest {
        InstallAttributesGetRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstallAttributesGetRequest {
        static instance: InstallAttributesGetRequest = InstallAttributesGetRequest {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.InstallAttributesGetReply)
pub struct InstallAttributesGetReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.InstallAttributesGetReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.InstallAttributesGetReply.value)
    pub value: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.InstallAttributesGetReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstallAttributesGetReply {
    fn default() -> &'a InstallAttributesGetReply {
        <InstallAttributesGetReply as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesGetReply {
    pub fn new() -> InstallAttributesGetReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InstallAttributesGetReply {
    const NAME: &'static str = "InstallAttributesGetReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.value = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstallAttributesGetReply {
        InstallAttributesGetReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstallAttributesGetReply {
        static instance: InstallAttributesGetReply = InstallAttributesGetReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            value: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.InstallAttributesSetRequest)
pub struct InstallAttributesSetRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.InstallAttributesSetRequest.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.InstallAttributesSetRequest.value)
    pub value: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.InstallAttributesSetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstallAttributesSetRequest {
    fn default() -> &'a InstallAttributesSetRequest {
        <InstallAttributesSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesSetRequest {
    pub fn new() -> InstallAttributesSetRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InstallAttributesSetRequest {
    const NAME: &'static str = "InstallAttributesSetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.value = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstallAttributesSetRequest {
        InstallAttributesSetRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstallAttributesSetRequest {
        static instance: InstallAttributesSetRequest = InstallAttributesSetRequest {
            name: ::std::string::String::new(),
            value: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.InstallAttributesSetReply)
pub struct InstallAttributesSetReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.InstallAttributesSetReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.InstallAttributesSetReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstallAttributesSetReply {
    fn default() -> &'a InstallAttributesSetReply {
        <InstallAttributesSetReply as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesSetReply {
    pub fn new() -> InstallAttributesSetReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InstallAttributesSetReply {
    const NAME: &'static str = "InstallAttributesSetReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstallAttributesSetReply {
        InstallAttributesSetReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstallAttributesSetReply {
        static instance: InstallAttributesSetReply = InstallAttributesSetReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.InstallAttributesFinalizeRequest)
pub struct InstallAttributesFinalizeRequest {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.InstallAttributesFinalizeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstallAttributesFinalizeRequest {
    fn default() -> &'a InstallAttributesFinalizeRequest {
        <InstallAttributesFinalizeRequest as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesFinalizeRequest {
    pub fn new() -> InstallAttributesFinalizeRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InstallAttributesFinalizeRequest {
    const NAME: &'static str = "InstallAttributesFinalizeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstallAttributesFinalizeRequest {
        InstallAttributesFinalizeRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstallAttributesFinalizeRequest {
        static instance: InstallAttributesFinalizeRequest = InstallAttributesFinalizeRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.InstallAttributesFinalizeReply)
pub struct InstallAttributesFinalizeReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.InstallAttributesFinalizeReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.InstallAttributesFinalizeReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstallAttributesFinalizeReply {
    fn default() -> &'a InstallAttributesFinalizeReply {
        <InstallAttributesFinalizeReply as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesFinalizeReply {
    pub fn new() -> InstallAttributesFinalizeReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InstallAttributesFinalizeReply {
    const NAME: &'static str = "InstallAttributesFinalizeReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstallAttributesFinalizeReply {
        InstallAttributesFinalizeReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstallAttributesFinalizeReply {
        static instance: InstallAttributesFinalizeReply = InstallAttributesFinalizeReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.InstallAttributesGetStatusRequest)
pub struct InstallAttributesGetStatusRequest {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.InstallAttributesGetStatusRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstallAttributesGetStatusRequest {
    fn default() -> &'a InstallAttributesGetStatusRequest {
        <InstallAttributesGetStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesGetStatusRequest {
    pub fn new() -> InstallAttributesGetStatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InstallAttributesGetStatusRequest {
    const NAME: &'static str = "InstallAttributesGetStatusRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstallAttributesGetStatusRequest {
        InstallAttributesGetStatusRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstallAttributesGetStatusRequest {
        static instance: InstallAttributesGetStatusRequest = InstallAttributesGetStatusRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.InstallAttributesGetStatusReply)
pub struct InstallAttributesGetStatusReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.InstallAttributesGetStatusReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.InstallAttributesGetStatusReply.count)
    pub count: i32,
    // @@protoc_insertion_point(field:user_data_auth.InstallAttributesGetStatusReply.is_secure)
    pub is_secure: bool,
    // @@protoc_insertion_point(field:user_data_auth.InstallAttributesGetStatusReply.state)
    pub state: ::protobuf::EnumOrUnknown<InstallAttributesState>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.InstallAttributesGetStatusReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstallAttributesGetStatusReply {
    fn default() -> &'a InstallAttributesGetStatusReply {
        <InstallAttributesGetStatusReply as ::protobuf::Message>::default_instance()
    }
}

impl InstallAttributesGetStatusReply {
    pub fn new() -> InstallAttributesGetStatusReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InstallAttributesGetStatusReply {
    const NAME: &'static str = "InstallAttributesGetStatusReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.count = is.read_int32()?;
                },
                24 => {
                    self.is_secure = is.read_bool()?;
                },
                32 => {
                    self.state = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.count);
        }
        if self.is_secure != false {
            my_size += 1 + 1;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(InstallAttributesState::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(4, self.state.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if self.count != 0 {
            os.write_int32(2, self.count)?;
        }
        if self.is_secure != false {
            os.write_bool(3, self.is_secure)?;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(InstallAttributesState::UNKNOWN) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.state))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstallAttributesGetStatusReply {
        InstallAttributesGetStatusReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.count = 0;
        self.is_secure = false;
        self.state = ::protobuf::EnumOrUnknown::new(InstallAttributesState::UNKNOWN);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstallAttributesGetStatusReply {
        static instance: InstallAttributesGetStatusReply = InstallAttributesGetStatusReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            count: 0,
            is_secure: false,
            state: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.FirmwareManagementParameters)
pub struct FirmwareManagementParameters {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.FirmwareManagementParameters.flags)
    pub flags: u32,
    // @@protoc_insertion_point(field:user_data_auth.FirmwareManagementParameters.developer_key_hash)
    pub developer_key_hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.FirmwareManagementParameters.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FirmwareManagementParameters {
    fn default() -> &'a FirmwareManagementParameters {
        <FirmwareManagementParameters as ::protobuf::Message>::default_instance()
    }
}

impl FirmwareManagementParameters {
    pub fn new() -> FirmwareManagementParameters {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FirmwareManagementParameters {
    const NAME: &'static str = "FirmwareManagementParameters";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.flags = is.read_uint32()?;
                },
                18 => {
                    self.developer_key_hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.flags != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.flags);
        }
        if !self.developer_key_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.developer_key_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.flags != 0 {
            os.write_uint32(1, self.flags)?;
        }
        if !self.developer_key_hash.is_empty() {
            os.write_bytes(2, &self.developer_key_hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FirmwareManagementParameters {
        FirmwareManagementParameters::new()
    }

    fn clear(&mut self) {
        self.flags = 0;
        self.developer_key_hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FirmwareManagementParameters {
        static instance: FirmwareManagementParameters = FirmwareManagementParameters {
            flags: 0,
            developer_key_hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetFirmwareManagementParametersRequest)
pub struct GetFirmwareManagementParametersRequest {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetFirmwareManagementParametersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFirmwareManagementParametersRequest {
    fn default() -> &'a GetFirmwareManagementParametersRequest {
        <GetFirmwareManagementParametersRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFirmwareManagementParametersRequest {
    pub fn new() -> GetFirmwareManagementParametersRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetFirmwareManagementParametersRequest {
    const NAME: &'static str = "GetFirmwareManagementParametersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFirmwareManagementParametersRequest {
        GetFirmwareManagementParametersRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFirmwareManagementParametersRequest {
        static instance: GetFirmwareManagementParametersRequest = GetFirmwareManagementParametersRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetFirmwareManagementParametersReply)
pub struct GetFirmwareManagementParametersReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetFirmwareManagementParametersReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.GetFirmwareManagementParametersReply.fwmp)
    pub fwmp: ::protobuf::MessageField<FirmwareManagementParameters>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetFirmwareManagementParametersReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFirmwareManagementParametersReply {
    fn default() -> &'a GetFirmwareManagementParametersReply {
        <GetFirmwareManagementParametersReply as ::protobuf::Message>::default_instance()
    }
}

impl GetFirmwareManagementParametersReply {
    pub fn new() -> GetFirmwareManagementParametersReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetFirmwareManagementParametersReply {
    const NAME: &'static str = "GetFirmwareManagementParametersReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fwmp)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.fwmp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.fwmp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFirmwareManagementParametersReply {
        GetFirmwareManagementParametersReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.fwmp.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFirmwareManagementParametersReply {
        static instance: GetFirmwareManagementParametersReply = GetFirmwareManagementParametersReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            fwmp: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.RemoveFirmwareManagementParametersRequest)
pub struct RemoveFirmwareManagementParametersRequest {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.RemoveFirmwareManagementParametersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveFirmwareManagementParametersRequest {
    fn default() -> &'a RemoveFirmwareManagementParametersRequest {
        <RemoveFirmwareManagementParametersRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveFirmwareManagementParametersRequest {
    pub fn new() -> RemoveFirmwareManagementParametersRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RemoveFirmwareManagementParametersRequest {
    const NAME: &'static str = "RemoveFirmwareManagementParametersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveFirmwareManagementParametersRequest {
        RemoveFirmwareManagementParametersRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveFirmwareManagementParametersRequest {
        static instance: RemoveFirmwareManagementParametersRequest = RemoveFirmwareManagementParametersRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.RemoveFirmwareManagementParametersReply)
pub struct RemoveFirmwareManagementParametersReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.RemoveFirmwareManagementParametersReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.RemoveFirmwareManagementParametersReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveFirmwareManagementParametersReply {
    fn default() -> &'a RemoveFirmwareManagementParametersReply {
        <RemoveFirmwareManagementParametersReply as ::protobuf::Message>::default_instance()
    }
}

impl RemoveFirmwareManagementParametersReply {
    pub fn new() -> RemoveFirmwareManagementParametersReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RemoveFirmwareManagementParametersReply {
    const NAME: &'static str = "RemoveFirmwareManagementParametersReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveFirmwareManagementParametersReply {
        RemoveFirmwareManagementParametersReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveFirmwareManagementParametersReply {
        static instance: RemoveFirmwareManagementParametersReply = RemoveFirmwareManagementParametersReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.SetFirmwareManagementParametersRequest)
pub struct SetFirmwareManagementParametersRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.SetFirmwareManagementParametersRequest.fwmp)
    pub fwmp: ::protobuf::MessageField<FirmwareManagementParameters>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.SetFirmwareManagementParametersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetFirmwareManagementParametersRequest {
    fn default() -> &'a SetFirmwareManagementParametersRequest {
        <SetFirmwareManagementParametersRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetFirmwareManagementParametersRequest {
    pub fn new() -> SetFirmwareManagementParametersRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetFirmwareManagementParametersRequest {
    const NAME: &'static str = "SetFirmwareManagementParametersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fwmp)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fwmp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fwmp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetFirmwareManagementParametersRequest {
        SetFirmwareManagementParametersRequest::new()
    }

    fn clear(&mut self) {
        self.fwmp.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetFirmwareManagementParametersRequest {
        static instance: SetFirmwareManagementParametersRequest = SetFirmwareManagementParametersRequest {
            fwmp: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.SetFirmwareManagementParametersReply)
pub struct SetFirmwareManagementParametersReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.SetFirmwareManagementParametersReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.SetFirmwareManagementParametersReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetFirmwareManagementParametersReply {
    fn default() -> &'a SetFirmwareManagementParametersReply {
        <SetFirmwareManagementParametersReply as ::protobuf::Message>::default_instance()
    }
}

impl SetFirmwareManagementParametersReply {
    pub fn new() -> SetFirmwareManagementParametersReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetFirmwareManagementParametersReply {
    const NAME: &'static str = "SetFirmwareManagementParametersReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetFirmwareManagementParametersReply {
        SetFirmwareManagementParametersReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetFirmwareManagementParametersReply {
        static instance: SetFirmwareManagementParametersReply = SetFirmwareManagementParametersReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetSystemSaltRequest)
pub struct GetSystemSaltRequest {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetSystemSaltRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSystemSaltRequest {
    fn default() -> &'a GetSystemSaltRequest {
        <GetSystemSaltRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSystemSaltRequest {
    pub fn new() -> GetSystemSaltRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSystemSaltRequest {
    const NAME: &'static str = "GetSystemSaltRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSystemSaltRequest {
        GetSystemSaltRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSystemSaltRequest {
        static instance: GetSystemSaltRequest = GetSystemSaltRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetSystemSaltReply)
pub struct GetSystemSaltReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetSystemSaltReply.salt)
    pub salt: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetSystemSaltReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSystemSaltReply {
    fn default() -> &'a GetSystemSaltReply {
        <GetSystemSaltReply as ::protobuf::Message>::default_instance()
    }
}

impl GetSystemSaltReply {
    pub fn new() -> GetSystemSaltReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSystemSaltReply {
    const NAME: &'static str = "GetSystemSaltReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.salt = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.salt.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.salt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.salt.is_empty() {
            os.write_bytes(1, &self.salt)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSystemSaltReply {
        GetSystemSaltReply::new()
    }

    fn clear(&mut self) {
        self.salt.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSystemSaltReply {
        static instance: GetSystemSaltReply = GetSystemSaltReply {
            salt: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.UpdateCurrentUserActivityTimestampRequest)
pub struct UpdateCurrentUserActivityTimestampRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.UpdateCurrentUserActivityTimestampRequest.time_shift_sec)
    pub time_shift_sec: i32,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.UpdateCurrentUserActivityTimestampRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateCurrentUserActivityTimestampRequest {
    fn default() -> &'a UpdateCurrentUserActivityTimestampRequest {
        <UpdateCurrentUserActivityTimestampRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateCurrentUserActivityTimestampRequest {
    pub fn new() -> UpdateCurrentUserActivityTimestampRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateCurrentUserActivityTimestampRequest {
    const NAME: &'static str = "UpdateCurrentUserActivityTimestampRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.time_shift_sec = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.time_shift_sec != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.time_shift_sec);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.time_shift_sec != 0 {
            os.write_int32(1, self.time_shift_sec)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateCurrentUserActivityTimestampRequest {
        UpdateCurrentUserActivityTimestampRequest::new()
    }

    fn clear(&mut self) {
        self.time_shift_sec = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateCurrentUserActivityTimestampRequest {
        static instance: UpdateCurrentUserActivityTimestampRequest = UpdateCurrentUserActivityTimestampRequest {
            time_shift_sec: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.UpdateCurrentUserActivityTimestampReply)
pub struct UpdateCurrentUserActivityTimestampReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.UpdateCurrentUserActivityTimestampReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.UpdateCurrentUserActivityTimestampReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateCurrentUserActivityTimestampReply {
    fn default() -> &'a UpdateCurrentUserActivityTimestampReply {
        <UpdateCurrentUserActivityTimestampReply as ::protobuf::Message>::default_instance()
    }
}

impl UpdateCurrentUserActivityTimestampReply {
    pub fn new() -> UpdateCurrentUserActivityTimestampReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateCurrentUserActivityTimestampReply {
    const NAME: &'static str = "UpdateCurrentUserActivityTimestampReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateCurrentUserActivityTimestampReply {
        UpdateCurrentUserActivityTimestampReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateCurrentUserActivityTimestampReply {
        static instance: UpdateCurrentUserActivityTimestampReply = UpdateCurrentUserActivityTimestampReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetSanitizedUsernameRequest)
pub struct GetSanitizedUsernameRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetSanitizedUsernameRequest.username)
    pub username: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetSanitizedUsernameRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSanitizedUsernameRequest {
    fn default() -> &'a GetSanitizedUsernameRequest {
        <GetSanitizedUsernameRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSanitizedUsernameRequest {
    pub fn new() -> GetSanitizedUsernameRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSanitizedUsernameRequest {
    const NAME: &'static str = "GetSanitizedUsernameRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.username = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSanitizedUsernameRequest {
        GetSanitizedUsernameRequest::new()
    }

    fn clear(&mut self) {
        self.username.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSanitizedUsernameRequest {
        static instance: GetSanitizedUsernameRequest = GetSanitizedUsernameRequest {
            username: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetSanitizedUsernameReply)
pub struct GetSanitizedUsernameReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetSanitizedUsernameReply.sanitized_username)
    pub sanitized_username: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetSanitizedUsernameReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSanitizedUsernameReply {
    fn default() -> &'a GetSanitizedUsernameReply {
        <GetSanitizedUsernameReply as ::protobuf::Message>::default_instance()
    }
}

impl GetSanitizedUsernameReply {
    pub fn new() -> GetSanitizedUsernameReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetSanitizedUsernameReply {
    const NAME: &'static str = "GetSanitizedUsernameReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sanitized_username = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.sanitized_username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sanitized_username);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.sanitized_username.is_empty() {
            os.write_string(1, &self.sanitized_username)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSanitizedUsernameReply {
        GetSanitizedUsernameReply::new()
    }

    fn clear(&mut self) {
        self.sanitized_username.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSanitizedUsernameReply {
        static instance: GetSanitizedUsernameReply = GetSanitizedUsernameReply {
            sanitized_username: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetLoginStatusRequest)
pub struct GetLoginStatusRequest {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetLoginStatusRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetLoginStatusRequest {
    fn default() -> &'a GetLoginStatusRequest {
        <GetLoginStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetLoginStatusRequest {
    pub fn new() -> GetLoginStatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetLoginStatusRequest {
    const NAME: &'static str = "GetLoginStatusRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetLoginStatusRequest {
        GetLoginStatusRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetLoginStatusRequest {
        static instance: GetLoginStatusRequest = GetLoginStatusRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetLoginStatusReply)
pub struct GetLoginStatusReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetLoginStatusReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.GetLoginStatusReply.owner_user_exists)
    pub owner_user_exists: bool,
    // @@protoc_insertion_point(field:user_data_auth.GetLoginStatusReply.is_locked_to_single_user)
    pub is_locked_to_single_user: bool,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetLoginStatusReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetLoginStatusReply {
    fn default() -> &'a GetLoginStatusReply {
        <GetLoginStatusReply as ::protobuf::Message>::default_instance()
    }
}

impl GetLoginStatusReply {
    pub fn new() -> GetLoginStatusReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetLoginStatusReply {
    const NAME: &'static str = "GetLoginStatusReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.owner_user_exists = is.read_bool()?;
                },
                24 => {
                    self.is_locked_to_single_user = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if self.owner_user_exists != false {
            my_size += 1 + 1;
        }
        if self.is_locked_to_single_user != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if self.owner_user_exists != false {
            os.write_bool(2, self.owner_user_exists)?;
        }
        if self.is_locked_to_single_user != false {
            os.write_bool(3, self.is_locked_to_single_user)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetLoginStatusReply {
        GetLoginStatusReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.owner_user_exists = false;
        self.is_locked_to_single_user = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetLoginStatusReply {
        static instance: GetLoginStatusReply = GetLoginStatusReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            owner_user_exists: false,
            is_locked_to_single_user: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.LockToSingleUserMountUntilRebootRequest)
pub struct LockToSingleUserMountUntilRebootRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.LockToSingleUserMountUntilRebootRequest.account_id)
    pub account_id: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.LockToSingleUserMountUntilRebootRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LockToSingleUserMountUntilRebootRequest {
    fn default() -> &'a LockToSingleUserMountUntilRebootRequest {
        <LockToSingleUserMountUntilRebootRequest as ::protobuf::Message>::default_instance()
    }
}

impl LockToSingleUserMountUntilRebootRequest {
    pub fn new() -> LockToSingleUserMountUntilRebootRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LockToSingleUserMountUntilRebootRequest {
    const NAME: &'static str = "LockToSingleUserMountUntilRebootRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LockToSingleUserMountUntilRebootRequest {
        LockToSingleUserMountUntilRebootRequest::new()
    }

    fn clear(&mut self) {
        self.account_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LockToSingleUserMountUntilRebootRequest {
        static instance: LockToSingleUserMountUntilRebootRequest = LockToSingleUserMountUntilRebootRequest {
            account_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.LockToSingleUserMountUntilRebootReply)
pub struct LockToSingleUserMountUntilRebootReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.LockToSingleUserMountUntilRebootReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.LockToSingleUserMountUntilRebootReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LockToSingleUserMountUntilRebootReply {
    fn default() -> &'a LockToSingleUserMountUntilRebootReply {
        <LockToSingleUserMountUntilRebootReply as ::protobuf::Message>::default_instance()
    }
}

impl LockToSingleUserMountUntilRebootReply {
    pub fn new() -> LockToSingleUserMountUntilRebootReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LockToSingleUserMountUntilRebootReply {
    const NAME: &'static str = "LockToSingleUserMountUntilRebootReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LockToSingleUserMountUntilRebootReply {
        LockToSingleUserMountUntilRebootReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LockToSingleUserMountUntilRebootReply {
        static instance: LockToSingleUserMountUntilRebootReply = LockToSingleUserMountUntilRebootReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetRsuDeviceIdReply)
pub struct GetRsuDeviceIdReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetRsuDeviceIdReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.GetRsuDeviceIdReply.rsu_device_id)
    pub rsu_device_id: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetRsuDeviceIdReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetRsuDeviceIdReply {
    fn default() -> &'a GetRsuDeviceIdReply {
        <GetRsuDeviceIdReply as ::protobuf::Message>::default_instance()
    }
}

impl GetRsuDeviceIdReply {
    pub fn new() -> GetRsuDeviceIdReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetRsuDeviceIdReply {
    const NAME: &'static str = "GetRsuDeviceIdReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.rsu_device_id = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if !self.rsu_device_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.rsu_device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if !self.rsu_device_id.is_empty() {
            os.write_bytes(2, &self.rsu_device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetRsuDeviceIdReply {
        GetRsuDeviceIdReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.rsu_device_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetRsuDeviceIdReply {
        static instance: GetRsuDeviceIdReply = GetRsuDeviceIdReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            rsu_device_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetRsuDeviceIdRequest)
pub struct GetRsuDeviceIdRequest {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetRsuDeviceIdRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetRsuDeviceIdRequest {
    fn default() -> &'a GetRsuDeviceIdRequest {
        <GetRsuDeviceIdRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetRsuDeviceIdRequest {
    pub fn new() -> GetRsuDeviceIdRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetRsuDeviceIdRequest {
    const NAME: &'static str = "GetRsuDeviceIdRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetRsuDeviceIdRequest {
        GetRsuDeviceIdRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetRsuDeviceIdRequest {
        static instance: GetRsuDeviceIdRequest = GetRsuDeviceIdRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.ResetApplicationContainerRequest)
pub struct ResetApplicationContainerRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.ResetApplicationContainerRequest.account_id)
    pub account_id: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // @@protoc_insertion_point(field:user_data_auth.ResetApplicationContainerRequest.application_name)
    pub application_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.ResetApplicationContainerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResetApplicationContainerRequest {
    fn default() -> &'a ResetApplicationContainerRequest {
        <ResetApplicationContainerRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResetApplicationContainerRequest {
    pub fn new() -> ResetApplicationContainerRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResetApplicationContainerRequest {
    const NAME: &'static str = "ResetApplicationContainerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_id)?;
                },
                18 => {
                    self.application_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.application_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.application_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.application_name.is_empty() {
            os.write_string(2, &self.application_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResetApplicationContainerRequest {
        ResetApplicationContainerRequest::new()
    }

    fn clear(&mut self) {
        self.account_id.clear();
        self.application_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResetApplicationContainerRequest {
        static instance: ResetApplicationContainerRequest = ResetApplicationContainerRequest {
            account_id: ::protobuf::MessageField::none(),
            application_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.ResetApplicationContainerReply)
pub struct ResetApplicationContainerReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.ResetApplicationContainerReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.ResetApplicationContainerReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.ResetApplicationContainerReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResetApplicationContainerReply {
    fn default() -> &'a ResetApplicationContainerReply {
        <ResetApplicationContainerReply as ::protobuf::Message>::default_instance()
    }
}

impl ResetApplicationContainerReply {
    pub fn new() -> ResetApplicationContainerReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResetApplicationContainerReply {
    const NAME: &'static str = "ResetApplicationContainerReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResetApplicationContainerReply {
        ResetApplicationContainerReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResetApplicationContainerReply {
        static instance: ResetApplicationContainerReply = ResetApplicationContainerReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.FidoMakeCredentialRequest)
pub struct FidoMakeCredentialRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.FidoMakeCredentialRequest.account_id)
    pub account_id: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // @@protoc_insertion_point(field:user_data_auth.FidoMakeCredentialRequest.make_credential_options)
    pub make_credential_options: ::protobuf::MessageField<super::fido::PublicKeyCredentialCreationOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.FidoMakeCredentialRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FidoMakeCredentialRequest {
    fn default() -> &'a FidoMakeCredentialRequest {
        <FidoMakeCredentialRequest as ::protobuf::Message>::default_instance()
    }
}

impl FidoMakeCredentialRequest {
    pub fn new() -> FidoMakeCredentialRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FidoMakeCredentialRequest {
    const NAME: &'static str = "FidoMakeCredentialRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.make_credential_options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.make_credential_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.make_credential_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FidoMakeCredentialRequest {
        FidoMakeCredentialRequest::new()
    }

    fn clear(&mut self) {
        self.account_id.clear();
        self.make_credential_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FidoMakeCredentialRequest {
        static instance: FidoMakeCredentialRequest = FidoMakeCredentialRequest {
            account_id: ::protobuf::MessageField::none(),
            make_credential_options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.FidoMakeCredentialReply)
pub struct FidoMakeCredentialReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.FidoMakeCredentialReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.FidoMakeCredentialReply.make_credential_response)
    pub make_credential_response: ::protobuf::MessageField<super::fido::MakeCredentialAuthenticatorResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.FidoMakeCredentialReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FidoMakeCredentialReply {
    fn default() -> &'a FidoMakeCredentialReply {
        <FidoMakeCredentialReply as ::protobuf::Message>::default_instance()
    }
}

impl FidoMakeCredentialReply {
    pub fn new() -> FidoMakeCredentialReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FidoMakeCredentialReply {
    const NAME: &'static str = "FidoMakeCredentialReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.make_credential_response)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.make_credential_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.make_credential_response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FidoMakeCredentialReply {
        FidoMakeCredentialReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.make_credential_response.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FidoMakeCredentialReply {
        static instance: FidoMakeCredentialReply = FidoMakeCredentialReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            make_credential_response: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.FidoGetAssertionRequest)
pub struct FidoGetAssertionRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.FidoGetAssertionRequest.get_assertion_options)
    pub get_assertion_options: ::protobuf::MessageField<super::fido::PublicKeyCredentialRequestOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.FidoGetAssertionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FidoGetAssertionRequest {
    fn default() -> &'a FidoGetAssertionRequest {
        <FidoGetAssertionRequest as ::protobuf::Message>::default_instance()
    }
}

impl FidoGetAssertionRequest {
    pub fn new() -> FidoGetAssertionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FidoGetAssertionRequest {
    const NAME: &'static str = "FidoGetAssertionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.get_assertion_options)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.get_assertion_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.get_assertion_options.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FidoGetAssertionRequest {
        FidoGetAssertionRequest::new()
    }

    fn clear(&mut self) {
        self.get_assertion_options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FidoGetAssertionRequest {
        static instance: FidoGetAssertionRequest = FidoGetAssertionRequest {
            get_assertion_options: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.FidoGetAssertionReply)
pub struct FidoGetAssertionReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.FidoGetAssertionReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.FidoGetAssertionReply.get_assertion_response)
    pub get_assertion_response: ::protobuf::MessageField<super::fido::GetAssertionAuthenticatorResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.FidoGetAssertionReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FidoGetAssertionReply {
    fn default() -> &'a FidoGetAssertionReply {
        <FidoGetAssertionReply as ::protobuf::Message>::default_instance()
    }
}

impl FidoGetAssertionReply {
    pub fn new() -> FidoGetAssertionReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FidoGetAssertionReply {
    const NAME: &'static str = "FidoGetAssertionReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.get_assertion_response)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.get_assertion_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.get_assertion_response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FidoGetAssertionReply {
        FidoGetAssertionReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.get_assertion_response.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FidoGetAssertionReply {
        static instance: FidoGetAssertionReply = FidoGetAssertionReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            get_assertion_response: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.AddAuthFactorRequest)
pub struct AddAuthFactorRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.AddAuthFactorRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:user_data_auth.AddAuthFactorRequest.auth_factor)
    pub auth_factor: ::protobuf::MessageField<super::auth_factor::AuthFactor>,
    // @@protoc_insertion_point(field:user_data_auth.AddAuthFactorRequest.auth_input)
    pub auth_input: ::protobuf::MessageField<super::auth_factor::AuthInput>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.AddAuthFactorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddAuthFactorRequest {
    fn default() -> &'a AddAuthFactorRequest {
        <AddAuthFactorRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddAuthFactorRequest {
    pub fn new() -> AddAuthFactorRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AddAuthFactorRequest {
    const NAME: &'static str = "AddAuthFactorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.auth_factor)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.auth_input)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if let Some(v) = self.auth_factor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.auth_input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if let Some(v) = self.auth_factor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.auth_input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddAuthFactorRequest {
        AddAuthFactorRequest::new()
    }

    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.auth_factor.clear();
        self.auth_input.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddAuthFactorRequest {
        static instance: AddAuthFactorRequest = AddAuthFactorRequest {
            auth_session_id: ::std::vec::Vec::new(),
            auth_factor: ::protobuf::MessageField::none(),
            auth_input: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.AddAuthFactorReply)
pub struct AddAuthFactorReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.AddAuthFactorReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.AddAuthFactorReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.AddAuthFactorReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddAuthFactorReply {
    fn default() -> &'a AddAuthFactorReply {
        <AddAuthFactorReply as ::protobuf::Message>::default_instance()
    }
}

impl AddAuthFactorReply {
    pub fn new() -> AddAuthFactorReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AddAuthFactorReply {
    const NAME: &'static str = "AddAuthFactorReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddAuthFactorReply {
        AddAuthFactorReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddAuthFactorReply {
        static instance: AddAuthFactorReply = AddAuthFactorReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.AuthenticateAuthFactorRequest)
pub struct AuthenticateAuthFactorRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.AuthenticateAuthFactorRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:user_data_auth.AuthenticateAuthFactorRequest.auth_factor_label)
    pub auth_factor_label: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.AuthenticateAuthFactorRequest.auth_input)
    pub auth_input: ::protobuf::MessageField<super::auth_factor::AuthInput>,
    // @@protoc_insertion_point(field:user_data_auth.AuthenticateAuthFactorRequest.auth_factor_labels)
    pub auth_factor_labels: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.AuthenticateAuthFactorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthenticateAuthFactorRequest {
    fn default() -> &'a AuthenticateAuthFactorRequest {
        <AuthenticateAuthFactorRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticateAuthFactorRequest {
    pub fn new() -> AuthenticateAuthFactorRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthenticateAuthFactorRequest {
    const NAME: &'static str = "AuthenticateAuthFactorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                18 => {
                    self.auth_factor_label = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.auth_input)?;
                },
                34 => {
                    self.auth_factor_labels.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if !self.auth_factor_label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.auth_factor_label);
        }
        if let Some(v) = self.auth_input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.auth_factor_labels {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if !self.auth_factor_label.is_empty() {
            os.write_string(2, &self.auth_factor_label)?;
        }
        if let Some(v) = self.auth_input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.auth_factor_labels {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthenticateAuthFactorRequest {
        AuthenticateAuthFactorRequest::new()
    }

    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.auth_factor_label.clear();
        self.auth_input.clear();
        self.auth_factor_labels.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthenticateAuthFactorRequest {
        static instance: AuthenticateAuthFactorRequest = AuthenticateAuthFactorRequest {
            auth_session_id: ::std::vec::Vec::new(),
            auth_factor_label: ::std::string::String::new(),
            auth_input: ::protobuf::MessageField::none(),
            auth_factor_labels: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.AuthenticateAuthFactorReply)
pub struct AuthenticateAuthFactorReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.AuthenticateAuthFactorReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.AuthenticateAuthFactorReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // @@protoc_insertion_point(field:user_data_auth.AuthenticateAuthFactorReply.authenticated)
    pub authenticated: bool,
    // @@protoc_insertion_point(field:user_data_auth.AuthenticateAuthFactorReply.authorized_for)
    pub authorized_for: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::auth_factor::AuthIntent>>,
    // @@protoc_insertion_point(field:user_data_auth.AuthenticateAuthFactorReply.seconds_left)
    pub seconds_left: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.AuthenticateAuthFactorReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthenticateAuthFactorReply {
    fn default() -> &'a AuthenticateAuthFactorReply {
        <AuthenticateAuthFactorReply as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticateAuthFactorReply {
    pub fn new() -> AuthenticateAuthFactorReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthenticateAuthFactorReply {
    const NAME: &'static str = "AuthenticateAuthFactorReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                24 => {
                    self.authenticated = is.read_bool()?;
                },
                32 => {
                    self.authorized_for.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.authorized_for)?
                },
                40 => {
                    self.seconds_left = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.authenticated != false {
            my_size += 1 + 1;
        }
        for value in &self.authorized_for {
            my_size += ::protobuf::rt::int32_size(4, value.value());
        };
        if let Some(v) = self.seconds_left {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.authenticated != false {
            os.write_bool(3, self.authenticated)?;
        }
        for v in &self.authorized_for {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.seconds_left {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthenticateAuthFactorReply {
        AuthenticateAuthFactorReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.error_info.clear();
        self.authenticated = false;
        self.authorized_for.clear();
        self.seconds_left = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthenticateAuthFactorReply {
        static instance: AuthenticateAuthFactorReply = AuthenticateAuthFactorReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            error_info: ::protobuf::MessageField::none(),
            authenticated: false,
            authorized_for: ::std::vec::Vec::new(),
            seconds_left: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.UpdateAuthFactorRequest)
pub struct UpdateAuthFactorRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.UpdateAuthFactorRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:user_data_auth.UpdateAuthFactorRequest.auth_factor_label)
    pub auth_factor_label: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.UpdateAuthFactorRequest.auth_factor)
    pub auth_factor: ::protobuf::MessageField<super::auth_factor::AuthFactor>,
    // @@protoc_insertion_point(field:user_data_auth.UpdateAuthFactorRequest.auth_input)
    pub auth_input: ::protobuf::MessageField<super::auth_factor::AuthInput>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.UpdateAuthFactorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateAuthFactorRequest {
    fn default() -> &'a UpdateAuthFactorRequest {
        <UpdateAuthFactorRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateAuthFactorRequest {
    pub fn new() -> UpdateAuthFactorRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateAuthFactorRequest {
    const NAME: &'static str = "UpdateAuthFactorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                18 => {
                    self.auth_factor_label = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.auth_factor)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.auth_input)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if !self.auth_factor_label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.auth_factor_label);
        }
        if let Some(v) = self.auth_factor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.auth_input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if !self.auth_factor_label.is_empty() {
            os.write_string(2, &self.auth_factor_label)?;
        }
        if let Some(v) = self.auth_factor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.auth_input.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateAuthFactorRequest {
        UpdateAuthFactorRequest::new()
    }

    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.auth_factor_label.clear();
        self.auth_factor.clear();
        self.auth_input.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateAuthFactorRequest {
        static instance: UpdateAuthFactorRequest = UpdateAuthFactorRequest {
            auth_session_id: ::std::vec::Vec::new(),
            auth_factor_label: ::std::string::String::new(),
            auth_factor: ::protobuf::MessageField::none(),
            auth_input: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.UpdateAuthFactorReply)
pub struct UpdateAuthFactorReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.UpdateAuthFactorReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.UpdateAuthFactorReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.UpdateAuthFactorReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateAuthFactorReply {
    fn default() -> &'a UpdateAuthFactorReply {
        <UpdateAuthFactorReply as ::protobuf::Message>::default_instance()
    }
}

impl UpdateAuthFactorReply {
    pub fn new() -> UpdateAuthFactorReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateAuthFactorReply {
    const NAME: &'static str = "UpdateAuthFactorReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateAuthFactorReply {
        UpdateAuthFactorReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateAuthFactorReply {
        static instance: UpdateAuthFactorReply = UpdateAuthFactorReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.RemoveAuthFactorRequest)
pub struct RemoveAuthFactorRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.RemoveAuthFactorRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:user_data_auth.RemoveAuthFactorRequest.auth_factor_label)
    pub auth_factor_label: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.RemoveAuthFactorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveAuthFactorRequest {
    fn default() -> &'a RemoveAuthFactorRequest {
        <RemoveAuthFactorRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveAuthFactorRequest {
    pub fn new() -> RemoveAuthFactorRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RemoveAuthFactorRequest {
    const NAME: &'static str = "RemoveAuthFactorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                18 => {
                    self.auth_factor_label = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if !self.auth_factor_label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.auth_factor_label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if !self.auth_factor_label.is_empty() {
            os.write_string(2, &self.auth_factor_label)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveAuthFactorRequest {
        RemoveAuthFactorRequest::new()
    }

    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.auth_factor_label.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveAuthFactorRequest {
        static instance: RemoveAuthFactorRequest = RemoveAuthFactorRequest {
            auth_session_id: ::std::vec::Vec::new(),
            auth_factor_label: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.RemoveAuthFactorReply)
pub struct RemoveAuthFactorReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.RemoveAuthFactorReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.RemoveAuthFactorReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.RemoveAuthFactorReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveAuthFactorReply {
    fn default() -> &'a RemoveAuthFactorReply {
        <RemoveAuthFactorReply as ::protobuf::Message>::default_instance()
    }
}

impl RemoveAuthFactorReply {
    pub fn new() -> RemoveAuthFactorReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RemoveAuthFactorReply {
    const NAME: &'static str = "RemoveAuthFactorReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveAuthFactorReply {
        RemoveAuthFactorReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveAuthFactorReply {
        static instance: RemoveAuthFactorReply = RemoveAuthFactorReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.ListAuthFactorsRequest)
pub struct ListAuthFactorsRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.ListAuthFactorsRequest.account_id)
    pub account_id: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.ListAuthFactorsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAuthFactorsRequest {
    fn default() -> &'a ListAuthFactorsRequest {
        <ListAuthFactorsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAuthFactorsRequest {
    pub fn new() -> ListAuthFactorsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListAuthFactorsRequest {
    const NAME: &'static str = "ListAuthFactorsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAuthFactorsRequest {
        ListAuthFactorsRequest::new()
    }

    fn clear(&mut self) {
        self.account_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAuthFactorsRequest {
        static instance: ListAuthFactorsRequest = ListAuthFactorsRequest {
            account_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.ListAuthFactorsReply)
pub struct ListAuthFactorsReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.ListAuthFactorsReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.ListAuthFactorsReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // @@protoc_insertion_point(field:user_data_auth.ListAuthFactorsReply.configured_auth_factors)
    pub configured_auth_factors: ::std::vec::Vec<super::auth_factor::AuthFactor>,
    // @@protoc_insertion_point(field:user_data_auth.ListAuthFactorsReply.configured_auth_factors_with_status)
    pub configured_auth_factors_with_status: ::std::vec::Vec<AuthFactorWithStatus>,
    // @@protoc_insertion_point(field:user_data_auth.ListAuthFactorsReply.supported_auth_factors)
    pub supported_auth_factors: ::std::vec::Vec<::protobuf::EnumOrUnknown<super::auth_factor::AuthFactorType>>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.ListAuthFactorsReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListAuthFactorsReply {
    fn default() -> &'a ListAuthFactorsReply {
        <ListAuthFactorsReply as ::protobuf::Message>::default_instance()
    }
}

impl ListAuthFactorsReply {
    pub fn new() -> ListAuthFactorsReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListAuthFactorsReply {
    const NAME: &'static str = "ListAuthFactorsReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                26 => {
                    self.configured_auth_factors.push(is.read_message()?);
                },
                42 => {
                    self.configured_auth_factors_with_status.push(is.read_message()?);
                },
                32 => {
                    self.supported_auth_factors.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_auth_factors)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.configured_auth_factors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.configured_auth_factors_with_status {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.supported_auth_factors {
            my_size += ::protobuf::rt::int32_size(4, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.configured_auth_factors {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.configured_auth_factors_with_status {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.supported_auth_factors {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListAuthFactorsReply {
        ListAuthFactorsReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.error_info.clear();
        self.configured_auth_factors.clear();
        self.configured_auth_factors_with_status.clear();
        self.supported_auth_factors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListAuthFactorsReply {
        static instance: ListAuthFactorsReply = ListAuthFactorsReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            error_info: ::protobuf::MessageField::none(),
            configured_auth_factors: ::std::vec::Vec::new(),
            configured_auth_factors_with_status: ::std::vec::Vec::new(),
            supported_auth_factors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.RecoveryExtendedInfoRequest)
pub struct RecoveryExtendedInfoRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.RecoveryExtendedInfoRequest.max_depth)
    pub max_depth: u32,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.RecoveryExtendedInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RecoveryExtendedInfoRequest {
    fn default() -> &'a RecoveryExtendedInfoRequest {
        <RecoveryExtendedInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl RecoveryExtendedInfoRequest {
    pub fn new() -> RecoveryExtendedInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RecoveryExtendedInfoRequest {
    const NAME: &'static str = "RecoveryExtendedInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.max_depth = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.max_depth != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.max_depth);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.max_depth != 0 {
            os.write_uint32(1, self.max_depth)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RecoveryExtendedInfoRequest {
        RecoveryExtendedInfoRequest::new()
    }

    fn clear(&mut self) {
        self.max_depth = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RecoveryExtendedInfoRequest {
        static instance: RecoveryExtendedInfoRequest = RecoveryExtendedInfoRequest {
            max_depth: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.RecoveryExtendedInfoReply)
pub struct RecoveryExtendedInfoReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.RecoveryExtendedInfoReply.recovery_ids)
    pub recovery_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.RecoveryExtendedInfoReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RecoveryExtendedInfoReply {
    fn default() -> &'a RecoveryExtendedInfoReply {
        <RecoveryExtendedInfoReply as ::protobuf::Message>::default_instance()
    }
}

impl RecoveryExtendedInfoReply {
    pub fn new() -> RecoveryExtendedInfoReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RecoveryExtendedInfoReply {
    const NAME: &'static str = "RecoveryExtendedInfoReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.recovery_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.recovery_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.recovery_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RecoveryExtendedInfoReply {
        RecoveryExtendedInfoReply::new()
    }

    fn clear(&mut self) {
        self.recovery_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RecoveryExtendedInfoReply {
        static instance: RecoveryExtendedInfoReply = RecoveryExtendedInfoReply {
            recovery_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetAuthFactorExtendedInfoRequest)
pub struct GetAuthFactorExtendedInfoRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetAuthFactorExtendedInfoRequest.account_id)
    pub account_id: ::protobuf::MessageField<super::rpc::AccountIdentifier>,
    // @@protoc_insertion_point(field:user_data_auth.GetAuthFactorExtendedInfoRequest.auth_factor_label)
    pub auth_factor_label: ::std::string::String,
    // message oneof groups
    pub extended_info: ::std::option::Option<get_auth_factor_extended_info_request::Extended_info>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetAuthFactorExtendedInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAuthFactorExtendedInfoRequest {
    fn default() -> &'a GetAuthFactorExtendedInfoRequest {
        <GetAuthFactorExtendedInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAuthFactorExtendedInfoRequest {
    pub fn new() -> GetAuthFactorExtendedInfoRequest {
        ::std::default::Default::default()
    }

    // .user_data_auth.RecoveryExtendedInfoRequest recovery_info_request = 3;

    pub fn recovery_info_request(&self) -> &RecoveryExtendedInfoRequest {
        match self.extended_info {
            ::std::option::Option::Some(get_auth_factor_extended_info_request::Extended_info::RecoveryInfoRequest(ref v)) => v,
            _ => <RecoveryExtendedInfoRequest as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_recovery_info_request(&mut self) {
        self.extended_info = ::std::option::Option::None;
    }

    pub fn has_recovery_info_request(&self) -> bool {
        match self.extended_info {
            ::std::option::Option::Some(get_auth_factor_extended_info_request::Extended_info::RecoveryInfoRequest(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_recovery_info_request(&mut self, v: RecoveryExtendedInfoRequest) {
        self.extended_info = ::std::option::Option::Some(get_auth_factor_extended_info_request::Extended_info::RecoveryInfoRequest(v))
    }

    // Mutable pointer to the field.
    pub fn mut_recovery_info_request(&mut self) -> &mut RecoveryExtendedInfoRequest {
        if let ::std::option::Option::Some(get_auth_factor_extended_info_request::Extended_info::RecoveryInfoRequest(_)) = self.extended_info {
        } else {
            self.extended_info = ::std::option::Option::Some(get_auth_factor_extended_info_request::Extended_info::RecoveryInfoRequest(RecoveryExtendedInfoRequest::new()));
        }
        match self.extended_info {
            ::std::option::Option::Some(get_auth_factor_extended_info_request::Extended_info::RecoveryInfoRequest(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_recovery_info_request(&mut self) -> RecoveryExtendedInfoRequest {
        if self.has_recovery_info_request() {
            match self.extended_info.take() {
                ::std::option::Option::Some(get_auth_factor_extended_info_request::Extended_info::RecoveryInfoRequest(v)) => v,
                _ => panic!(),
            }
        } else {
            RecoveryExtendedInfoRequest::new()
        }
    }
}

impl ::protobuf::Message for GetAuthFactorExtendedInfoRequest {
    const NAME: &'static str = "GetAuthFactorExtendedInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.account_id)?;
                },
                18 => {
                    self.auth_factor_label = is.read_string()?;
                },
                26 => {
                    self.extended_info = ::std::option::Option::Some(get_auth_factor_extended_info_request::Extended_info::RecoveryInfoRequest(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.auth_factor_label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.auth_factor_label);
        }
        if let ::std::option::Option::Some(ref v) = self.extended_info {
            match v {
                &get_auth_factor_extended_info_request::Extended_info::RecoveryInfoRequest(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.auth_factor_label.is_empty() {
            os.write_string(2, &self.auth_factor_label)?;
        }
        if let ::std::option::Option::Some(ref v) = self.extended_info {
            match v {
                &get_auth_factor_extended_info_request::Extended_info::RecoveryInfoRequest(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAuthFactorExtendedInfoRequest {
        GetAuthFactorExtendedInfoRequest::new()
    }

    fn clear(&mut self) {
        self.account_id.clear();
        self.auth_factor_label.clear();
        self.extended_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAuthFactorExtendedInfoRequest {
        static instance: GetAuthFactorExtendedInfoRequest = GetAuthFactorExtendedInfoRequest {
            account_id: ::protobuf::MessageField::none(),
            auth_factor_label: ::std::string::String::new(),
            extended_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `GetAuthFactorExtendedInfoRequest`
pub mod get_auth_factor_extended_info_request {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:user_data_auth.GetAuthFactorExtendedInfoRequest.extended_info)
    pub enum Extended_info {
        // @@protoc_insertion_point(oneof_field:user_data_auth.GetAuthFactorExtendedInfoRequest.recovery_info_request)
        RecoveryInfoRequest(super::RecoveryExtendedInfoRequest),
    }

    impl ::protobuf::Oneof for Extended_info {
    }

    impl Extended_info {
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetAuthFactorExtendedInfoReply)
pub struct GetAuthFactorExtendedInfoReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetAuthFactorExtendedInfoReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.GetAuthFactorExtendedInfoReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // @@protoc_insertion_point(field:user_data_auth.GetAuthFactorExtendedInfoReply.auth_factor)
    pub auth_factor: ::protobuf::MessageField<super::auth_factor::AuthFactor>,
    // message oneof groups
    pub extended_info: ::std::option::Option<get_auth_factor_extended_info_reply::Extended_info>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetAuthFactorExtendedInfoReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAuthFactorExtendedInfoReply {
    fn default() -> &'a GetAuthFactorExtendedInfoReply {
        <GetAuthFactorExtendedInfoReply as ::protobuf::Message>::default_instance()
    }
}

impl GetAuthFactorExtendedInfoReply {
    pub fn new() -> GetAuthFactorExtendedInfoReply {
        ::std::default::Default::default()
    }

    // .user_data_auth.RecoveryExtendedInfoReply recovery_info_reply = 4;

    pub fn recovery_info_reply(&self) -> &RecoveryExtendedInfoReply {
        match self.extended_info {
            ::std::option::Option::Some(get_auth_factor_extended_info_reply::Extended_info::RecoveryInfoReply(ref v)) => v,
            _ => <RecoveryExtendedInfoReply as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_recovery_info_reply(&mut self) {
        self.extended_info = ::std::option::Option::None;
    }

    pub fn has_recovery_info_reply(&self) -> bool {
        match self.extended_info {
            ::std::option::Option::Some(get_auth_factor_extended_info_reply::Extended_info::RecoveryInfoReply(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_recovery_info_reply(&mut self, v: RecoveryExtendedInfoReply) {
        self.extended_info = ::std::option::Option::Some(get_auth_factor_extended_info_reply::Extended_info::RecoveryInfoReply(v))
    }

    // Mutable pointer to the field.
    pub fn mut_recovery_info_reply(&mut self) -> &mut RecoveryExtendedInfoReply {
        if let ::std::option::Option::Some(get_auth_factor_extended_info_reply::Extended_info::RecoveryInfoReply(_)) = self.extended_info {
        } else {
            self.extended_info = ::std::option::Option::Some(get_auth_factor_extended_info_reply::Extended_info::RecoveryInfoReply(RecoveryExtendedInfoReply::new()));
        }
        match self.extended_info {
            ::std::option::Option::Some(get_auth_factor_extended_info_reply::Extended_info::RecoveryInfoReply(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_recovery_info_reply(&mut self) -> RecoveryExtendedInfoReply {
        if self.has_recovery_info_reply() {
            match self.extended_info.take() {
                ::std::option::Option::Some(get_auth_factor_extended_info_reply::Extended_info::RecoveryInfoReply(v)) => v,
                _ => panic!(),
            }
        } else {
            RecoveryExtendedInfoReply::new()
        }
    }
}

impl ::protobuf::Message for GetAuthFactorExtendedInfoReply {
    const NAME: &'static str = "GetAuthFactorExtendedInfoReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.auth_factor)?;
                },
                34 => {
                    self.extended_info = ::std::option::Option::Some(get_auth_factor_extended_info_reply::Extended_info::RecoveryInfoReply(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.auth_factor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.extended_info {
            match v {
                &get_auth_factor_extended_info_reply::Extended_info::RecoveryInfoReply(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.auth_factor.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.extended_info {
            match v {
                &get_auth_factor_extended_info_reply::Extended_info::RecoveryInfoReply(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAuthFactorExtendedInfoReply {
        GetAuthFactorExtendedInfoReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.error_info.clear();
        self.auth_factor.clear();
        self.extended_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAuthFactorExtendedInfoReply {
        static instance: GetAuthFactorExtendedInfoReply = GetAuthFactorExtendedInfoReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            error_info: ::protobuf::MessageField::none(),
            auth_factor: ::protobuf::MessageField::none(),
            extended_info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `GetAuthFactorExtendedInfoReply`
pub mod get_auth_factor_extended_info_reply {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:user_data_auth.GetAuthFactorExtendedInfoReply.extended_info)
    pub enum Extended_info {
        // @@protoc_insertion_point(oneof_field:user_data_auth.GetAuthFactorExtendedInfoReply.recovery_info_reply)
        RecoveryInfoReply(super::RecoveryExtendedInfoReply),
    }

    impl ::protobuf::Oneof for Extended_info {
    }

    impl Extended_info {
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetRecoveryRequestRequest)
pub struct GetRecoveryRequestRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetRecoveryRequestRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:user_data_auth.GetRecoveryRequestRequest.auth_factor_label)
    pub auth_factor_label: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.GetRecoveryRequestRequest.requestor_user_id_type)
    pub requestor_user_id_type: ::protobuf::EnumOrUnknown<get_recovery_request_request::UserType>,
    // @@protoc_insertion_point(field:user_data_auth.GetRecoveryRequestRequest.requestor_user_id)
    pub requestor_user_id: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.GetRecoveryRequestRequest.gaia_access_token)
    pub gaia_access_token: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.GetRecoveryRequestRequest.gaia_reauth_proof_token)
    pub gaia_reauth_proof_token: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.GetRecoveryRequestRequest.epoch_response)
    pub epoch_response: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetRecoveryRequestRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetRecoveryRequestRequest {
    fn default() -> &'a GetRecoveryRequestRequest {
        <GetRecoveryRequestRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetRecoveryRequestRequest {
    pub fn new() -> GetRecoveryRequestRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetRecoveryRequestRequest {
    const NAME: &'static str = "GetRecoveryRequestRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                18 => {
                    self.auth_factor_label = is.read_string()?;
                },
                24 => {
                    self.requestor_user_id_type = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.requestor_user_id = is.read_string()?;
                },
                42 => {
                    self.gaia_access_token = is.read_string()?;
                },
                50 => {
                    self.gaia_reauth_proof_token = is.read_string()?;
                },
                58 => {
                    self.epoch_response = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if !self.auth_factor_label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.auth_factor_label);
        }
        if self.requestor_user_id_type != ::protobuf::EnumOrUnknown::new(get_recovery_request_request::UserType::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.requestor_user_id_type.value());
        }
        if !self.requestor_user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.requestor_user_id);
        }
        if !self.gaia_access_token.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.gaia_access_token);
        }
        if !self.gaia_reauth_proof_token.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.gaia_reauth_proof_token);
        }
        if !self.epoch_response.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.epoch_response);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if !self.auth_factor_label.is_empty() {
            os.write_string(2, &self.auth_factor_label)?;
        }
        if self.requestor_user_id_type != ::protobuf::EnumOrUnknown::new(get_recovery_request_request::UserType::UNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.requestor_user_id_type))?;
        }
        if !self.requestor_user_id.is_empty() {
            os.write_string(4, &self.requestor_user_id)?;
        }
        if !self.gaia_access_token.is_empty() {
            os.write_string(5, &self.gaia_access_token)?;
        }
        if !self.gaia_reauth_proof_token.is_empty() {
            os.write_string(6, &self.gaia_reauth_proof_token)?;
        }
        if !self.epoch_response.is_empty() {
            os.write_bytes(7, &self.epoch_response)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetRecoveryRequestRequest {
        GetRecoveryRequestRequest::new()
    }

    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.auth_factor_label.clear();
        self.requestor_user_id_type = ::protobuf::EnumOrUnknown::new(get_recovery_request_request::UserType::UNKNOWN);
        self.requestor_user_id.clear();
        self.gaia_access_token.clear();
        self.gaia_reauth_proof_token.clear();
        self.epoch_response.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetRecoveryRequestRequest {
        static instance: GetRecoveryRequestRequest = GetRecoveryRequestRequest {
            auth_session_id: ::std::vec::Vec::new(),
            auth_factor_label: ::std::string::String::new(),
            requestor_user_id_type: ::protobuf::EnumOrUnknown::from_i32(0),
            requestor_user_id: ::std::string::String::new(),
            gaia_access_token: ::std::string::String::new(),
            gaia_reauth_proof_token: ::std::string::String::new(),
            epoch_response: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `GetRecoveryRequestRequest`
pub mod get_recovery_request_request {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:user_data_auth.GetRecoveryRequestRequest.UserType)
    pub enum UserType {
        // @@protoc_insertion_point(enum_value:user_data_auth.GetRecoveryRequestRequest.UserType.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:user_data_auth.GetRecoveryRequestRequest.UserType.GAIA_ID)
        GAIA_ID = 1,
    }

    impl ::protobuf::Enum for UserType {
        const NAME: &'static str = "UserType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<UserType> {
            match value {
                0 => ::std::option::Option::Some(UserType::UNKNOWN),
                1 => ::std::option::Option::Some(UserType::GAIA_ID),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [UserType] = &[
            UserType::UNKNOWN,
            UserType::GAIA_ID,
        ];
    }

    impl ::std::default::Default for UserType {
        fn default() -> Self {
            UserType::UNKNOWN
        }
    }

}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.GetRecoveryRequestReply)
pub struct GetRecoveryRequestReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.GetRecoveryRequestReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.GetRecoveryRequestReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // @@protoc_insertion_point(field:user_data_auth.GetRecoveryRequestReply.recovery_request)
    pub recovery_request: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.GetRecoveryRequestReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetRecoveryRequestReply {
    fn default() -> &'a GetRecoveryRequestReply {
        <GetRecoveryRequestReply as ::protobuf::Message>::default_instance()
    }
}

impl GetRecoveryRequestReply {
    pub fn new() -> GetRecoveryRequestReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetRecoveryRequestReply {
    const NAME: &'static str = "GetRecoveryRequestReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                26 => {
                    self.recovery_request = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.recovery_request.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.recovery_request);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.recovery_request.is_empty() {
            os.write_bytes(3, &self.recovery_request)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetRecoveryRequestReply {
        GetRecoveryRequestReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.error_info.clear();
        self.recovery_request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetRecoveryRequestReply {
        static instance: GetRecoveryRequestReply = GetRecoveryRequestReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            error_info: ::protobuf::MessageField::none(),
            recovery_request: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PrepareAuthFactorRequest)
pub struct PrepareAuthFactorRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.PrepareAuthFactorRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:user_data_auth.PrepareAuthFactorRequest.auth_factor_type)
    pub auth_factor_type: ::protobuf::EnumOrUnknown<super::auth_factor::AuthFactorType>,
    // @@protoc_insertion_point(field:user_data_auth.PrepareAuthFactorRequest.purpose)
    pub purpose: ::protobuf::EnumOrUnknown<super::auth_factor::AuthFactorPreparePurpose>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PrepareAuthFactorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrepareAuthFactorRequest {
    fn default() -> &'a PrepareAuthFactorRequest {
        <PrepareAuthFactorRequest as ::protobuf::Message>::default_instance()
    }
}

impl PrepareAuthFactorRequest {
    pub fn new() -> PrepareAuthFactorRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PrepareAuthFactorRequest {
    const NAME: &'static str = "PrepareAuthFactorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                16 => {
                    self.auth_factor_type = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.purpose = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if self.auth_factor_type != ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(2, self.auth_factor_type.value());
        }
        if self.purpose != ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorPreparePurpose::PURPOSE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(3, self.purpose.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if self.auth_factor_type != ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.auth_factor_type))?;
        }
        if self.purpose != ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorPreparePurpose::PURPOSE_UNSPECIFIED) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.purpose))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrepareAuthFactorRequest {
        PrepareAuthFactorRequest::new()
    }

    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.auth_factor_type = ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED);
        self.purpose = ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorPreparePurpose::PURPOSE_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrepareAuthFactorRequest {
        static instance: PrepareAuthFactorRequest = PrepareAuthFactorRequest {
            auth_session_id: ::std::vec::Vec::new(),
            auth_factor_type: ::protobuf::EnumOrUnknown::from_i32(0),
            purpose: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PrepareAuthFactorReply)
pub struct PrepareAuthFactorReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.PrepareAuthFactorReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.PrepareAuthFactorReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PrepareAuthFactorReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrepareAuthFactorReply {
    fn default() -> &'a PrepareAuthFactorReply {
        <PrepareAuthFactorReply as ::protobuf::Message>::default_instance()
    }
}

impl PrepareAuthFactorReply {
    pub fn new() -> PrepareAuthFactorReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PrepareAuthFactorReply {
    const NAME: &'static str = "PrepareAuthFactorReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrepareAuthFactorReply {
        PrepareAuthFactorReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrepareAuthFactorReply {
        static instance: PrepareAuthFactorReply = PrepareAuthFactorReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.TerminateAuthFactorRequest)
pub struct TerminateAuthFactorRequest {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.TerminateAuthFactorRequest.auth_session_id)
    pub auth_session_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:user_data_auth.TerminateAuthFactorRequest.auth_factor_type)
    pub auth_factor_type: ::protobuf::EnumOrUnknown<super::auth_factor::AuthFactorType>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.TerminateAuthFactorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TerminateAuthFactorRequest {
    fn default() -> &'a TerminateAuthFactorRequest {
        <TerminateAuthFactorRequest as ::protobuf::Message>::default_instance()
    }
}

impl TerminateAuthFactorRequest {
    pub fn new() -> TerminateAuthFactorRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TerminateAuthFactorRequest {
    const NAME: &'static str = "TerminateAuthFactorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.auth_session_id = is.read_bytes()?;
                },
                16 => {
                    self.auth_factor_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.auth_session_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.auth_session_id);
        }
        if self.auth_factor_type != ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(2, self.auth_factor_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.auth_session_id.is_empty() {
            os.write_bytes(1, &self.auth_session_id)?;
        }
        if self.auth_factor_type != ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.auth_factor_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TerminateAuthFactorRequest {
        TerminateAuthFactorRequest::new()
    }

    fn clear(&mut self) {
        self.auth_session_id.clear();
        self.auth_factor_type = ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TerminateAuthFactorRequest {
        static instance: TerminateAuthFactorRequest = TerminateAuthFactorRequest {
            auth_session_id: ::std::vec::Vec::new(),
            auth_factor_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.TerminateAuthFactorReply)
pub struct TerminateAuthFactorReply {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.TerminateAuthFactorReply.error)
    pub error: ::protobuf::EnumOrUnknown<CryptohomeErrorCode>,
    // @@protoc_insertion_point(field:user_data_auth.TerminateAuthFactorReply.error_info)
    pub error_info: ::protobuf::MessageField<CryptohomeErrorInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.TerminateAuthFactorReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TerminateAuthFactorReply {
    fn default() -> &'a TerminateAuthFactorReply {
        <TerminateAuthFactorReply as ::protobuf::Message>::default_instance()
    }
}

impl TerminateAuthFactorReply {
    pub fn new() -> TerminateAuthFactorReply {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TerminateAuthFactorReply {
    const NAME: &'static str = "TerminateAuthFactorReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.error = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.error.value());
        }
        if let Some(v) = self.error_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.error != ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.error))?;
        }
        if let Some(v) = self.error_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TerminateAuthFactorReply {
        TerminateAuthFactorReply::new()
    }

    fn clear(&mut self) {
        self.error = ::protobuf::EnumOrUnknown::new(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET);
        self.error_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TerminateAuthFactorReply {
        static instance: TerminateAuthFactorReply = TerminateAuthFactorReply {
            error: ::protobuf::EnumOrUnknown::from_i32(0),
            error_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.AuthScanResult)
pub struct AuthScanResult {
    // message oneof groups
    pub scan_result: ::std::option::Option<auth_scan_result::Scan_result>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.AuthScanResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthScanResult {
    fn default() -> &'a AuthScanResult {
        <AuthScanResult as ::protobuf::Message>::default_instance()
    }
}

impl AuthScanResult {
    pub fn new() -> AuthScanResult {
        ::std::default::Default::default()
    }

    // .user_data_auth.FingerprintScanResult fingerprint_result = 1;

    pub fn fingerprint_result(&self) -> FingerprintScanResult {
        match self.scan_result {
            ::std::option::Option::Some(auth_scan_result::Scan_result::FingerprintResult(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => FingerprintScanResult::FINGERPRINT_SCAN_RESULT_SUCCESS,
        }
    }

    pub fn clear_fingerprint_result(&mut self) {
        self.scan_result = ::std::option::Option::None;
    }

    pub fn has_fingerprint_result(&self) -> bool {
        match self.scan_result {
            ::std::option::Option::Some(auth_scan_result::Scan_result::FingerprintResult(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fingerprint_result(&mut self, v: FingerprintScanResult) {
        self.scan_result = ::std::option::Option::Some(auth_scan_result::Scan_result::FingerprintResult(::protobuf::EnumOrUnknown::new(v)))
    }
}

impl ::protobuf::Message for AuthScanResult {
    const NAME: &'static str = "AuthScanResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.scan_result = ::std::option::Option::Some(auth_scan_result::Scan_result::FingerprintResult(is.read_enum_or_unknown()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.scan_result {
            match v {
                &auth_scan_result::Scan_result::FingerprintResult(v) => {
                    my_size += ::protobuf::rt::int32_size(1, v.value());
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.scan_result {
            match v {
                &auth_scan_result::Scan_result::FingerprintResult(v) => {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthScanResult {
        AuthScanResult::new()
    }

    fn clear(&mut self) {
        self.scan_result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthScanResult {
        static instance: AuthScanResult = AuthScanResult {
            scan_result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `AuthScanResult`
pub mod auth_scan_result {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:user_data_auth.AuthScanResult.scan_result)
    pub enum Scan_result {
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthScanResult.fingerprint_result)
        FingerprintResult(::protobuf::EnumOrUnknown<super::FingerprintScanResult>),
    }

    impl ::protobuf::Oneof for Scan_result {
    }

    impl Scan_result {
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.FingerprintEnrollmentProgress)
pub struct FingerprintEnrollmentProgress {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.FingerprintEnrollmentProgress.percent_complete)
    pub percent_complete: i32,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.FingerprintEnrollmentProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FingerprintEnrollmentProgress {
    fn default() -> &'a FingerprintEnrollmentProgress {
        <FingerprintEnrollmentProgress as ::protobuf::Message>::default_instance()
    }
}

impl FingerprintEnrollmentProgress {
    pub fn new() -> FingerprintEnrollmentProgress {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FingerprintEnrollmentProgress {
    const NAME: &'static str = "FingerprintEnrollmentProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.percent_complete = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.percent_complete != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.percent_complete);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.percent_complete != 0 {
            os.write_int32(1, self.percent_complete)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FingerprintEnrollmentProgress {
        FingerprintEnrollmentProgress::new()
    }

    fn clear(&mut self) {
        self.percent_complete = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FingerprintEnrollmentProgress {
        static instance: FingerprintEnrollmentProgress = FingerprintEnrollmentProgress {
            percent_complete: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.AuthEnrollmentProgress)
pub struct AuthEnrollmentProgress {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.AuthEnrollmentProgress.scan_result)
    pub scan_result: ::protobuf::MessageField<AuthScanResult>,
    // @@protoc_insertion_point(field:user_data_auth.AuthEnrollmentProgress.done)
    pub done: bool,
    // message oneof groups
    pub progress: ::std::option::Option<auth_enrollment_progress::Progress>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.AuthEnrollmentProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthEnrollmentProgress {
    fn default() -> &'a AuthEnrollmentProgress {
        <AuthEnrollmentProgress as ::protobuf::Message>::default_instance()
    }
}

impl AuthEnrollmentProgress {
    pub fn new() -> AuthEnrollmentProgress {
        ::std::default::Default::default()
    }

    // .user_data_auth.FingerprintEnrollmentProgress fingerprint_progress = 3;

    pub fn fingerprint_progress(&self) -> &FingerprintEnrollmentProgress {
        match self.progress {
            ::std::option::Option::Some(auth_enrollment_progress::Progress::FingerprintProgress(ref v)) => v,
            _ => <FingerprintEnrollmentProgress as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_fingerprint_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_fingerprint_progress(&self) -> bool {
        match self.progress {
            ::std::option::Option::Some(auth_enrollment_progress::Progress::FingerprintProgress(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fingerprint_progress(&mut self, v: FingerprintEnrollmentProgress) {
        self.progress = ::std::option::Option::Some(auth_enrollment_progress::Progress::FingerprintProgress(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fingerprint_progress(&mut self) -> &mut FingerprintEnrollmentProgress {
        if let ::std::option::Option::Some(auth_enrollment_progress::Progress::FingerprintProgress(_)) = self.progress {
        } else {
            self.progress = ::std::option::Option::Some(auth_enrollment_progress::Progress::FingerprintProgress(FingerprintEnrollmentProgress::new()));
        }
        match self.progress {
            ::std::option::Option::Some(auth_enrollment_progress::Progress::FingerprintProgress(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fingerprint_progress(&mut self) -> FingerprintEnrollmentProgress {
        if self.has_fingerprint_progress() {
            match self.progress.take() {
                ::std::option::Option::Some(auth_enrollment_progress::Progress::FingerprintProgress(v)) => v,
                _ => panic!(),
            }
        } else {
            FingerprintEnrollmentProgress::new()
        }
    }
}

impl ::protobuf::Message for AuthEnrollmentProgress {
    const NAME: &'static str = "AuthEnrollmentProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scan_result)?;
                },
                16 => {
                    self.done = is.read_bool()?;
                },
                26 => {
                    self.progress = ::std::option::Option::Some(auth_enrollment_progress::Progress::FingerprintProgress(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.scan_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.done != false {
            my_size += 1 + 1;
        }
        if let ::std::option::Option::Some(ref v) = self.progress {
            match v {
                &auth_enrollment_progress::Progress::FingerprintProgress(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.scan_result.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.done != false {
            os.write_bool(2, self.done)?;
        }
        if let ::std::option::Option::Some(ref v) = self.progress {
            match v {
                &auth_enrollment_progress::Progress::FingerprintProgress(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthEnrollmentProgress {
        AuthEnrollmentProgress::new()
    }

    fn clear(&mut self) {
        self.scan_result.clear();
        self.done = false;
        self.progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthEnrollmentProgress {
        static instance: AuthEnrollmentProgress = AuthEnrollmentProgress {
            scan_result: ::protobuf::MessageField::none(),
            done: false,
            progress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `AuthEnrollmentProgress`
pub mod auth_enrollment_progress {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:user_data_auth.AuthEnrollmentProgress.progress)
    pub enum Progress {
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthEnrollmentProgress.fingerprint_progress)
        FingerprintProgress(super::FingerprintEnrollmentProgress),
    }

    impl ::protobuf::Oneof for Progress {
    }

    impl Progress {
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.AuthScanDone)
pub struct AuthScanDone {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.AuthScanDone.scan_result)
    pub scan_result: ::protobuf::MessageField<AuthScanResult>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.AuthScanDone.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthScanDone {
    fn default() -> &'a AuthScanDone {
        <AuthScanDone as ::protobuf::Message>::default_instance()
    }
}

impl AuthScanDone {
    pub fn new() -> AuthScanDone {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthScanDone {
    const NAME: &'static str = "AuthScanDone";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.scan_result)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.scan_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.scan_result.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthScanDone {
        AuthScanDone::new()
    }

    fn clear(&mut self) {
        self.scan_result.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthScanDone {
        static instance: AuthScanDone = AuthScanDone {
            scan_result: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PrepareAuthFactorForAddProgress)
pub struct PrepareAuthFactorForAddProgress {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.PrepareAuthFactorForAddProgress.auth_factor_type)
    pub auth_factor_type: ::protobuf::EnumOrUnknown<super::auth_factor::AuthFactorType>,
    // message oneof groups
    pub progress: ::std::option::Option<prepare_auth_factor_for_add_progress::Progress>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PrepareAuthFactorForAddProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrepareAuthFactorForAddProgress {
    fn default() -> &'a PrepareAuthFactorForAddProgress {
        <PrepareAuthFactorForAddProgress as ::protobuf::Message>::default_instance()
    }
}

impl PrepareAuthFactorForAddProgress {
    pub fn new() -> PrepareAuthFactorForAddProgress {
        ::std::default::Default::default()
    }

    // .user_data_auth.AuthEnrollmentProgress biometrics_progress = 2;

    pub fn biometrics_progress(&self) -> &AuthEnrollmentProgress {
        match self.progress {
            ::std::option::Option::Some(prepare_auth_factor_for_add_progress::Progress::BiometricsProgress(ref v)) => v,
            _ => <AuthEnrollmentProgress as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_biometrics_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_biometrics_progress(&self) -> bool {
        match self.progress {
            ::std::option::Option::Some(prepare_auth_factor_for_add_progress::Progress::BiometricsProgress(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_biometrics_progress(&mut self, v: AuthEnrollmentProgress) {
        self.progress = ::std::option::Option::Some(prepare_auth_factor_for_add_progress::Progress::BiometricsProgress(v))
    }

    // Mutable pointer to the field.
    pub fn mut_biometrics_progress(&mut self) -> &mut AuthEnrollmentProgress {
        if let ::std::option::Option::Some(prepare_auth_factor_for_add_progress::Progress::BiometricsProgress(_)) = self.progress {
        } else {
            self.progress = ::std::option::Option::Some(prepare_auth_factor_for_add_progress::Progress::BiometricsProgress(AuthEnrollmentProgress::new()));
        }
        match self.progress {
            ::std::option::Option::Some(prepare_auth_factor_for_add_progress::Progress::BiometricsProgress(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_biometrics_progress(&mut self) -> AuthEnrollmentProgress {
        if self.has_biometrics_progress() {
            match self.progress.take() {
                ::std::option::Option::Some(prepare_auth_factor_for_add_progress::Progress::BiometricsProgress(v)) => v,
                _ => panic!(),
            }
        } else {
            AuthEnrollmentProgress::new()
        }
    }
}

impl ::protobuf::Message for PrepareAuthFactorForAddProgress {
    const NAME: &'static str = "PrepareAuthFactorForAddProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.auth_factor_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.progress = ::std::option::Option::Some(prepare_auth_factor_for_add_progress::Progress::BiometricsProgress(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.auth_factor_type != ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.auth_factor_type.value());
        }
        if let ::std::option::Option::Some(ref v) = self.progress {
            match v {
                &prepare_auth_factor_for_add_progress::Progress::BiometricsProgress(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.auth_factor_type != ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.auth_factor_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.progress {
            match v {
                &prepare_auth_factor_for_add_progress::Progress::BiometricsProgress(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrepareAuthFactorForAddProgress {
        PrepareAuthFactorForAddProgress::new()
    }

    fn clear(&mut self) {
        self.auth_factor_type = ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED);
        self.progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrepareAuthFactorForAddProgress {
        static instance: PrepareAuthFactorForAddProgress = PrepareAuthFactorForAddProgress {
            auth_factor_type: ::protobuf::EnumOrUnknown::from_i32(0),
            progress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `PrepareAuthFactorForAddProgress`
pub mod prepare_auth_factor_for_add_progress {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:user_data_auth.PrepareAuthFactorForAddProgress.progress)
    pub enum Progress {
        // @@protoc_insertion_point(oneof_field:user_data_auth.PrepareAuthFactorForAddProgress.biometrics_progress)
        BiometricsProgress(super::AuthEnrollmentProgress),
    }

    impl ::protobuf::Oneof for Progress {
    }

    impl Progress {
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PrepareAuthFactorForAuthProgress)
pub struct PrepareAuthFactorForAuthProgress {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.PrepareAuthFactorForAuthProgress.auth_factor_type)
    pub auth_factor_type: ::protobuf::EnumOrUnknown<super::auth_factor::AuthFactorType>,
    // message oneof groups
    pub progress: ::std::option::Option<prepare_auth_factor_for_auth_progress::Progress>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PrepareAuthFactorForAuthProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrepareAuthFactorForAuthProgress {
    fn default() -> &'a PrepareAuthFactorForAuthProgress {
        <PrepareAuthFactorForAuthProgress as ::protobuf::Message>::default_instance()
    }
}

impl PrepareAuthFactorForAuthProgress {
    pub fn new() -> PrepareAuthFactorForAuthProgress {
        ::std::default::Default::default()
    }

    // .user_data_auth.AuthScanDone biometrics_progress = 2;

    pub fn biometrics_progress(&self) -> &AuthScanDone {
        match self.progress {
            ::std::option::Option::Some(prepare_auth_factor_for_auth_progress::Progress::BiometricsProgress(ref v)) => v,
            _ => <AuthScanDone as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_biometrics_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_biometrics_progress(&self) -> bool {
        match self.progress {
            ::std::option::Option::Some(prepare_auth_factor_for_auth_progress::Progress::BiometricsProgress(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_biometrics_progress(&mut self, v: AuthScanDone) {
        self.progress = ::std::option::Option::Some(prepare_auth_factor_for_auth_progress::Progress::BiometricsProgress(v))
    }

    // Mutable pointer to the field.
    pub fn mut_biometrics_progress(&mut self) -> &mut AuthScanDone {
        if let ::std::option::Option::Some(prepare_auth_factor_for_auth_progress::Progress::BiometricsProgress(_)) = self.progress {
        } else {
            self.progress = ::std::option::Option::Some(prepare_auth_factor_for_auth_progress::Progress::BiometricsProgress(AuthScanDone::new()));
        }
        match self.progress {
            ::std::option::Option::Some(prepare_auth_factor_for_auth_progress::Progress::BiometricsProgress(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_biometrics_progress(&mut self) -> AuthScanDone {
        if self.has_biometrics_progress() {
            match self.progress.take() {
                ::std::option::Option::Some(prepare_auth_factor_for_auth_progress::Progress::BiometricsProgress(v)) => v,
                _ => panic!(),
            }
        } else {
            AuthScanDone::new()
        }
    }
}

impl ::protobuf::Message for PrepareAuthFactorForAuthProgress {
    const NAME: &'static str = "PrepareAuthFactorForAuthProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.auth_factor_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.progress = ::std::option::Option::Some(prepare_auth_factor_for_auth_progress::Progress::BiometricsProgress(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.auth_factor_type != ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.auth_factor_type.value());
        }
        if let ::std::option::Option::Some(ref v) = self.progress {
            match v {
                &prepare_auth_factor_for_auth_progress::Progress::BiometricsProgress(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.auth_factor_type != ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.auth_factor_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.progress {
            match v {
                &prepare_auth_factor_for_auth_progress::Progress::BiometricsProgress(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrepareAuthFactorForAuthProgress {
        PrepareAuthFactorForAuthProgress::new()
    }

    fn clear(&mut self) {
        self.auth_factor_type = ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED);
        self.progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrepareAuthFactorForAuthProgress {
        static instance: PrepareAuthFactorForAuthProgress = PrepareAuthFactorForAuthProgress {
            auth_factor_type: ::protobuf::EnumOrUnknown::from_i32(0),
            progress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `PrepareAuthFactorForAuthProgress`
pub mod prepare_auth_factor_for_auth_progress {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:user_data_auth.PrepareAuthFactorForAuthProgress.progress)
    pub enum Progress {
        // @@protoc_insertion_point(oneof_field:user_data_auth.PrepareAuthFactorForAuthProgress.biometrics_progress)
        BiometricsProgress(super::AuthScanDone),
    }

    impl ::protobuf::Oneof for Progress {
    }

    impl Progress {
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PrepareAuthFactorProgress)
pub struct PrepareAuthFactorProgress {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.PrepareAuthFactorProgress.purpose)
    pub purpose: ::protobuf::EnumOrUnknown<super::auth_factor::AuthFactorPreparePurpose>,
    // message oneof groups
    pub progress: ::std::option::Option<prepare_auth_factor_progress::Progress>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PrepareAuthFactorProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PrepareAuthFactorProgress {
    fn default() -> &'a PrepareAuthFactorProgress {
        <PrepareAuthFactorProgress as ::protobuf::Message>::default_instance()
    }
}

impl PrepareAuthFactorProgress {
    pub fn new() -> PrepareAuthFactorProgress {
        ::std::default::Default::default()
    }

    // .user_data_auth.PrepareAuthFactorForAddProgress add_progress = 2;

    pub fn add_progress(&self) -> &PrepareAuthFactorForAddProgress {
        match self.progress {
            ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AddProgress(ref v)) => v,
            _ => <PrepareAuthFactorForAddProgress as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_add_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_add_progress(&self) -> bool {
        match self.progress {
            ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AddProgress(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_add_progress(&mut self, v: PrepareAuthFactorForAddProgress) {
        self.progress = ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AddProgress(v))
    }

    // Mutable pointer to the field.
    pub fn mut_add_progress(&mut self) -> &mut PrepareAuthFactorForAddProgress {
        if let ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AddProgress(_)) = self.progress {
        } else {
            self.progress = ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AddProgress(PrepareAuthFactorForAddProgress::new()));
        }
        match self.progress {
            ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AddProgress(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_add_progress(&mut self) -> PrepareAuthFactorForAddProgress {
        if self.has_add_progress() {
            match self.progress.take() {
                ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AddProgress(v)) => v,
                _ => panic!(),
            }
        } else {
            PrepareAuthFactorForAddProgress::new()
        }
    }

    // .user_data_auth.PrepareAuthFactorForAuthProgress auth_progress = 3;

    pub fn auth_progress(&self) -> &PrepareAuthFactorForAuthProgress {
        match self.progress {
            ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AuthProgress(ref v)) => v,
            _ => <PrepareAuthFactorForAuthProgress as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_auth_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_auth_progress(&self) -> bool {
        match self.progress {
            ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AuthProgress(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_auth_progress(&mut self, v: PrepareAuthFactorForAuthProgress) {
        self.progress = ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AuthProgress(v))
    }

    // Mutable pointer to the field.
    pub fn mut_auth_progress(&mut self) -> &mut PrepareAuthFactorForAuthProgress {
        if let ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AuthProgress(_)) = self.progress {
        } else {
            self.progress = ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AuthProgress(PrepareAuthFactorForAuthProgress::new()));
        }
        match self.progress {
            ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AuthProgress(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_auth_progress(&mut self) -> PrepareAuthFactorForAuthProgress {
        if self.has_auth_progress() {
            match self.progress.take() {
                ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AuthProgress(v)) => v,
                _ => panic!(),
            }
        } else {
            PrepareAuthFactorForAuthProgress::new()
        }
    }
}

impl ::protobuf::Message for PrepareAuthFactorProgress {
    const NAME: &'static str = "PrepareAuthFactorProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.purpose = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.progress = ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AddProgress(is.read_message()?));
                },
                26 => {
                    self.progress = ::std::option::Option::Some(prepare_auth_factor_progress::Progress::AuthProgress(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.purpose != ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorPreparePurpose::PURPOSE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.purpose.value());
        }
        if let ::std::option::Option::Some(ref v) = self.progress {
            match v {
                &prepare_auth_factor_progress::Progress::AddProgress(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &prepare_auth_factor_progress::Progress::AuthProgress(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.purpose != ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorPreparePurpose::PURPOSE_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.purpose))?;
        }
        if let ::std::option::Option::Some(ref v) = self.progress {
            match v {
                &prepare_auth_factor_progress::Progress::AddProgress(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &prepare_auth_factor_progress::Progress::AuthProgress(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PrepareAuthFactorProgress {
        PrepareAuthFactorProgress::new()
    }

    fn clear(&mut self) {
        self.purpose = ::protobuf::EnumOrUnknown::new(super::auth_factor::AuthFactorPreparePurpose::PURPOSE_UNSPECIFIED);
        self.progress = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PrepareAuthFactorProgress {
        static instance: PrepareAuthFactorProgress = PrepareAuthFactorProgress {
            purpose: ::protobuf::EnumOrUnknown::from_i32(0),
            progress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `PrepareAuthFactorProgress`
pub mod prepare_auth_factor_progress {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:user_data_auth.PrepareAuthFactorProgress.progress)
    pub enum Progress {
        // @@protoc_insertion_point(oneof_field:user_data_auth.PrepareAuthFactorProgress.add_progress)
        AddProgress(super::PrepareAuthFactorForAddProgress),
        // @@protoc_insertion_point(oneof_field:user_data_auth.PrepareAuthFactorProgress.auth_progress)
        AuthProgress(super::PrepareAuthFactorForAuthProgress),
    }

    impl ::protobuf::Oneof for Progress {
    }

    impl Progress {
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:user_data_auth.CryptohomeErrorCode)
pub enum CryptohomeErrorCode {
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_NOT_SET)
    CRYPTOHOME_ERROR_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_ACCOUNT_NOT_FOUND)
    CRYPTOHOME_ERROR_ACCOUNT_NOT_FOUND = 1,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_AUTHORIZATION_KEY_NOT_FOUND)
    CRYPTOHOME_ERROR_AUTHORIZATION_KEY_NOT_FOUND = 2,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_AUTHORIZATION_KEY_FAILED)
    CRYPTOHOME_ERROR_AUTHORIZATION_KEY_FAILED = 3,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_NOT_IMPLEMENTED)
    CRYPTOHOME_ERROR_NOT_IMPLEMENTED = 4,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_MOUNT_FATAL)
    CRYPTOHOME_ERROR_MOUNT_FATAL = 5,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_MOUNT_MOUNT_POINT_BUSY)
    CRYPTOHOME_ERROR_MOUNT_MOUNT_POINT_BUSY = 6,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_TPM_COMM_ERROR)
    CRYPTOHOME_ERROR_TPM_COMM_ERROR = 7,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_TPM_DEFEND_LOCK)
    CRYPTOHOME_ERROR_TPM_DEFEND_LOCK = 8,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_TPM_NEEDS_REBOOT)
    CRYPTOHOME_ERROR_TPM_NEEDS_REBOOT = 9,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_AUTHORIZATION_KEY_DENIED)
    CRYPTOHOME_ERROR_AUTHORIZATION_KEY_DENIED = 10,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_KEY_QUOTA_EXCEEDED)
    CRYPTOHOME_ERROR_KEY_QUOTA_EXCEEDED = 11,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_KEY_LABEL_EXISTS)
    CRYPTOHOME_ERROR_KEY_LABEL_EXISTS = 12,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_BACKING_STORE_FAILURE)
    CRYPTOHOME_ERROR_BACKING_STORE_FAILURE = 13,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_UPDATE_SIGNATURE_INVALID)
    CRYPTOHOME_ERROR_UPDATE_SIGNATURE_INVALID = 14,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_KEY_NOT_FOUND)
    CRYPTOHOME_ERROR_KEY_NOT_FOUND = 15,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_LOCKBOX_SIGNATURE_INVALID)
    CRYPTOHOME_ERROR_LOCKBOX_SIGNATURE_INVALID = 16,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_LOCKBOX_CANNOT_SIGN)
    CRYPTOHOME_ERROR_LOCKBOX_CANNOT_SIGN = 17,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_BOOT_ATTRIBUTE_NOT_FOUND)
    CRYPTOHOME_ERROR_BOOT_ATTRIBUTE_NOT_FOUND = 18,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_BOOT_ATTRIBUTES_CANNOT_SIGN)
    CRYPTOHOME_ERROR_BOOT_ATTRIBUTES_CANNOT_SIGN = 19,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_TPM_EK_NOT_AVAILABLE)
    CRYPTOHOME_ERROR_TPM_EK_NOT_AVAILABLE = 20,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_ATTESTATION_NOT_READY)
    CRYPTOHOME_ERROR_ATTESTATION_NOT_READY = 21,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_CANNOT_CONNECT_TO_CA)
    CRYPTOHOME_ERROR_CANNOT_CONNECT_TO_CA = 22,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_CA_REFUSED_ENROLLMENT)
    CRYPTOHOME_ERROR_CA_REFUSED_ENROLLMENT = 23,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_CA_REFUSED_CERTIFICATE)
    CRYPTOHOME_ERROR_CA_REFUSED_CERTIFICATE = 24,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_INTERNAL_ATTESTATION_ERROR)
    CRYPTOHOME_ERROR_INTERNAL_ATTESTATION_ERROR = 25,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_INVALID)
    CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_INVALID = 26,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_STORE)
    CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_STORE = 27,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_REMOVE)
    CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_REMOVE = 28,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_MOUNT_OLD_ENCRYPTION)
    CRYPTOHOME_ERROR_MOUNT_OLD_ENCRYPTION = 29,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_MOUNT_PREVIOUS_MIGRATION_INCOMPLETE)
    CRYPTOHOME_ERROR_MOUNT_PREVIOUS_MIGRATION_INCOMPLETE = 30,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_MIGRATE_KEY_FAILED)
    CRYPTOHOME_ERROR_MIGRATE_KEY_FAILED = 31,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_REMOVE_FAILED)
    CRYPTOHOME_ERROR_REMOVE_FAILED = 32,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_INVALID_ARGUMENT)
    CRYPTOHOME_ERROR_INVALID_ARGUMENT = 33,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_GET_FAILED)
    CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_GET_FAILED = 34,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_SET_FAILED)
    CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_SET_FAILED = 35,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_FINALIZE_FAILED)
    CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_FINALIZE_FAILED = 36,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_UPDATE_USER_ACTIVITY_TIMESTAMP_FAILED)
    CRYPTOHOME_ERROR_UPDATE_USER_ACTIVITY_TIMESTAMP_FAILED = 37,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_FAILED_TO_READ_PCR)
    CRYPTOHOME_ERROR_FAILED_TO_READ_PCR = 38,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_PCR_ALREADY_EXTENDED)
    CRYPTOHOME_ERROR_PCR_ALREADY_EXTENDED = 39,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_FAILED_TO_EXTEND_PCR)
    CRYPTOHOME_ERROR_FAILED_TO_EXTEND_PCR = 40,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_TPM_UPDATE_REQUIRED)
    CRYPTOHOME_ERROR_TPM_UPDATE_REQUIRED = 41,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_FINGERPRINT_ERROR_INTERNAL)
    CRYPTOHOME_ERROR_FINGERPRINT_ERROR_INTERNAL = 42,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_FINGERPRINT_RETRY_REQUIRED)
    CRYPTOHOME_ERROR_FINGERPRINT_RETRY_REQUIRED = 43,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_FINGERPRINT_DENIED)
    CRYPTOHOME_ERROR_FINGERPRINT_DENIED = 44,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_VAULT_UNRECOVERABLE)
    CRYPTOHOME_ERROR_VAULT_UNRECOVERABLE = 45,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_FIDO_MAKE_CREDENTIAL_FAILED)
    CRYPTOHOME_ERROR_FIDO_MAKE_CREDENTIAL_FAILED = 46,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_FIDO_GET_ASSERTION_FAILED)
    CRYPTOHOME_ERROR_FIDO_GET_ASSERTION_FAILED = 47,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_TOKEN_SERIALIZATION_FAILED)
    CRYPTOHOME_TOKEN_SERIALIZATION_FAILED = 48,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_INVALID_AUTH_SESSION_TOKEN)
    CRYPTOHOME_INVALID_AUTH_SESSION_TOKEN = 49,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ADD_CREDENTIALS_FAILED)
    CRYPTOHOME_ADD_CREDENTIALS_FAILED = 50,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_UNAUTHENTICATED_AUTH_SESSION)
    CRYPTOHOME_ERROR_UNAUTHENTICATED_AUTH_SESSION = 51,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_UNKNOWN_LEGACY)
    CRYPTOHOME_ERROR_UNKNOWN_LEGACY = 52,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_UNUSABLE_VAULT)
    CRYPTOHOME_ERROR_UNUSABLE_VAULT = 53,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_REMOVE_CREDENTIALS_FAILED)
    CRYPTOHOME_REMOVE_CREDENTIALS_FAILED = 54,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_UPDATE_CREDENTIALS_FAILED)
    CRYPTOHOME_UPDATE_CREDENTIALS_FAILED = 55,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_RECOVERY_TRANSIENT)
    CRYPTOHOME_ERROR_RECOVERY_TRANSIENT = 56,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_RECOVERY_FATAL)
    CRYPTOHOME_ERROR_RECOVERY_FATAL = 57,
    // @@protoc_insertion_point(enum_value:user_data_auth.CryptohomeErrorCode.CRYPTOHOME_ERROR_BIOMETRICS_BUSY)
    CRYPTOHOME_ERROR_BIOMETRICS_BUSY = 58,
}

impl ::protobuf::Enum for CryptohomeErrorCode {
    const NAME: &'static str = "CryptohomeErrorCode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CryptohomeErrorCode> {
        match value {
            0 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET),
            1 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_ACCOUNT_NOT_FOUND),
            2 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_AUTHORIZATION_KEY_NOT_FOUND),
            3 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_AUTHORIZATION_KEY_FAILED),
            4 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_IMPLEMENTED),
            5 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_FATAL),
            6 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_MOUNT_POINT_BUSY),
            7 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_COMM_ERROR),
            8 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_DEFEND_LOCK),
            9 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_NEEDS_REBOOT),
            10 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_AUTHORIZATION_KEY_DENIED),
            11 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_KEY_QUOTA_EXCEEDED),
            12 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_KEY_LABEL_EXISTS),
            13 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_BACKING_STORE_FAILURE),
            14 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_UPDATE_SIGNATURE_INVALID),
            15 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_KEY_NOT_FOUND),
            16 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_LOCKBOX_SIGNATURE_INVALID),
            17 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_LOCKBOX_CANNOT_SIGN),
            18 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_BOOT_ATTRIBUTE_NOT_FOUND),
            19 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_BOOT_ATTRIBUTES_CANNOT_SIGN),
            20 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_EK_NOT_AVAILABLE),
            21 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_ATTESTATION_NOT_READY),
            22 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_CANNOT_CONNECT_TO_CA),
            23 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_CA_REFUSED_ENROLLMENT),
            24 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_CA_REFUSED_CERTIFICATE),
            25 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_INTERNAL_ATTESTATION_ERROR),
            26 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_INVALID),
            27 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_STORE),
            28 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_REMOVE),
            29 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_OLD_ENCRYPTION),
            30 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_PREVIOUS_MIGRATION_INCOMPLETE),
            31 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_MIGRATE_KEY_FAILED),
            32 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_REMOVE_FAILED),
            33 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_INVALID_ARGUMENT),
            34 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_GET_FAILED),
            35 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_SET_FAILED),
            36 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_FINALIZE_FAILED),
            37 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_UPDATE_USER_ACTIVITY_TIMESTAMP_FAILED),
            38 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FAILED_TO_READ_PCR),
            39 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_PCR_ALREADY_EXTENDED),
            40 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FAILED_TO_EXTEND_PCR),
            41 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_UPDATE_REQUIRED),
            42 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FINGERPRINT_ERROR_INTERNAL),
            43 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FINGERPRINT_RETRY_REQUIRED),
            44 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FINGERPRINT_DENIED),
            45 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_VAULT_UNRECOVERABLE),
            46 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FIDO_MAKE_CREDENTIAL_FAILED),
            47 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_FIDO_GET_ASSERTION_FAILED),
            48 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_TOKEN_SERIALIZATION_FAILED),
            49 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_INVALID_AUTH_SESSION_TOKEN),
            50 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ADD_CREDENTIALS_FAILED),
            51 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_UNAUTHENTICATED_AUTH_SESSION),
            52 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_UNKNOWN_LEGACY),
            53 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_UNUSABLE_VAULT),
            54 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_REMOVE_CREDENTIALS_FAILED),
            55 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_UPDATE_CREDENTIALS_FAILED),
            56 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_RECOVERY_TRANSIENT),
            57 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_RECOVERY_FATAL),
            58 => ::std::option::Option::Some(CryptohomeErrorCode::CRYPTOHOME_ERROR_BIOMETRICS_BUSY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CryptohomeErrorCode] = &[
        CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_ACCOUNT_NOT_FOUND,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_AUTHORIZATION_KEY_NOT_FOUND,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_AUTHORIZATION_KEY_FAILED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_IMPLEMENTED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_FATAL,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_MOUNT_POINT_BUSY,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_COMM_ERROR,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_DEFEND_LOCK,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_NEEDS_REBOOT,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_AUTHORIZATION_KEY_DENIED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_KEY_QUOTA_EXCEEDED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_KEY_LABEL_EXISTS,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_BACKING_STORE_FAILURE,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_UPDATE_SIGNATURE_INVALID,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_KEY_NOT_FOUND,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_LOCKBOX_SIGNATURE_INVALID,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_LOCKBOX_CANNOT_SIGN,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_BOOT_ATTRIBUTE_NOT_FOUND,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_BOOT_ATTRIBUTES_CANNOT_SIGN,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_EK_NOT_AVAILABLE,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_ATTESTATION_NOT_READY,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_CANNOT_CONNECT_TO_CA,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_CA_REFUSED_ENROLLMENT,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_CA_REFUSED_CERTIFICATE,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_INTERNAL_ATTESTATION_ERROR,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_INVALID,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_STORE,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_FIRMWARE_MANAGEMENT_PARAMETERS_CANNOT_REMOVE,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_OLD_ENCRYPTION,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_MOUNT_PREVIOUS_MIGRATION_INCOMPLETE,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_MIGRATE_KEY_FAILED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_REMOVE_FAILED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_INVALID_ARGUMENT,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_GET_FAILED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_SET_FAILED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_INSTALL_ATTRIBUTES_FINALIZE_FAILED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_UPDATE_USER_ACTIVITY_TIMESTAMP_FAILED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_FAILED_TO_READ_PCR,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_PCR_ALREADY_EXTENDED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_FAILED_TO_EXTEND_PCR,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_TPM_UPDATE_REQUIRED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_FINGERPRINT_ERROR_INTERNAL,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_FINGERPRINT_RETRY_REQUIRED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_FINGERPRINT_DENIED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_VAULT_UNRECOVERABLE,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_FIDO_MAKE_CREDENTIAL_FAILED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_FIDO_GET_ASSERTION_FAILED,
        CryptohomeErrorCode::CRYPTOHOME_TOKEN_SERIALIZATION_FAILED,
        CryptohomeErrorCode::CRYPTOHOME_INVALID_AUTH_SESSION_TOKEN,
        CryptohomeErrorCode::CRYPTOHOME_ADD_CREDENTIALS_FAILED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_UNAUTHENTICATED_AUTH_SESSION,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_UNKNOWN_LEGACY,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_UNUSABLE_VAULT,
        CryptohomeErrorCode::CRYPTOHOME_REMOVE_CREDENTIALS_FAILED,
        CryptohomeErrorCode::CRYPTOHOME_UPDATE_CREDENTIALS_FAILED,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_RECOVERY_TRANSIENT,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_RECOVERY_FATAL,
        CryptohomeErrorCode::CRYPTOHOME_ERROR_BIOMETRICS_BUSY,
    ];
}

impl ::std::default::Default for CryptohomeErrorCode {
    fn default() -> Self {
        CryptohomeErrorCode::CRYPTOHOME_ERROR_NOT_SET
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:user_data_auth.PrimaryAction)
pub enum PrimaryAction {
    // @@protoc_insertion_point(enum_value:user_data_auth.PrimaryAction.PRIMARY_NO_ERROR)
    PRIMARY_NO_ERROR = 0,
    // @@protoc_insertion_point(enum_value:user_data_auth.PrimaryAction.PRIMARY_NONE)
    PRIMARY_NONE = 1,
    // @@protoc_insertion_point(enum_value:user_data_auth.PrimaryAction.PRIMARY_CREATE_REQUIRED)
    PRIMARY_CREATE_REQUIRED = 2,
    // @@protoc_insertion_point(enum_value:user_data_auth.PrimaryAction.PRIMARY_NOTIFY_OLD_ENCRYPTION_POLICY)
    PRIMARY_NOTIFY_OLD_ENCRYPTION_POLICY = 3,
    // @@protoc_insertion_point(enum_value:user_data_auth.PrimaryAction.PRIMARY_RESUME_PREVIOUS_MIGRATION)
    PRIMARY_RESUME_PREVIOUS_MIGRATION = 4,
    // @@protoc_insertion_point(enum_value:user_data_auth.PrimaryAction.PRIMARY_TPM_UDPATE_REQUIRED)
    PRIMARY_TPM_UDPATE_REQUIRED = 5,
    // @@protoc_insertion_point(enum_value:user_data_auth.PrimaryAction.PRIMARY_TPM_NEEDS_REBOOT)
    PRIMARY_TPM_NEEDS_REBOOT = 6,
    // @@protoc_insertion_point(enum_value:user_data_auth.PrimaryAction.PRIMARY_TPM_LOCKOUT)
    PRIMARY_TPM_LOCKOUT = 7,
    // @@protoc_insertion_point(enum_value:user_data_auth.PrimaryAction.PRIMARY_INCORRECT_AUTH)
    PRIMARY_INCORRECT_AUTH = 8,
    // @@protoc_insertion_point(enum_value:user_data_auth.PrimaryAction.PRIMARY_LE_LOCKED_OUT)
    PRIMARY_LE_LOCKED_OUT = 9,
}

impl ::protobuf::Enum for PrimaryAction {
    const NAME: &'static str = "PrimaryAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PrimaryAction> {
        match value {
            0 => ::std::option::Option::Some(PrimaryAction::PRIMARY_NO_ERROR),
            1 => ::std::option::Option::Some(PrimaryAction::PRIMARY_NONE),
            2 => ::std::option::Option::Some(PrimaryAction::PRIMARY_CREATE_REQUIRED),
            3 => ::std::option::Option::Some(PrimaryAction::PRIMARY_NOTIFY_OLD_ENCRYPTION_POLICY),
            4 => ::std::option::Option::Some(PrimaryAction::PRIMARY_RESUME_PREVIOUS_MIGRATION),
            5 => ::std::option::Option::Some(PrimaryAction::PRIMARY_TPM_UDPATE_REQUIRED),
            6 => ::std::option::Option::Some(PrimaryAction::PRIMARY_TPM_NEEDS_REBOOT),
            7 => ::std::option::Option::Some(PrimaryAction::PRIMARY_TPM_LOCKOUT),
            8 => ::std::option::Option::Some(PrimaryAction::PRIMARY_INCORRECT_AUTH),
            9 => ::std::option::Option::Some(PrimaryAction::PRIMARY_LE_LOCKED_OUT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PrimaryAction] = &[
        PrimaryAction::PRIMARY_NO_ERROR,
        PrimaryAction::PRIMARY_NONE,
        PrimaryAction::PRIMARY_CREATE_REQUIRED,
        PrimaryAction::PRIMARY_NOTIFY_OLD_ENCRYPTION_POLICY,
        PrimaryAction::PRIMARY_RESUME_PREVIOUS_MIGRATION,
        PrimaryAction::PRIMARY_TPM_UDPATE_REQUIRED,
        PrimaryAction::PRIMARY_TPM_NEEDS_REBOOT,
        PrimaryAction::PRIMARY_TPM_LOCKOUT,
        PrimaryAction::PRIMARY_INCORRECT_AUTH,
        PrimaryAction::PRIMARY_LE_LOCKED_OUT,
    ];
}

impl ::std::default::Default for PrimaryAction {
    fn default() -> Self {
        PrimaryAction::PRIMARY_NO_ERROR
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:user_data_auth.PossibleAction)
pub enum PossibleAction {
    // @@protoc_insertion_point(enum_value:user_data_auth.PossibleAction.POSSIBLY_NONE)
    POSSIBLY_NONE = 0,
    // @@protoc_insertion_point(enum_value:user_data_auth.PossibleAction.POSSIBLY_RETRY)
    POSSIBLY_RETRY = 1,
    // @@protoc_insertion_point(enum_value:user_data_auth.PossibleAction.POSSIBLY_REBOOT)
    POSSIBLY_REBOOT = 2,
    // @@protoc_insertion_point(enum_value:user_data_auth.PossibleAction.POSSIBLY_AUTH)
    POSSIBLY_AUTH = 3,
    // @@protoc_insertion_point(enum_value:user_data_auth.PossibleAction.POSSIBLY_INCORRECT_AUTH)
    POSSIBLY_INCORRECT_AUTH = 4,
    // @@protoc_insertion_point(enum_value:user_data_auth.PossibleAction.POSSIBLY_DELETE_VAULT)
    POSSIBLY_DELETE_VAULT = 5,
    // @@protoc_insertion_point(enum_value:user_data_auth.PossibleAction.POSSIBLY_POWERWASH)
    POSSIBLY_POWERWASH = 6,
    // @@protoc_insertion_point(enum_value:user_data_auth.PossibleAction.POSSIBLY_DEV_CHECK_UNEXPECTED_STATE)
    POSSIBLY_DEV_CHECK_UNEXPECTED_STATE = 7,
    // @@protoc_insertion_point(enum_value:user_data_auth.PossibleAction.POSSIBLY_FATAL)
    POSSIBLY_FATAL = 8,
}

impl ::protobuf::Enum for PossibleAction {
    const NAME: &'static str = "PossibleAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PossibleAction> {
        match value {
            0 => ::std::option::Option::Some(PossibleAction::POSSIBLY_NONE),
            1 => ::std::option::Option::Some(PossibleAction::POSSIBLY_RETRY),
            2 => ::std::option::Option::Some(PossibleAction::POSSIBLY_REBOOT),
            3 => ::std::option::Option::Some(PossibleAction::POSSIBLY_AUTH),
            4 => ::std::option::Option::Some(PossibleAction::POSSIBLY_INCORRECT_AUTH),
            5 => ::std::option::Option::Some(PossibleAction::POSSIBLY_DELETE_VAULT),
            6 => ::std::option::Option::Some(PossibleAction::POSSIBLY_POWERWASH),
            7 => ::std::option::Option::Some(PossibleAction::POSSIBLY_DEV_CHECK_UNEXPECTED_STATE),
            8 => ::std::option::Option::Some(PossibleAction::POSSIBLY_FATAL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PossibleAction] = &[
        PossibleAction::POSSIBLY_NONE,
        PossibleAction::POSSIBLY_RETRY,
        PossibleAction::POSSIBLY_REBOOT,
        PossibleAction::POSSIBLY_AUTH,
        PossibleAction::POSSIBLY_INCORRECT_AUTH,
        PossibleAction::POSSIBLY_DELETE_VAULT,
        PossibleAction::POSSIBLY_POWERWASH,
        PossibleAction::POSSIBLY_DEV_CHECK_UNEXPECTED_STATE,
        PossibleAction::POSSIBLY_FATAL,
    ];
}

impl ::std::default::Default for PossibleAction {
    fn default() -> Self {
        PossibleAction::POSSIBLY_NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:user_data_auth.DircryptoMigrationStatus)
pub enum DircryptoMigrationStatus {
    // @@protoc_insertion_point(enum_value:user_data_auth.DircryptoMigrationStatus.DIRCRYPTO_MIGRATION_SUCCESS)
    DIRCRYPTO_MIGRATION_SUCCESS = 0,
    // @@protoc_insertion_point(enum_value:user_data_auth.DircryptoMigrationStatus.DIRCRYPTO_MIGRATION_FAILED)
    DIRCRYPTO_MIGRATION_FAILED = 1,
    // @@protoc_insertion_point(enum_value:user_data_auth.DircryptoMigrationStatus.DIRCRYPTO_MIGRATION_INITIALIZING)
    DIRCRYPTO_MIGRATION_INITIALIZING = 2,
    // @@protoc_insertion_point(enum_value:user_data_auth.DircryptoMigrationStatus.DIRCRYPTO_MIGRATION_IN_PROGRESS)
    DIRCRYPTO_MIGRATION_IN_PROGRESS = 3,
}

impl ::protobuf::Enum for DircryptoMigrationStatus {
    const NAME: &'static str = "DircryptoMigrationStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DircryptoMigrationStatus> {
        match value {
            0 => ::std::option::Option::Some(DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_SUCCESS),
            1 => ::std::option::Option::Some(DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_FAILED),
            2 => ::std::option::Option::Some(DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_INITIALIZING),
            3 => ::std::option::Option::Some(DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_IN_PROGRESS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DircryptoMigrationStatus] = &[
        DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_SUCCESS,
        DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_FAILED,
        DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_INITIALIZING,
        DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_IN_PROGRESS,
    ];
}

impl ::std::default::Default for DircryptoMigrationStatus {
    fn default() -> Self {
        DircryptoMigrationStatus::DIRCRYPTO_MIGRATION_SUCCESS
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:user_data_auth.AuthSessionFlags)
pub enum AuthSessionFlags {
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthSessionFlags.AUTH_SESSION_FLAGS_NONE)
    AUTH_SESSION_FLAGS_NONE = 0,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthSessionFlags.AUTH_SESSION_FLAGS_EPHEMERAL_USER)
    AUTH_SESSION_FLAGS_EPHEMERAL_USER = 2,
}

impl ::protobuf::Enum for AuthSessionFlags {
    const NAME: &'static str = "AuthSessionFlags";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthSessionFlags> {
        match value {
            0 => ::std::option::Option::Some(AuthSessionFlags::AUTH_SESSION_FLAGS_NONE),
            2 => ::std::option::Option::Some(AuthSessionFlags::AUTH_SESSION_FLAGS_EPHEMERAL_USER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AuthSessionFlags] = &[
        AuthSessionFlags::AUTH_SESSION_FLAGS_NONE,
        AuthSessionFlags::AUTH_SESSION_FLAGS_EPHEMERAL_USER,
    ];
}

impl ::std::default::Default for AuthSessionFlags {
    fn default() -> Self {
        AuthSessionFlags::AUTH_SESSION_FLAGS_NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:user_data_auth.AuthSessionStatus)
pub enum AuthSessionStatus {
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthSessionStatus.AUTH_SESSION_STATUS_NOT_SET)
    AUTH_SESSION_STATUS_NOT_SET = 0,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthSessionStatus.AUTH_SESSION_STATUS_FURTHER_FACTOR_REQUIRED)
    AUTH_SESSION_STATUS_FURTHER_FACTOR_REQUIRED = 1,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthSessionStatus.AUTH_SESSION_STATUS_AUTHENTICATED)
    AUTH_SESSION_STATUS_AUTHENTICATED = 2,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthSessionStatus.AUTH_SESSION_STATUS_INVALID_AUTH_SESSION)
    AUTH_SESSION_STATUS_INVALID_AUTH_SESSION = 3,
}

impl ::protobuf::Enum for AuthSessionStatus {
    const NAME: &'static str = "AuthSessionStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthSessionStatus> {
        match value {
            0 => ::std::option::Option::Some(AuthSessionStatus::AUTH_SESSION_STATUS_NOT_SET),
            1 => ::std::option::Option::Some(AuthSessionStatus::AUTH_SESSION_STATUS_FURTHER_FACTOR_REQUIRED),
            2 => ::std::option::Option::Some(AuthSessionStatus::AUTH_SESSION_STATUS_AUTHENTICATED),
            3 => ::std::option::Option::Some(AuthSessionStatus::AUTH_SESSION_STATUS_INVALID_AUTH_SESSION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AuthSessionStatus] = &[
        AuthSessionStatus::AUTH_SESSION_STATUS_NOT_SET,
        AuthSessionStatus::AUTH_SESSION_STATUS_FURTHER_FACTOR_REQUIRED,
        AuthSessionStatus::AUTH_SESSION_STATUS_AUTHENTICATED,
        AuthSessionStatus::AUTH_SESSION_STATUS_INVALID_AUTH_SESSION,
    ];
}

impl ::std::default::Default for AuthSessionStatus {
    fn default() -> Self {
        AuthSessionStatus::AUTH_SESSION_STATUS_NOT_SET
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:user_data_auth.VaultEncryptionType)
pub enum VaultEncryptionType {
    // @@protoc_insertion_point(enum_value:user_data_auth.VaultEncryptionType.CRYPTOHOME_VAULT_ENCRYPTION_ANY)
    CRYPTOHOME_VAULT_ENCRYPTION_ANY = 0,
    // @@protoc_insertion_point(enum_value:user_data_auth.VaultEncryptionType.CRYPTOHOME_VAULT_ENCRYPTION_ECRYPTFS)
    CRYPTOHOME_VAULT_ENCRYPTION_ECRYPTFS = 1,
    // @@protoc_insertion_point(enum_value:user_data_auth.VaultEncryptionType.CRYPTOHOME_VAULT_ENCRYPTION_FSCRYPT)
    CRYPTOHOME_VAULT_ENCRYPTION_FSCRYPT = 2,
    // @@protoc_insertion_point(enum_value:user_data_auth.VaultEncryptionType.CRYPTOHOME_VAULT_ENCRYPTION_DMCRYPT)
    CRYPTOHOME_VAULT_ENCRYPTION_DMCRYPT = 3,
}

impl ::protobuf::Enum for VaultEncryptionType {
    const NAME: &'static str = "VaultEncryptionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VaultEncryptionType> {
        match value {
            0 => ::std::option::Option::Some(VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ANY),
            1 => ::std::option::Option::Some(VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ECRYPTFS),
            2 => ::std::option::Option::Some(VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_FSCRYPT),
            3 => ::std::option::Option::Some(VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_DMCRYPT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VaultEncryptionType] = &[
        VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ANY,
        VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ECRYPTFS,
        VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_FSCRYPT,
        VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_DMCRYPT,
    ];
}

impl ::std::default::Default for VaultEncryptionType {
    fn default() -> Self {
        VaultEncryptionType::CRYPTOHOME_VAULT_ENCRYPTION_ANY
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:user_data_auth.InstallAttributesState)
pub enum InstallAttributesState {
    // @@protoc_insertion_point(enum_value:user_data_auth.InstallAttributesState.UNKNOWN)
    UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:user_data_auth.InstallAttributesState.TPM_NOT_OWNED)
    TPM_NOT_OWNED = 1,
    // @@protoc_insertion_point(enum_value:user_data_auth.InstallAttributesState.FIRST_INSTALL)
    FIRST_INSTALL = 2,
    // @@protoc_insertion_point(enum_value:user_data_auth.InstallAttributesState.VALID)
    VALID = 3,
    // @@protoc_insertion_point(enum_value:user_data_auth.InstallAttributesState.INVALID)
    INVALID = 4,
}

impl ::protobuf::Enum for InstallAttributesState {
    const NAME: &'static str = "InstallAttributesState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InstallAttributesState> {
        match value {
            0 => ::std::option::Option::Some(InstallAttributesState::UNKNOWN),
            1 => ::std::option::Option::Some(InstallAttributesState::TPM_NOT_OWNED),
            2 => ::std::option::Option::Some(InstallAttributesState::FIRST_INSTALL),
            3 => ::std::option::Option::Some(InstallAttributesState::VALID),
            4 => ::std::option::Option::Some(InstallAttributesState::INVALID),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [InstallAttributesState] = &[
        InstallAttributesState::UNKNOWN,
        InstallAttributesState::TPM_NOT_OWNED,
        InstallAttributesState::FIRST_INSTALL,
        InstallAttributesState::VALID,
        InstallAttributesState::INVALID,
    ];
}

impl ::std::default::Default for InstallAttributesState {
    fn default() -> Self {
        InstallAttributesState::UNKNOWN
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:user_data_auth.FingerprintScanResult)
pub enum FingerprintScanResult {
    // @@protoc_insertion_point(enum_value:user_data_auth.FingerprintScanResult.FINGERPRINT_SCAN_RESULT_SUCCESS)
    FINGERPRINT_SCAN_RESULT_SUCCESS = 0,
    // @@protoc_insertion_point(enum_value:user_data_auth.FingerprintScanResult.FINGERPRINT_SCAN_RESULT_RETRY)
    FINGERPRINT_SCAN_RESULT_RETRY = 1,
    // @@protoc_insertion_point(enum_value:user_data_auth.FingerprintScanResult.FINGERPRINT_SCAN_RESULT_LOCKOUT)
    FINGERPRINT_SCAN_RESULT_LOCKOUT = 2,
    // @@protoc_insertion_point(enum_value:user_data_auth.FingerprintScanResult.FINGERPRINT_SCAN_RESULT_FATAL_ERROR)
    FINGERPRINT_SCAN_RESULT_FATAL_ERROR = 3,
    // @@protoc_insertion_point(enum_value:user_data_auth.FingerprintScanResult.FINGERPRINT_SCAN_RESULT_PARTIAL)
    FINGERPRINT_SCAN_RESULT_PARTIAL = 4,
    // @@protoc_insertion_point(enum_value:user_data_auth.FingerprintScanResult.FINGERPRINT_SCAN_RESULT_INSUFFICIENT)
    FINGERPRINT_SCAN_RESULT_INSUFFICIENT = 5,
    // @@protoc_insertion_point(enum_value:user_data_auth.FingerprintScanResult.FINGERPRINT_SCAN_RESULT_SENSOR_DIRTY)
    FINGERPRINT_SCAN_RESULT_SENSOR_DIRTY = 6,
    // @@protoc_insertion_point(enum_value:user_data_auth.FingerprintScanResult.FINGERPRINT_SCAN_RESULT_TOO_SLOW)
    FINGERPRINT_SCAN_RESULT_TOO_SLOW = 7,
    // @@protoc_insertion_point(enum_value:user_data_auth.FingerprintScanResult.FINGERPRINT_SCAN_RESULT_TOO_FAST)
    FINGERPRINT_SCAN_RESULT_TOO_FAST = 8,
    // @@protoc_insertion_point(enum_value:user_data_auth.FingerprintScanResult.FINGERPRINT_SCAN_RESULT_IMMOBILE)
    FINGERPRINT_SCAN_RESULT_IMMOBILE = 9,
    // @@protoc_insertion_point(enum_value:user_data_auth.FingerprintScanResult.FINGERPRINT_SCAN_RESULT_ENROLL_OTHER)
    FINGERPRINT_SCAN_RESULT_ENROLL_OTHER = 10,
}

impl ::protobuf::Enum for FingerprintScanResult {
    const NAME: &'static str = "FingerprintScanResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FingerprintScanResult> {
        match value {
            0 => ::std::option::Option::Some(FingerprintScanResult::FINGERPRINT_SCAN_RESULT_SUCCESS),
            1 => ::std::option::Option::Some(FingerprintScanResult::FINGERPRINT_SCAN_RESULT_RETRY),
            2 => ::std::option::Option::Some(FingerprintScanResult::FINGERPRINT_SCAN_RESULT_LOCKOUT),
            3 => ::std::option::Option::Some(FingerprintScanResult::FINGERPRINT_SCAN_RESULT_FATAL_ERROR),
            4 => ::std::option::Option::Some(FingerprintScanResult::FINGERPRINT_SCAN_RESULT_PARTIAL),
            5 => ::std::option::Option::Some(FingerprintScanResult::FINGERPRINT_SCAN_RESULT_INSUFFICIENT),
            6 => ::std::option::Option::Some(FingerprintScanResult::FINGERPRINT_SCAN_RESULT_SENSOR_DIRTY),
            7 => ::std::option::Option::Some(FingerprintScanResult::FINGERPRINT_SCAN_RESULT_TOO_SLOW),
            8 => ::std::option::Option::Some(FingerprintScanResult::FINGERPRINT_SCAN_RESULT_TOO_FAST),
            9 => ::std::option::Option::Some(FingerprintScanResult::FINGERPRINT_SCAN_RESULT_IMMOBILE),
            10 => ::std::option::Option::Some(FingerprintScanResult::FINGERPRINT_SCAN_RESULT_ENROLL_OTHER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FingerprintScanResult] = &[
        FingerprintScanResult::FINGERPRINT_SCAN_RESULT_SUCCESS,
        FingerprintScanResult::FINGERPRINT_SCAN_RESULT_RETRY,
        FingerprintScanResult::FINGERPRINT_SCAN_RESULT_LOCKOUT,
        FingerprintScanResult::FINGERPRINT_SCAN_RESULT_FATAL_ERROR,
        FingerprintScanResult::FINGERPRINT_SCAN_RESULT_PARTIAL,
        FingerprintScanResult::FINGERPRINT_SCAN_RESULT_INSUFFICIENT,
        FingerprintScanResult::FINGERPRINT_SCAN_RESULT_SENSOR_DIRTY,
        FingerprintScanResult::FINGERPRINT_SCAN_RESULT_TOO_SLOW,
        FingerprintScanResult::FINGERPRINT_SCAN_RESULT_TOO_FAST,
        FingerprintScanResult::FINGERPRINT_SCAN_RESULT_IMMOBILE,
        FingerprintScanResult::FINGERPRINT_SCAN_RESULT_ENROLL_OTHER,
    ];
}

impl ::std::default::Default for FingerprintScanResult {
    fn default() -> Self {
        FingerprintScanResult::FINGERPRINT_SCAN_RESULT_SUCCESS
    }
}

