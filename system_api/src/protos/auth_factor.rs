// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.21.9
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `auth_factor.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PasswordAuthInput)
pub struct PasswordAuthInput {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.PasswordAuthInput.secret)
    pub secret: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PasswordAuthInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PasswordAuthInput {
    fn default() -> &'a PasswordAuthInput {
        <PasswordAuthInput as ::protobuf::Message>::default_instance()
    }
}

impl PasswordAuthInput {
    pub fn new() -> PasswordAuthInput {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PasswordAuthInput {
    const NAME: &'static str = "PasswordAuthInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.secret = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.secret.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.secret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.secret.is_empty() {
            os.write_bytes(1, &self.secret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PasswordAuthInput {
        PasswordAuthInput::new()
    }

    fn clear(&mut self) {
        self.secret.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PasswordAuthInput {
        static instance: PasswordAuthInput = PasswordAuthInput {
            secret: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PinAuthInput)
pub struct PinAuthInput {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.PinAuthInput.secret)
    pub secret: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PinAuthInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PinAuthInput {
    fn default() -> &'a PinAuthInput {
        <PinAuthInput as ::protobuf::Message>::default_instance()
    }
}

impl PinAuthInput {
    pub fn new() -> PinAuthInput {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PinAuthInput {
    const NAME: &'static str = "PinAuthInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.secret = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.secret.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.secret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.secret.is_empty() {
            os.write_bytes(1, &self.secret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PinAuthInput {
        PinAuthInput::new()
    }

    fn clear(&mut self) {
        self.secret.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PinAuthInput {
        static instance: PinAuthInput = PinAuthInput {
            secret: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.CryptohomeRecoveryAuthInput)
pub struct CryptohomeRecoveryAuthInput {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.CryptohomeRecoveryAuthInput.mediator_pub_key)
    pub mediator_pub_key: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:user_data_auth.CryptohomeRecoveryAuthInput.user_gaia_id)
    pub user_gaia_id: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.CryptohomeRecoveryAuthInput.device_user_id)
    pub device_user_id: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.CryptohomeRecoveryAuthInput.epoch_response)
    pub epoch_response: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:user_data_auth.CryptohomeRecoveryAuthInput.recovery_response)
    pub recovery_response: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:user_data_auth.CryptohomeRecoveryAuthInput.ledger_info)
    pub ledger_info: ::protobuf::MessageField<cryptohome_recovery_auth_input::LedgerInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.CryptohomeRecoveryAuthInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CryptohomeRecoveryAuthInput {
    fn default() -> &'a CryptohomeRecoveryAuthInput {
        <CryptohomeRecoveryAuthInput as ::protobuf::Message>::default_instance()
    }
}

impl CryptohomeRecoveryAuthInput {
    pub fn new() -> CryptohomeRecoveryAuthInput {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CryptohomeRecoveryAuthInput {
    const NAME: &'static str = "CryptohomeRecoveryAuthInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mediator_pub_key = is.read_bytes()?;
                },
                18 => {
                    self.user_gaia_id = is.read_string()?;
                },
                26 => {
                    self.device_user_id = is.read_string()?;
                },
                34 => {
                    self.epoch_response = is.read_bytes()?;
                },
                42 => {
                    self.recovery_response = is.read_bytes()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ledger_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.mediator_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.mediator_pub_key);
        }
        if !self.user_gaia_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user_gaia_id);
        }
        if !self.device_user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.device_user_id);
        }
        if !self.epoch_response.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.epoch_response);
        }
        if !self.recovery_response.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.recovery_response);
        }
        if let Some(v) = self.ledger_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.mediator_pub_key.is_empty() {
            os.write_bytes(1, &self.mediator_pub_key)?;
        }
        if !self.user_gaia_id.is_empty() {
            os.write_string(2, &self.user_gaia_id)?;
        }
        if !self.device_user_id.is_empty() {
            os.write_string(3, &self.device_user_id)?;
        }
        if !self.epoch_response.is_empty() {
            os.write_bytes(4, &self.epoch_response)?;
        }
        if !self.recovery_response.is_empty() {
            os.write_bytes(5, &self.recovery_response)?;
        }
        if let Some(v) = self.ledger_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CryptohomeRecoveryAuthInput {
        CryptohomeRecoveryAuthInput::new()
    }

    fn clear(&mut self) {
        self.mediator_pub_key.clear();
        self.user_gaia_id.clear();
        self.device_user_id.clear();
        self.epoch_response.clear();
        self.recovery_response.clear();
        self.ledger_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CryptohomeRecoveryAuthInput {
        static instance: CryptohomeRecoveryAuthInput = CryptohomeRecoveryAuthInput {
            mediator_pub_key: ::std::vec::Vec::new(),
            user_gaia_id: ::std::string::String::new(),
            device_user_id: ::std::string::String::new(),
            epoch_response: ::std::vec::Vec::new(),
            recovery_response: ::std::vec::Vec::new(),
            ledger_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CryptohomeRecoveryAuthInput`
pub mod cryptohome_recovery_auth_input {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:user_data_auth.CryptohomeRecoveryAuthInput.LedgerInfo)
    pub struct LedgerInfo {
        // message fields
        // @@protoc_insertion_point(field:user_data_auth.CryptohomeRecoveryAuthInput.LedgerInfo.name)
        pub name: ::std::string::String,
        // @@protoc_insertion_point(field:user_data_auth.CryptohomeRecoveryAuthInput.LedgerInfo.key_hash)
        pub key_hash: u32,
        // @@protoc_insertion_point(field:user_data_auth.CryptohomeRecoveryAuthInput.LedgerInfo.public_key)
        pub public_key: ::std::vec::Vec<u8>,
        // special fields
        // @@protoc_insertion_point(special_field:user_data_auth.CryptohomeRecoveryAuthInput.LedgerInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LedgerInfo {
        fn default() -> &'a LedgerInfo {
            <LedgerInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl LedgerInfo {
        pub fn new() -> LedgerInfo {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for LedgerInfo {
        const NAME: &'static str = "LedgerInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = is.read_string()?;
                    },
                    16 => {
                        self.key_hash = is.read_uint32()?;
                    },
                    26 => {
                        self.public_key = is.read_bytes()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.name);
            }
            if self.key_hash != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.key_hash);
            }
            if !self.public_key.is_empty() {
                my_size += ::protobuf::rt::bytes_size(3, &self.public_key);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.name.is_empty() {
                os.write_string(1, &self.name)?;
            }
            if self.key_hash != 0 {
                os.write_uint32(2, self.key_hash)?;
            }
            if !self.public_key.is_empty() {
                os.write_bytes(3, &self.public_key)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LedgerInfo {
            LedgerInfo::new()
        }

        fn clear(&mut self) {
            self.name.clear();
            self.key_hash = 0;
            self.public_key.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LedgerInfo {
            static instance: LedgerInfo = LedgerInfo {
                name: ::std::string::String::new(),
                key_hash: 0,
                public_key: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.KioskAuthInput)
pub struct KioskAuthInput {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.KioskAuthInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KioskAuthInput {
    fn default() -> &'a KioskAuthInput {
        <KioskAuthInput as ::protobuf::Message>::default_instance()
    }
}

impl KioskAuthInput {
    pub fn new() -> KioskAuthInput {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for KioskAuthInput {
    const NAME: &'static str = "KioskAuthInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KioskAuthInput {
        KioskAuthInput::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KioskAuthInput {
        static instance: KioskAuthInput = KioskAuthInput {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.SmartCardAuthInput)
pub struct SmartCardAuthInput {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.SmartCardAuthInput.signature_algorithms)
    pub signature_algorithms: ::std::vec::Vec<::protobuf::EnumOrUnknown<SmartCardSignatureAlgorithm>>,
    // @@protoc_insertion_point(field:user_data_auth.SmartCardAuthInput.key_delegate_dbus_service_name)
    pub key_delegate_dbus_service_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.SmartCardAuthInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SmartCardAuthInput {
    fn default() -> &'a SmartCardAuthInput {
        <SmartCardAuthInput as ::protobuf::Message>::default_instance()
    }
}

impl SmartCardAuthInput {
    pub fn new() -> SmartCardAuthInput {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SmartCardAuthInput {
    const NAME: &'static str = "SmartCardAuthInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.signature_algorithms.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.signature_algorithms)?
                },
                18 => {
                    self.key_delegate_dbus_service_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.signature_algorithms {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        if !self.key_delegate_dbus_service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key_delegate_dbus_service_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.signature_algorithms {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if !self.key_delegate_dbus_service_name.is_empty() {
            os.write_string(2, &self.key_delegate_dbus_service_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SmartCardAuthInput {
        SmartCardAuthInput::new()
    }

    fn clear(&mut self) {
        self.signature_algorithms.clear();
        self.key_delegate_dbus_service_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SmartCardAuthInput {
        static instance: SmartCardAuthInput = SmartCardAuthInput {
            signature_algorithms: ::std::vec::Vec::new(),
            key_delegate_dbus_service_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.LegacyFingerprintAuthInput)
pub struct LegacyFingerprintAuthInput {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.LegacyFingerprintAuthInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LegacyFingerprintAuthInput {
    fn default() -> &'a LegacyFingerprintAuthInput {
        <LegacyFingerprintAuthInput as ::protobuf::Message>::default_instance()
    }
}

impl LegacyFingerprintAuthInput {
    pub fn new() -> LegacyFingerprintAuthInput {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LegacyFingerprintAuthInput {
    const NAME: &'static str = "LegacyFingerprintAuthInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LegacyFingerprintAuthInput {
        LegacyFingerprintAuthInput::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LegacyFingerprintAuthInput {
        static instance: LegacyFingerprintAuthInput = LegacyFingerprintAuthInput {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.FingerprintAuthInput)
pub struct FingerprintAuthInput {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.FingerprintAuthInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FingerprintAuthInput {
    fn default() -> &'a FingerprintAuthInput {
        <FingerprintAuthInput as ::protobuf::Message>::default_instance()
    }
}

impl FingerprintAuthInput {
    pub fn new() -> FingerprintAuthInput {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FingerprintAuthInput {
    const NAME: &'static str = "FingerprintAuthInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FingerprintAuthInput {
        FingerprintAuthInput::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FingerprintAuthInput {
        static instance: FingerprintAuthInput = FingerprintAuthInput {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.AuthInput)
pub struct AuthInput {
    // message oneof groups
    pub input: ::std::option::Option<auth_input::Input>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.AuthInput.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthInput {
    fn default() -> &'a AuthInput {
        <AuthInput as ::protobuf::Message>::default_instance()
    }
}

impl AuthInput {
    pub fn new() -> AuthInput {
        ::std::default::Default::default()
    }

    // .user_data_auth.PasswordAuthInput password_input = 1;

    pub fn password_input(&self) -> &PasswordAuthInput {
        match self.input {
            ::std::option::Option::Some(auth_input::Input::PasswordInput(ref v)) => v,
            _ => <PasswordAuthInput as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_password_input(&mut self) {
        self.input = ::std::option::Option::None;
    }

    pub fn has_password_input(&self) -> bool {
        match self.input {
            ::std::option::Option::Some(auth_input::Input::PasswordInput(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_password_input(&mut self, v: PasswordAuthInput) {
        self.input = ::std::option::Option::Some(auth_input::Input::PasswordInput(v))
    }

    // Mutable pointer to the field.
    pub fn mut_password_input(&mut self) -> &mut PasswordAuthInput {
        if let ::std::option::Option::Some(auth_input::Input::PasswordInput(_)) = self.input {
        } else {
            self.input = ::std::option::Option::Some(auth_input::Input::PasswordInput(PasswordAuthInput::new()));
        }
        match self.input {
            ::std::option::Option::Some(auth_input::Input::PasswordInput(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_password_input(&mut self) -> PasswordAuthInput {
        if self.has_password_input() {
            match self.input.take() {
                ::std::option::Option::Some(auth_input::Input::PasswordInput(v)) => v,
                _ => panic!(),
            }
        } else {
            PasswordAuthInput::new()
        }
    }

    // .user_data_auth.PinAuthInput pin_input = 2;

    pub fn pin_input(&self) -> &PinAuthInput {
        match self.input {
            ::std::option::Option::Some(auth_input::Input::PinInput(ref v)) => v,
            _ => <PinAuthInput as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pin_input(&mut self) {
        self.input = ::std::option::Option::None;
    }

    pub fn has_pin_input(&self) -> bool {
        match self.input {
            ::std::option::Option::Some(auth_input::Input::PinInput(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pin_input(&mut self, v: PinAuthInput) {
        self.input = ::std::option::Option::Some(auth_input::Input::PinInput(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pin_input(&mut self) -> &mut PinAuthInput {
        if let ::std::option::Option::Some(auth_input::Input::PinInput(_)) = self.input {
        } else {
            self.input = ::std::option::Option::Some(auth_input::Input::PinInput(PinAuthInput::new()));
        }
        match self.input {
            ::std::option::Option::Some(auth_input::Input::PinInput(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pin_input(&mut self) -> PinAuthInput {
        if self.has_pin_input() {
            match self.input.take() {
                ::std::option::Option::Some(auth_input::Input::PinInput(v)) => v,
                _ => panic!(),
            }
        } else {
            PinAuthInput::new()
        }
    }

    // .user_data_auth.CryptohomeRecoveryAuthInput cryptohome_recovery_input = 3;

    pub fn cryptohome_recovery_input(&self) -> &CryptohomeRecoveryAuthInput {
        match self.input {
            ::std::option::Option::Some(auth_input::Input::CryptohomeRecoveryInput(ref v)) => v,
            _ => <CryptohomeRecoveryAuthInput as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cryptohome_recovery_input(&mut self) {
        self.input = ::std::option::Option::None;
    }

    pub fn has_cryptohome_recovery_input(&self) -> bool {
        match self.input {
            ::std::option::Option::Some(auth_input::Input::CryptohomeRecoveryInput(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cryptohome_recovery_input(&mut self, v: CryptohomeRecoveryAuthInput) {
        self.input = ::std::option::Option::Some(auth_input::Input::CryptohomeRecoveryInput(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cryptohome_recovery_input(&mut self) -> &mut CryptohomeRecoveryAuthInput {
        if let ::std::option::Option::Some(auth_input::Input::CryptohomeRecoveryInput(_)) = self.input {
        } else {
            self.input = ::std::option::Option::Some(auth_input::Input::CryptohomeRecoveryInput(CryptohomeRecoveryAuthInput::new()));
        }
        match self.input {
            ::std::option::Option::Some(auth_input::Input::CryptohomeRecoveryInput(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cryptohome_recovery_input(&mut self) -> CryptohomeRecoveryAuthInput {
        if self.has_cryptohome_recovery_input() {
            match self.input.take() {
                ::std::option::Option::Some(auth_input::Input::CryptohomeRecoveryInput(v)) => v,
                _ => panic!(),
            }
        } else {
            CryptohomeRecoveryAuthInput::new()
        }
    }

    // .user_data_auth.KioskAuthInput kiosk_input = 4;

    pub fn kiosk_input(&self) -> &KioskAuthInput {
        match self.input {
            ::std::option::Option::Some(auth_input::Input::KioskInput(ref v)) => v,
            _ => <KioskAuthInput as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_kiosk_input(&mut self) {
        self.input = ::std::option::Option::None;
    }

    pub fn has_kiosk_input(&self) -> bool {
        match self.input {
            ::std::option::Option::Some(auth_input::Input::KioskInput(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_kiosk_input(&mut self, v: KioskAuthInput) {
        self.input = ::std::option::Option::Some(auth_input::Input::KioskInput(v))
    }

    // Mutable pointer to the field.
    pub fn mut_kiosk_input(&mut self) -> &mut KioskAuthInput {
        if let ::std::option::Option::Some(auth_input::Input::KioskInput(_)) = self.input {
        } else {
            self.input = ::std::option::Option::Some(auth_input::Input::KioskInput(KioskAuthInput::new()));
        }
        match self.input {
            ::std::option::Option::Some(auth_input::Input::KioskInput(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_kiosk_input(&mut self) -> KioskAuthInput {
        if self.has_kiosk_input() {
            match self.input.take() {
                ::std::option::Option::Some(auth_input::Input::KioskInput(v)) => v,
                _ => panic!(),
            }
        } else {
            KioskAuthInput::new()
        }
    }

    // .user_data_auth.SmartCardAuthInput smart_card_input = 5;

    pub fn smart_card_input(&self) -> &SmartCardAuthInput {
        match self.input {
            ::std::option::Option::Some(auth_input::Input::SmartCardInput(ref v)) => v,
            _ => <SmartCardAuthInput as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_smart_card_input(&mut self) {
        self.input = ::std::option::Option::None;
    }

    pub fn has_smart_card_input(&self) -> bool {
        match self.input {
            ::std::option::Option::Some(auth_input::Input::SmartCardInput(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_smart_card_input(&mut self, v: SmartCardAuthInput) {
        self.input = ::std::option::Option::Some(auth_input::Input::SmartCardInput(v))
    }

    // Mutable pointer to the field.
    pub fn mut_smart_card_input(&mut self) -> &mut SmartCardAuthInput {
        if let ::std::option::Option::Some(auth_input::Input::SmartCardInput(_)) = self.input {
        } else {
            self.input = ::std::option::Option::Some(auth_input::Input::SmartCardInput(SmartCardAuthInput::new()));
        }
        match self.input {
            ::std::option::Option::Some(auth_input::Input::SmartCardInput(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_smart_card_input(&mut self) -> SmartCardAuthInput {
        if self.has_smart_card_input() {
            match self.input.take() {
                ::std::option::Option::Some(auth_input::Input::SmartCardInput(v)) => v,
                _ => panic!(),
            }
        } else {
            SmartCardAuthInput::new()
        }
    }

    // .user_data_auth.LegacyFingerprintAuthInput legacy_fingerprint_input = 6;

    pub fn legacy_fingerprint_input(&self) -> &LegacyFingerprintAuthInput {
        match self.input {
            ::std::option::Option::Some(auth_input::Input::LegacyFingerprintInput(ref v)) => v,
            _ => <LegacyFingerprintAuthInput as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_legacy_fingerprint_input(&mut self) {
        self.input = ::std::option::Option::None;
    }

    pub fn has_legacy_fingerprint_input(&self) -> bool {
        match self.input {
            ::std::option::Option::Some(auth_input::Input::LegacyFingerprintInput(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_legacy_fingerprint_input(&mut self, v: LegacyFingerprintAuthInput) {
        self.input = ::std::option::Option::Some(auth_input::Input::LegacyFingerprintInput(v))
    }

    // Mutable pointer to the field.
    pub fn mut_legacy_fingerprint_input(&mut self) -> &mut LegacyFingerprintAuthInput {
        if let ::std::option::Option::Some(auth_input::Input::LegacyFingerprintInput(_)) = self.input {
        } else {
            self.input = ::std::option::Option::Some(auth_input::Input::LegacyFingerprintInput(LegacyFingerprintAuthInput::new()));
        }
        match self.input {
            ::std::option::Option::Some(auth_input::Input::LegacyFingerprintInput(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_legacy_fingerprint_input(&mut self) -> LegacyFingerprintAuthInput {
        if self.has_legacy_fingerprint_input() {
            match self.input.take() {
                ::std::option::Option::Some(auth_input::Input::LegacyFingerprintInput(v)) => v,
                _ => panic!(),
            }
        } else {
            LegacyFingerprintAuthInput::new()
        }
    }

    // .user_data_auth.FingerprintAuthInput fingerprint_input = 7;

    pub fn fingerprint_input(&self) -> &FingerprintAuthInput {
        match self.input {
            ::std::option::Option::Some(auth_input::Input::FingerprintInput(ref v)) => v,
            _ => <FingerprintAuthInput as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_fingerprint_input(&mut self) {
        self.input = ::std::option::Option::None;
    }

    pub fn has_fingerprint_input(&self) -> bool {
        match self.input {
            ::std::option::Option::Some(auth_input::Input::FingerprintInput(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fingerprint_input(&mut self, v: FingerprintAuthInput) {
        self.input = ::std::option::Option::Some(auth_input::Input::FingerprintInput(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fingerprint_input(&mut self) -> &mut FingerprintAuthInput {
        if let ::std::option::Option::Some(auth_input::Input::FingerprintInput(_)) = self.input {
        } else {
            self.input = ::std::option::Option::Some(auth_input::Input::FingerprintInput(FingerprintAuthInput::new()));
        }
        match self.input {
            ::std::option::Option::Some(auth_input::Input::FingerprintInput(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fingerprint_input(&mut self) -> FingerprintAuthInput {
        if self.has_fingerprint_input() {
            match self.input.take() {
                ::std::option::Option::Some(auth_input::Input::FingerprintInput(v)) => v,
                _ => panic!(),
            }
        } else {
            FingerprintAuthInput::new()
        }
    }
}

impl ::protobuf::Message for AuthInput {
    const NAME: &'static str = "AuthInput";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.input = ::std::option::Option::Some(auth_input::Input::PasswordInput(is.read_message()?));
                },
                18 => {
                    self.input = ::std::option::Option::Some(auth_input::Input::PinInput(is.read_message()?));
                },
                26 => {
                    self.input = ::std::option::Option::Some(auth_input::Input::CryptohomeRecoveryInput(is.read_message()?));
                },
                34 => {
                    self.input = ::std::option::Option::Some(auth_input::Input::KioskInput(is.read_message()?));
                },
                42 => {
                    self.input = ::std::option::Option::Some(auth_input::Input::SmartCardInput(is.read_message()?));
                },
                50 => {
                    self.input = ::std::option::Option::Some(auth_input::Input::LegacyFingerprintInput(is.read_message()?));
                },
                58 => {
                    self.input = ::std::option::Option::Some(auth_input::Input::FingerprintInput(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.input {
            match v {
                &auth_input::Input::PasswordInput(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &auth_input::Input::PinInput(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &auth_input::Input::CryptohomeRecoveryInput(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &auth_input::Input::KioskInput(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &auth_input::Input::SmartCardInput(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &auth_input::Input::LegacyFingerprintInput(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &auth_input::Input::FingerprintInput(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.input {
            match v {
                &auth_input::Input::PasswordInput(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &auth_input::Input::PinInput(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &auth_input::Input::CryptohomeRecoveryInput(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &auth_input::Input::KioskInput(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &auth_input::Input::SmartCardInput(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &auth_input::Input::LegacyFingerprintInput(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &auth_input::Input::FingerprintInput(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthInput {
        AuthInput::new()
    }

    fn clear(&mut self) {
        self.input = ::std::option::Option::None;
        self.input = ::std::option::Option::None;
        self.input = ::std::option::Option::None;
        self.input = ::std::option::Option::None;
        self.input = ::std::option::Option::None;
        self.input = ::std::option::Option::None;
        self.input = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthInput {
        static instance: AuthInput = AuthInput {
            input: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `AuthInput`
pub mod auth_input {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:user_data_auth.AuthInput.input)
    pub enum Input {
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthInput.password_input)
        PasswordInput(super::PasswordAuthInput),
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthInput.pin_input)
        PinInput(super::PinAuthInput),
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthInput.cryptohome_recovery_input)
        CryptohomeRecoveryInput(super::CryptohomeRecoveryAuthInput),
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthInput.kiosk_input)
        KioskInput(super::KioskAuthInput),
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthInput.smart_card_input)
        SmartCardInput(super::SmartCardAuthInput),
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthInput.legacy_fingerprint_input)
        LegacyFingerprintInput(super::LegacyFingerprintAuthInput),
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthInput.fingerprint_input)
        FingerprintInput(super::FingerprintAuthInput),
    }

    impl ::protobuf::Oneof for Input {
    }

    impl Input {
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PasswordMetadata)
pub struct PasswordMetadata {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PasswordMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PasswordMetadata {
    fn default() -> &'a PasswordMetadata {
        <PasswordMetadata as ::protobuf::Message>::default_instance()
    }
}

impl PasswordMetadata {
    pub fn new() -> PasswordMetadata {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PasswordMetadata {
    const NAME: &'static str = "PasswordMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PasswordMetadata {
        PasswordMetadata::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PasswordMetadata {
        static instance: PasswordMetadata = PasswordMetadata {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.PinMetadata)
pub struct PinMetadata {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.PinMetadata.auth_locked)
    pub auth_locked: bool,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.PinMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PinMetadata {
    fn default() -> &'a PinMetadata {
        <PinMetadata as ::protobuf::Message>::default_instance()
    }
}

impl PinMetadata {
    pub fn new() -> PinMetadata {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PinMetadata {
    const NAME: &'static str = "PinMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.auth_locked = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.auth_locked != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.auth_locked != false {
            os.write_bool(1, self.auth_locked)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PinMetadata {
        PinMetadata::new()
    }

    fn clear(&mut self) {
        self.auth_locked = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PinMetadata {
        static instance: PinMetadata = PinMetadata {
            auth_locked: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.CryptohomeRecoveryMetadata)
pub struct CryptohomeRecoveryMetadata {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.CryptohomeRecoveryMetadata.mediator_pub_key)
    pub mediator_pub_key: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.CryptohomeRecoveryMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CryptohomeRecoveryMetadata {
    fn default() -> &'a CryptohomeRecoveryMetadata {
        <CryptohomeRecoveryMetadata as ::protobuf::Message>::default_instance()
    }
}

impl CryptohomeRecoveryMetadata {
    pub fn new() -> CryptohomeRecoveryMetadata {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CryptohomeRecoveryMetadata {
    const NAME: &'static str = "CryptohomeRecoveryMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mediator_pub_key = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.mediator_pub_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.mediator_pub_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.mediator_pub_key.is_empty() {
            os.write_bytes(1, &self.mediator_pub_key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CryptohomeRecoveryMetadata {
        CryptohomeRecoveryMetadata::new()
    }

    fn clear(&mut self) {
        self.mediator_pub_key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CryptohomeRecoveryMetadata {
        static instance: CryptohomeRecoveryMetadata = CryptohomeRecoveryMetadata {
            mediator_pub_key: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.KioskMetadata)
pub struct KioskMetadata {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.KioskMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KioskMetadata {
    fn default() -> &'a KioskMetadata {
        <KioskMetadata as ::protobuf::Message>::default_instance()
    }
}

impl KioskMetadata {
    pub fn new() -> KioskMetadata {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for KioskMetadata {
    const NAME: &'static str = "KioskMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KioskMetadata {
        KioskMetadata::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KioskMetadata {
        static instance: KioskMetadata = KioskMetadata {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.SmartCardMetadata)
pub struct SmartCardMetadata {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.SmartCardMetadata.public_key_spki_der)
    pub public_key_spki_der: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.SmartCardMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SmartCardMetadata {
    fn default() -> &'a SmartCardMetadata {
        <SmartCardMetadata as ::protobuf::Message>::default_instance()
    }
}

impl SmartCardMetadata {
    pub fn new() -> SmartCardMetadata {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SmartCardMetadata {
    const NAME: &'static str = "SmartCardMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.public_key_spki_der = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.public_key_spki_der.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.public_key_spki_der);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.public_key_spki_der.is_empty() {
            os.write_bytes(1, &self.public_key_spki_der)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SmartCardMetadata {
        SmartCardMetadata::new()
    }

    fn clear(&mut self) {
        self.public_key_spki_der.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SmartCardMetadata {
        static instance: SmartCardMetadata = SmartCardMetadata {
            public_key_spki_der: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.CommonMetadata)
pub struct CommonMetadata {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.CommonMetadata.chromeos_version_last_updated)
    pub chromeos_version_last_updated: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.CommonMetadata.chrome_version_last_updated)
    pub chrome_version_last_updated: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.CommonMetadata.lockout_policy)
    pub lockout_policy: ::protobuf::EnumOrUnknown<LockoutPolicy>,
    // @@protoc_insertion_point(field:user_data_auth.CommonMetadata.user_specified_name)
    pub user_specified_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.CommonMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CommonMetadata {
    fn default() -> &'a CommonMetadata {
        <CommonMetadata as ::protobuf::Message>::default_instance()
    }
}

impl CommonMetadata {
    pub fn new() -> CommonMetadata {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CommonMetadata {
    const NAME: &'static str = "CommonMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.chromeos_version_last_updated = is.read_string()?;
                },
                18 => {
                    self.chrome_version_last_updated = is.read_string()?;
                },
                24 => {
                    self.lockout_policy = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.user_specified_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.chromeos_version_last_updated.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.chromeos_version_last_updated);
        }
        if !self.chrome_version_last_updated.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.chrome_version_last_updated);
        }
        if self.lockout_policy != ::protobuf::EnumOrUnknown::new(LockoutPolicy::LOCKOUT_POLICY_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.lockout_policy.value());
        }
        if !self.user_specified_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.user_specified_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.chromeos_version_last_updated.is_empty() {
            os.write_string(1, &self.chromeos_version_last_updated)?;
        }
        if !self.chrome_version_last_updated.is_empty() {
            os.write_string(2, &self.chrome_version_last_updated)?;
        }
        if self.lockout_policy != ::protobuf::EnumOrUnknown::new(LockoutPolicy::LOCKOUT_POLICY_UNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.lockout_policy))?;
        }
        if !self.user_specified_name.is_empty() {
            os.write_string(4, &self.user_specified_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CommonMetadata {
        CommonMetadata::new()
    }

    fn clear(&mut self) {
        self.chromeos_version_last_updated.clear();
        self.chrome_version_last_updated.clear();
        self.lockout_policy = ::protobuf::EnumOrUnknown::new(LockoutPolicy::LOCKOUT_POLICY_UNKNOWN);
        self.user_specified_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CommonMetadata {
        static instance: CommonMetadata = CommonMetadata {
            chromeos_version_last_updated: ::std::string::String::new(),
            chrome_version_last_updated: ::std::string::String::new(),
            lockout_policy: ::protobuf::EnumOrUnknown::from_i32(0),
            user_specified_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.LegacyFingerprintMetadata)
pub struct LegacyFingerprintMetadata {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.LegacyFingerprintMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LegacyFingerprintMetadata {
    fn default() -> &'a LegacyFingerprintMetadata {
        <LegacyFingerprintMetadata as ::protobuf::Message>::default_instance()
    }
}

impl LegacyFingerprintMetadata {
    pub fn new() -> LegacyFingerprintMetadata {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LegacyFingerprintMetadata {
    const NAME: &'static str = "LegacyFingerprintMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LegacyFingerprintMetadata {
        LegacyFingerprintMetadata::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LegacyFingerprintMetadata {
        static instance: LegacyFingerprintMetadata = LegacyFingerprintMetadata {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.FingerprintMetadata)
pub struct FingerprintMetadata {
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.FingerprintMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FingerprintMetadata {
    fn default() -> &'a FingerprintMetadata {
        <FingerprintMetadata as ::protobuf::Message>::default_instance()
    }
}

impl FingerprintMetadata {
    pub fn new() -> FingerprintMetadata {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FingerprintMetadata {
    const NAME: &'static str = "FingerprintMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FingerprintMetadata {
        FingerprintMetadata::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FingerprintMetadata {
        static instance: FingerprintMetadata = FingerprintMetadata {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:user_data_auth.AuthFactor)
pub struct AuthFactor {
    // message fields
    // @@protoc_insertion_point(field:user_data_auth.AuthFactor.type)
    pub type_: ::protobuf::EnumOrUnknown<AuthFactorType>,
    // @@protoc_insertion_point(field:user_data_auth.AuthFactor.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:user_data_auth.AuthFactor.common_metadata)
    pub common_metadata: ::protobuf::MessageField<CommonMetadata>,
    // message oneof groups
    pub metadata: ::std::option::Option<auth_factor::Metadata>,
    // special fields
    // @@protoc_insertion_point(special_field:user_data_auth.AuthFactor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AuthFactor {
    fn default() -> &'a AuthFactor {
        <AuthFactor as ::protobuf::Message>::default_instance()
    }
}

impl AuthFactor {
    pub fn new() -> AuthFactor {
        ::std::default::Default::default()
    }

    // .user_data_auth.PasswordMetadata password_metadata = 4;

    pub fn password_metadata(&self) -> &PasswordMetadata {
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::PasswordMetadata(ref v)) => v,
            _ => <PasswordMetadata as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_password_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_password_metadata(&self) -> bool {
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::PasswordMetadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_password_metadata(&mut self, v: PasswordMetadata) {
        self.metadata = ::std::option::Option::Some(auth_factor::Metadata::PasswordMetadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_password_metadata(&mut self) -> &mut PasswordMetadata {
        if let ::std::option::Option::Some(auth_factor::Metadata::PasswordMetadata(_)) = self.metadata {
        } else {
            self.metadata = ::std::option::Option::Some(auth_factor::Metadata::PasswordMetadata(PasswordMetadata::new()));
        }
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::PasswordMetadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_password_metadata(&mut self) -> PasswordMetadata {
        if self.has_password_metadata() {
            match self.metadata.take() {
                ::std::option::Option::Some(auth_factor::Metadata::PasswordMetadata(v)) => v,
                _ => panic!(),
            }
        } else {
            PasswordMetadata::new()
        }
    }

    // .user_data_auth.PinMetadata pin_metadata = 5;

    pub fn pin_metadata(&self) -> &PinMetadata {
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::PinMetadata(ref v)) => v,
            _ => <PinMetadata as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pin_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_pin_metadata(&self) -> bool {
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::PinMetadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pin_metadata(&mut self, v: PinMetadata) {
        self.metadata = ::std::option::Option::Some(auth_factor::Metadata::PinMetadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pin_metadata(&mut self) -> &mut PinMetadata {
        if let ::std::option::Option::Some(auth_factor::Metadata::PinMetadata(_)) = self.metadata {
        } else {
            self.metadata = ::std::option::Option::Some(auth_factor::Metadata::PinMetadata(PinMetadata::new()));
        }
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::PinMetadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pin_metadata(&mut self) -> PinMetadata {
        if self.has_pin_metadata() {
            match self.metadata.take() {
                ::std::option::Option::Some(auth_factor::Metadata::PinMetadata(v)) => v,
                _ => panic!(),
            }
        } else {
            PinMetadata::new()
        }
    }

    // .user_data_auth.CryptohomeRecoveryMetadata cryptohome_recovery_metadata = 6;

    pub fn cryptohome_recovery_metadata(&self) -> &CryptohomeRecoveryMetadata {
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::CryptohomeRecoveryMetadata(ref v)) => v,
            _ => <CryptohomeRecoveryMetadata as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cryptohome_recovery_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_cryptohome_recovery_metadata(&self) -> bool {
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::CryptohomeRecoveryMetadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cryptohome_recovery_metadata(&mut self, v: CryptohomeRecoveryMetadata) {
        self.metadata = ::std::option::Option::Some(auth_factor::Metadata::CryptohomeRecoveryMetadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cryptohome_recovery_metadata(&mut self) -> &mut CryptohomeRecoveryMetadata {
        if let ::std::option::Option::Some(auth_factor::Metadata::CryptohomeRecoveryMetadata(_)) = self.metadata {
        } else {
            self.metadata = ::std::option::Option::Some(auth_factor::Metadata::CryptohomeRecoveryMetadata(CryptohomeRecoveryMetadata::new()));
        }
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::CryptohomeRecoveryMetadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cryptohome_recovery_metadata(&mut self) -> CryptohomeRecoveryMetadata {
        if self.has_cryptohome_recovery_metadata() {
            match self.metadata.take() {
                ::std::option::Option::Some(auth_factor::Metadata::CryptohomeRecoveryMetadata(v)) => v,
                _ => panic!(),
            }
        } else {
            CryptohomeRecoveryMetadata::new()
        }
    }

    // .user_data_auth.KioskMetadata kiosk_metadata = 7;

    pub fn kiosk_metadata(&self) -> &KioskMetadata {
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::KioskMetadata(ref v)) => v,
            _ => <KioskMetadata as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_kiosk_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_kiosk_metadata(&self) -> bool {
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::KioskMetadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_kiosk_metadata(&mut self, v: KioskMetadata) {
        self.metadata = ::std::option::Option::Some(auth_factor::Metadata::KioskMetadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_kiosk_metadata(&mut self) -> &mut KioskMetadata {
        if let ::std::option::Option::Some(auth_factor::Metadata::KioskMetadata(_)) = self.metadata {
        } else {
            self.metadata = ::std::option::Option::Some(auth_factor::Metadata::KioskMetadata(KioskMetadata::new()));
        }
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::KioskMetadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_kiosk_metadata(&mut self) -> KioskMetadata {
        if self.has_kiosk_metadata() {
            match self.metadata.take() {
                ::std::option::Option::Some(auth_factor::Metadata::KioskMetadata(v)) => v,
                _ => panic!(),
            }
        } else {
            KioskMetadata::new()
        }
    }

    // .user_data_auth.SmartCardMetadata smart_card_metadata = 8;

    pub fn smart_card_metadata(&self) -> &SmartCardMetadata {
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::SmartCardMetadata(ref v)) => v,
            _ => <SmartCardMetadata as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_smart_card_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_smart_card_metadata(&self) -> bool {
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::SmartCardMetadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_smart_card_metadata(&mut self, v: SmartCardMetadata) {
        self.metadata = ::std::option::Option::Some(auth_factor::Metadata::SmartCardMetadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_smart_card_metadata(&mut self) -> &mut SmartCardMetadata {
        if let ::std::option::Option::Some(auth_factor::Metadata::SmartCardMetadata(_)) = self.metadata {
        } else {
            self.metadata = ::std::option::Option::Some(auth_factor::Metadata::SmartCardMetadata(SmartCardMetadata::new()));
        }
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::SmartCardMetadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_smart_card_metadata(&mut self) -> SmartCardMetadata {
        if self.has_smart_card_metadata() {
            match self.metadata.take() {
                ::std::option::Option::Some(auth_factor::Metadata::SmartCardMetadata(v)) => v,
                _ => panic!(),
            }
        } else {
            SmartCardMetadata::new()
        }
    }

    // .user_data_auth.LegacyFingerprintMetadata legacy_fingerprint_metadata = 11;

    pub fn legacy_fingerprint_metadata(&self) -> &LegacyFingerprintMetadata {
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::LegacyFingerprintMetadata(ref v)) => v,
            _ => <LegacyFingerprintMetadata as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_legacy_fingerprint_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_legacy_fingerprint_metadata(&self) -> bool {
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::LegacyFingerprintMetadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_legacy_fingerprint_metadata(&mut self, v: LegacyFingerprintMetadata) {
        self.metadata = ::std::option::Option::Some(auth_factor::Metadata::LegacyFingerprintMetadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_legacy_fingerprint_metadata(&mut self) -> &mut LegacyFingerprintMetadata {
        if let ::std::option::Option::Some(auth_factor::Metadata::LegacyFingerprintMetadata(_)) = self.metadata {
        } else {
            self.metadata = ::std::option::Option::Some(auth_factor::Metadata::LegacyFingerprintMetadata(LegacyFingerprintMetadata::new()));
        }
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::LegacyFingerprintMetadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_legacy_fingerprint_metadata(&mut self) -> LegacyFingerprintMetadata {
        if self.has_legacy_fingerprint_metadata() {
            match self.metadata.take() {
                ::std::option::Option::Some(auth_factor::Metadata::LegacyFingerprintMetadata(v)) => v,
                _ => panic!(),
            }
        } else {
            LegacyFingerprintMetadata::new()
        }
    }

    // .user_data_auth.FingerprintMetadata fingerprint_metadata = 12;

    pub fn fingerprint_metadata(&self) -> &FingerprintMetadata {
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::FingerprintMetadata(ref v)) => v,
            _ => <FingerprintMetadata as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_fingerprint_metadata(&mut self) {
        self.metadata = ::std::option::Option::None;
    }

    pub fn has_fingerprint_metadata(&self) -> bool {
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::FingerprintMetadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fingerprint_metadata(&mut self, v: FingerprintMetadata) {
        self.metadata = ::std::option::Option::Some(auth_factor::Metadata::FingerprintMetadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fingerprint_metadata(&mut self) -> &mut FingerprintMetadata {
        if let ::std::option::Option::Some(auth_factor::Metadata::FingerprintMetadata(_)) = self.metadata {
        } else {
            self.metadata = ::std::option::Option::Some(auth_factor::Metadata::FingerprintMetadata(FingerprintMetadata::new()));
        }
        match self.metadata {
            ::std::option::Option::Some(auth_factor::Metadata::FingerprintMetadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fingerprint_metadata(&mut self) -> FingerprintMetadata {
        if self.has_fingerprint_metadata() {
            match self.metadata.take() {
                ::std::option::Option::Some(auth_factor::Metadata::FingerprintMetadata(v)) => v,
                _ => panic!(),
            }
        } else {
            FingerprintMetadata::new()
        }
    }
}

impl ::protobuf::Message for AuthFactor {
    const NAME: &'static str = "AuthFactor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.label = is.read_string()?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.common_metadata)?;
                },
                34 => {
                    self.metadata = ::std::option::Option::Some(auth_factor::Metadata::PasswordMetadata(is.read_message()?));
                },
                42 => {
                    self.metadata = ::std::option::Option::Some(auth_factor::Metadata::PinMetadata(is.read_message()?));
                },
                50 => {
                    self.metadata = ::std::option::Option::Some(auth_factor::Metadata::CryptohomeRecoveryMetadata(is.read_message()?));
                },
                58 => {
                    self.metadata = ::std::option::Option::Some(auth_factor::Metadata::KioskMetadata(is.read_message()?));
                },
                66 => {
                    self.metadata = ::std::option::Option::Some(auth_factor::Metadata::SmartCardMetadata(is.read_message()?));
                },
                90 => {
                    self.metadata = ::std::option::Option::Some(auth_factor::Metadata::LegacyFingerprintMetadata(is.read_message()?));
                },
                98 => {
                    self.metadata = ::std::option::Option::Some(auth_factor::Metadata::FingerprintMetadata(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label);
        }
        if let Some(v) = self.common_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.metadata {
            match v {
                &auth_factor::Metadata::PasswordMetadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &auth_factor::Metadata::PinMetadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &auth_factor::Metadata::CryptohomeRecoveryMetadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &auth_factor::Metadata::KioskMetadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &auth_factor::Metadata::SmartCardMetadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &auth_factor::Metadata::LegacyFingerprintMetadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &auth_factor::Metadata::FingerprintMetadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.label.is_empty() {
            os.write_string(2, &self.label)?;
        }
        if let Some(v) = self.common_metadata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.metadata {
            match v {
                &auth_factor::Metadata::PasswordMetadata(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &auth_factor::Metadata::PinMetadata(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &auth_factor::Metadata::CryptohomeRecoveryMetadata(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &auth_factor::Metadata::KioskMetadata(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &auth_factor::Metadata::SmartCardMetadata(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &auth_factor::Metadata::LegacyFingerprintMetadata(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &auth_factor::Metadata::FingerprintMetadata(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AuthFactor {
        AuthFactor::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED);
        self.label.clear();
        self.common_metadata.clear();
        self.metadata = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.metadata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AuthFactor {
        static instance: AuthFactor = AuthFactor {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            label: ::std::string::String::new(),
            common_metadata: ::protobuf::MessageField::none(),
            metadata: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `AuthFactor`
pub mod auth_factor {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:user_data_auth.AuthFactor.metadata)
    pub enum Metadata {
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthFactor.password_metadata)
        PasswordMetadata(super::PasswordMetadata),
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthFactor.pin_metadata)
        PinMetadata(super::PinMetadata),
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthFactor.cryptohome_recovery_metadata)
        CryptohomeRecoveryMetadata(super::CryptohomeRecoveryMetadata),
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthFactor.kiosk_metadata)
        KioskMetadata(super::KioskMetadata),
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthFactor.smart_card_metadata)
        SmartCardMetadata(super::SmartCardMetadata),
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthFactor.legacy_fingerprint_metadata)
        LegacyFingerprintMetadata(super::LegacyFingerprintMetadata),
        // @@protoc_insertion_point(oneof_field:user_data_auth.AuthFactor.fingerprint_metadata)
        FingerprintMetadata(super::FingerprintMetadata),
    }

    impl ::protobuf::Oneof for Metadata {
    }

    impl Metadata {
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:user_data_auth.AuthFactorType)
pub enum AuthFactorType {
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthFactorType.AUTH_FACTOR_TYPE_UNSPECIFIED)
    AUTH_FACTOR_TYPE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthFactorType.AUTH_FACTOR_TYPE_PASSWORD)
    AUTH_FACTOR_TYPE_PASSWORD = 1,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthFactorType.AUTH_FACTOR_TYPE_PIN)
    AUTH_FACTOR_TYPE_PIN = 2,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthFactorType.AUTH_FACTOR_TYPE_CRYPTOHOME_RECOVERY)
    AUTH_FACTOR_TYPE_CRYPTOHOME_RECOVERY = 3,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthFactorType.AUTH_FACTOR_TYPE_KIOSK)
    AUTH_FACTOR_TYPE_KIOSK = 4,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthFactorType.AUTH_FACTOR_TYPE_SMART_CARD)
    AUTH_FACTOR_TYPE_SMART_CARD = 5,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthFactorType.AUTH_FACTOR_TYPE_LEGACY_FINGERPRINT)
    AUTH_FACTOR_TYPE_LEGACY_FINGERPRINT = 6,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthFactorType.AUTH_FACTOR_TYPE_FINGERPRINT)
    AUTH_FACTOR_TYPE_FINGERPRINT = 7,
}

impl ::protobuf::Enum for AuthFactorType {
    const NAME: &'static str = "AuthFactorType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthFactorType> {
        match value {
            0 => ::std::option::Option::Some(AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(AuthFactorType::AUTH_FACTOR_TYPE_PASSWORD),
            2 => ::std::option::Option::Some(AuthFactorType::AUTH_FACTOR_TYPE_PIN),
            3 => ::std::option::Option::Some(AuthFactorType::AUTH_FACTOR_TYPE_CRYPTOHOME_RECOVERY),
            4 => ::std::option::Option::Some(AuthFactorType::AUTH_FACTOR_TYPE_KIOSK),
            5 => ::std::option::Option::Some(AuthFactorType::AUTH_FACTOR_TYPE_SMART_CARD),
            6 => ::std::option::Option::Some(AuthFactorType::AUTH_FACTOR_TYPE_LEGACY_FINGERPRINT),
            7 => ::std::option::Option::Some(AuthFactorType::AUTH_FACTOR_TYPE_FINGERPRINT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AuthFactorType] = &[
        AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED,
        AuthFactorType::AUTH_FACTOR_TYPE_PASSWORD,
        AuthFactorType::AUTH_FACTOR_TYPE_PIN,
        AuthFactorType::AUTH_FACTOR_TYPE_CRYPTOHOME_RECOVERY,
        AuthFactorType::AUTH_FACTOR_TYPE_KIOSK,
        AuthFactorType::AUTH_FACTOR_TYPE_SMART_CARD,
        AuthFactorType::AUTH_FACTOR_TYPE_LEGACY_FINGERPRINT,
        AuthFactorType::AUTH_FACTOR_TYPE_FINGERPRINT,
    ];
}

impl ::std::default::Default for AuthFactorType {
    fn default() -> Self {
        AuthFactorType::AUTH_FACTOR_TYPE_UNSPECIFIED
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:user_data_auth.AuthFactorPreparePurpose)
pub enum AuthFactorPreparePurpose {
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthFactorPreparePurpose.PURPOSE_UNSPECIFIED)
    PURPOSE_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthFactorPreparePurpose.PURPOSE_ADD_AUTH_FACTOR)
    PURPOSE_ADD_AUTH_FACTOR = 1,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthFactorPreparePurpose.PURPOSE_AUTHENTICATE_AUTH_FACTOR)
    PURPOSE_AUTHENTICATE_AUTH_FACTOR = 2,
}

impl ::protobuf::Enum for AuthFactorPreparePurpose {
    const NAME: &'static str = "AuthFactorPreparePurpose";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthFactorPreparePurpose> {
        match value {
            0 => ::std::option::Option::Some(AuthFactorPreparePurpose::PURPOSE_UNSPECIFIED),
            1 => ::std::option::Option::Some(AuthFactorPreparePurpose::PURPOSE_ADD_AUTH_FACTOR),
            2 => ::std::option::Option::Some(AuthFactorPreparePurpose::PURPOSE_AUTHENTICATE_AUTH_FACTOR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AuthFactorPreparePurpose] = &[
        AuthFactorPreparePurpose::PURPOSE_UNSPECIFIED,
        AuthFactorPreparePurpose::PURPOSE_ADD_AUTH_FACTOR,
        AuthFactorPreparePurpose::PURPOSE_AUTHENTICATE_AUTH_FACTOR,
    ];
}

impl ::std::default::Default for AuthFactorPreparePurpose {
    fn default() -> Self {
        AuthFactorPreparePurpose::PURPOSE_UNSPECIFIED
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:user_data_auth.SmartCardSignatureAlgorithm)
pub enum SmartCardSignatureAlgorithm {
    // @@protoc_insertion_point(enum_value:user_data_auth.SmartCardSignatureAlgorithm.CHALLENGE_NOT_SPECIFIED)
    CHALLENGE_NOT_SPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:user_data_auth.SmartCardSignatureAlgorithm.CHALLENGE_RSASSA_PKCS1_V1_5_SHA1)
    CHALLENGE_RSASSA_PKCS1_V1_5_SHA1 = 1,
    // @@protoc_insertion_point(enum_value:user_data_auth.SmartCardSignatureAlgorithm.CHALLENGE_RSASSA_PKCS1_V1_5_SHA256)
    CHALLENGE_RSASSA_PKCS1_V1_5_SHA256 = 2,
    // @@protoc_insertion_point(enum_value:user_data_auth.SmartCardSignatureAlgorithm.CHALLENGE_RSASSA_PKCS1_V1_5_SHA384)
    CHALLENGE_RSASSA_PKCS1_V1_5_SHA384 = 3,
    // @@protoc_insertion_point(enum_value:user_data_auth.SmartCardSignatureAlgorithm.CHALLENGE_RSASSA_PKCS1_V1_5_SHA512)
    CHALLENGE_RSASSA_PKCS1_V1_5_SHA512 = 4,
}

impl ::protobuf::Enum for SmartCardSignatureAlgorithm {
    const NAME: &'static str = "SmartCardSignatureAlgorithm";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SmartCardSignatureAlgorithm> {
        match value {
            0 => ::std::option::Option::Some(SmartCardSignatureAlgorithm::CHALLENGE_NOT_SPECIFIED),
            1 => ::std::option::Option::Some(SmartCardSignatureAlgorithm::CHALLENGE_RSASSA_PKCS1_V1_5_SHA1),
            2 => ::std::option::Option::Some(SmartCardSignatureAlgorithm::CHALLENGE_RSASSA_PKCS1_V1_5_SHA256),
            3 => ::std::option::Option::Some(SmartCardSignatureAlgorithm::CHALLENGE_RSASSA_PKCS1_V1_5_SHA384),
            4 => ::std::option::Option::Some(SmartCardSignatureAlgorithm::CHALLENGE_RSASSA_PKCS1_V1_5_SHA512),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SmartCardSignatureAlgorithm] = &[
        SmartCardSignatureAlgorithm::CHALLENGE_NOT_SPECIFIED,
        SmartCardSignatureAlgorithm::CHALLENGE_RSASSA_PKCS1_V1_5_SHA1,
        SmartCardSignatureAlgorithm::CHALLENGE_RSASSA_PKCS1_V1_5_SHA256,
        SmartCardSignatureAlgorithm::CHALLENGE_RSASSA_PKCS1_V1_5_SHA384,
        SmartCardSignatureAlgorithm::CHALLENGE_RSASSA_PKCS1_V1_5_SHA512,
    ];
}

impl ::std::default::Default for SmartCardSignatureAlgorithm {
    fn default() -> Self {
        SmartCardSignatureAlgorithm::CHALLENGE_NOT_SPECIFIED
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:user_data_auth.AuthIntent)
pub enum AuthIntent {
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthIntent.AUTH_INTENT_UNSPECIFIED)
    AUTH_INTENT_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthIntent.AUTH_INTENT_DECRYPT)
    AUTH_INTENT_DECRYPT = 1,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthIntent.AUTH_INTENT_VERIFY_ONLY)
    AUTH_INTENT_VERIFY_ONLY = 2,
    // @@protoc_insertion_point(enum_value:user_data_auth.AuthIntent.AUTH_INTENT_WEBAUTHN)
    AUTH_INTENT_WEBAUTHN = 3,
}

impl ::protobuf::Enum for AuthIntent {
    const NAME: &'static str = "AuthIntent";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthIntent> {
        match value {
            0 => ::std::option::Option::Some(AuthIntent::AUTH_INTENT_UNSPECIFIED),
            1 => ::std::option::Option::Some(AuthIntent::AUTH_INTENT_DECRYPT),
            2 => ::std::option::Option::Some(AuthIntent::AUTH_INTENT_VERIFY_ONLY),
            3 => ::std::option::Option::Some(AuthIntent::AUTH_INTENT_WEBAUTHN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AuthIntent] = &[
        AuthIntent::AUTH_INTENT_UNSPECIFIED,
        AuthIntent::AUTH_INTENT_DECRYPT,
        AuthIntent::AUTH_INTENT_VERIFY_ONLY,
        AuthIntent::AUTH_INTENT_WEBAUTHN,
    ];
}

impl ::std::default::Default for AuthIntent {
    fn default() -> Self {
        AuthIntent::AUTH_INTENT_UNSPECIFIED
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:user_data_auth.LockoutPolicy)
pub enum LockoutPolicy {
    // @@protoc_insertion_point(enum_value:user_data_auth.LockoutPolicy.LOCKOUT_POLICY_UNKNOWN)
    LOCKOUT_POLICY_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:user_data_auth.LockoutPolicy.LOCKOUT_POLICY_NONE)
    LOCKOUT_POLICY_NONE = 1,
    // @@protoc_insertion_point(enum_value:user_data_auth.LockoutPolicy.LOCKOUT_POLICY_ATTEMPT_LIMITED)
    LOCKOUT_POLICY_ATTEMPT_LIMITED = 2,
    // @@protoc_insertion_point(enum_value:user_data_auth.LockoutPolicy.LOCKOUT_POLICY_TIME_LIMITED)
    LOCKOUT_POLICY_TIME_LIMITED = 3,
}

impl ::protobuf::Enum for LockoutPolicy {
    const NAME: &'static str = "LockoutPolicy";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LockoutPolicy> {
        match value {
            0 => ::std::option::Option::Some(LockoutPolicy::LOCKOUT_POLICY_UNKNOWN),
            1 => ::std::option::Option::Some(LockoutPolicy::LOCKOUT_POLICY_NONE),
            2 => ::std::option::Option::Some(LockoutPolicy::LOCKOUT_POLICY_ATTEMPT_LIMITED),
            3 => ::std::option::Option::Some(LockoutPolicy::LOCKOUT_POLICY_TIME_LIMITED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LockoutPolicy] = &[
        LockoutPolicy::LOCKOUT_POLICY_UNKNOWN,
        LockoutPolicy::LOCKOUT_POLICY_NONE,
        LockoutPolicy::LOCKOUT_POLICY_ATTEMPT_LIMITED,
        LockoutPolicy::LOCKOUT_POLICY_TIME_LIMITED,
    ];
}

impl ::std::default::Default for LockoutPolicy {
    fn default() -> Self {
        LockoutPolicy::LOCKOUT_POLICY_UNKNOWN
    }
}

