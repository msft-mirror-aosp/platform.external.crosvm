diff --git a/base/Android.bp b/base/Android.bp
index 32859ea24..5d7e55e42 100644
--- a/base/Android.bp
+++ b/base/Android.bp
@@ -15,7 +15,7 @@ package {
 rust_test {
     name: "base_test_src_lib",
     defaults: ["crosvm_inner_defaults"],
-    host_supported: true,
+    host_supported: false, // Can't seem to access syslog in TH host tests.
     crate_name: "base",
     cargo_env_compat: true,
     cargo_pkg_version: "0.1.0",
@@ -47,12 +47,31 @@ rust_test {
         "libbase_event_token_derive",
         "libremain",
     ],
+    target: {
+        android: {
+            rustlibs: ["libandroid_log_sys"],
+        },
+        linux_bionic_arm64: {
+            // For ARM architecture, we use aarch64-linux-android for BOTH
+            // device and host targets. As a result, host targets are also
+            // built with target_os = "android". Therefore, sys_util/src/android
+            // is used and thus this android module is required.
+            // This seems incorrect, but is inevitable because rustc doesn't
+            // yet support a Linux-based target using Bionic as libc. We can't
+            // use aarch64-unknown-linux-gnu because it's using glibc which
+            // we don't support for cross-host builds.
+            rustlibs: [
+                "libandroid_log_sys",
+            ],
+        },
+    },
+    shared_libs: ["libcap"], // specified in src/linux/capabilities.rs
 }
 
 rust_test {
     name: "base_test_tests_linux_main",
     defaults: ["crosvm_inner_defaults"],
-    host_supported: true,
+    host_supported: false, // Can't seem to access syslog in TH host tests.
     crate_name: "linux",
     cargo_env_compat: true,
     cargo_pkg_version: "0.1.0",
@@ -161,6 +180,25 @@ rust_test {
         "libbase_event_token_derive",
         "libremain",
     ],
+    target: {
+        android: {
+            rustlibs: ["libandroid_log_sys"],
+        },
+        linux_bionic_arm64: {
+            // For ARM architecture, we use aarch64-linux-android for BOTH
+            // device and host targets. As a result, host targets are also
+            // built with target_os = "android". Therefore, sys_util/src/android
+            // is used and thus this android module is required.
+            // This seems incorrect, but is inevitable because rustc doesn't
+            // yet support a Linux-based target using Bionic as libc. We can't
+            // use aarch64-unknown-linux-gnu because it's using glibc which
+            // we don't support for cross-host builds.
+            rustlibs: [
+                "libandroid_log_sys",
+            ],
+        },
+    },
+    shared_libs: ["libcap"], // specified in src/linux/capabilities.rs
 }
 
 rust_library {
@@ -194,4 +232,23 @@ rust_library {
     ],
     apex_available: ["com.android.virt"],
     visibility: ["//vendor:__subpackages__"],
+    target: {
+        android: {
+            rustlibs: ["libandroid_log_sys"],
+        },
+        linux_bionic_arm64: {
+            // For ARM architecture, we use aarch64-linux-android for BOTH
+            // device and host targets. As a result, host targets are also
+            // built with target_os = "android". Therefore, sys_util/src/android
+            // is used and thus this android module is required.
+            // This seems incorrect, but is inevitable because rustc doesn't
+            // yet support a Linux-based target using Bionic as libc. We can't
+            // use aarch64-unknown-linux-gnu because it's using glibc which
+            // we don't support for cross-host builds.
+            rustlibs: [
+                "libandroid_log_sys",
+            ],
+        },
+    },
+    shared_libs: ["libcap"], // specified in src/linux/capabilities.rs
 }
